# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to create the Asset Metadata for", "name": "asset_id"}, {"type": "byte", "desc": "The Reversible Flags. WARNING: LSB and 1 can by set only at creation time", "name": "reversible_flags"}, {"type": "byte", "desc": "The Irreversible Flags. WARNING: if the MSB is True the Asset Metadata is IMMUTABLE", "name": "irreversible_flags"}, {"type": "uint16", "desc": "The Metadata byte size to be created", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}, {"type": "pay", "desc": "Payment of the MBR Delta amount (microALGO) for the Asset Metadata Box creation", "name": "mbr_delta_payment"}], "name": "arc89_create_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Create Asset Metadata for an existing ASA, restricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Metadata byte size, must be less than or equal to the existing", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}], "name": "arc89_replace_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Replace mutable Metadata with a smaller or equal size payload for an existing ASA,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Metadata byte size, must be larger than the existing", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}, {"type": "pay", "desc": "Payment of the MBR Delta amount (microALGO) for the larger Asset Metadata Box replace", "name": "mbr_delta_payment"}], "name": "arc89_replace_metadata_larger", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Replace mutable Metadata with a larger size payload for an existing ASA,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata slice for", "name": "asset_id"}, {"type": "uint16", "desc": "The 0-based byte offset within the Metadata (body) bytes", "name": "offset"}, {"type": "byte[]", "desc": "The slice payload", "name": "payload"}], "name": "arc89_replace_metadata_slice", "returns": {"type": "void"}, "desc": "Replace a slice of the Asset Metadata for an ASA with a payload of the same size,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to migrate the Asset Metadata for", "name": "asset_id"}, {"type": "uint64", "desc": "The Application ID of the new ASA Metadata Registry version", "name": "new_registry_id"}], "name": "arc89_migrate_metadata", "returns": {"type": "void"}, "desc": "Migrate the Asset Metadata for an ASA to a new ASA Metadata Registry version,\nrestricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "new_registry_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataMigrated", "desc": "Event emitted when Asset Metadata has been migrated to a new ASA Metadata Registry version"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to delete the Asset Metadata for", "name": "asset_id"}], "name": "arc89_delete_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Delete Asset Metadata for an ASA, restricted to the ASA Manager Address (if the ASA still exists).", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataDeleted", "desc": "Event emitted when Asset Metadata is deleted"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to provide Metadata extra payload for", "name": "asset_id"}, {"type": "byte[]", "desc": "The Metadata extra payload to concatenate", "name": "payload"}], "name": "arc89_extra_payload", "returns": {"type": "void"}, "desc": "Concatenate extra payload to Asset Metadata head call methods (creation or replacement).", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set the Metadata Flag for", "name": "asset_id"}, {"type": "uint8", "desc": "The reversible flag index to set", "name": "flag"}, {"type": "bool", "desc": "The flag value to set", "name": "value"}], "name": "arc89_set_reversible_flag", "returns": {"type": "void"}, "desc": "Set a reversible Asset Metadata Flag, restricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set the Metadata Flag for", "name": "asset_id"}, {"type": "uint8", "desc": "The irreversible flag index to set. WARNING: must be in 2 ... 6", "name": "flag"}], "name": "arc89_set_irreversible_flag", "returns": {"type": "void"}, "desc": "Set an irreversible Asset Metadata Flag, restricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set immutable Asset Metadata for", "name": "asset_id"}], "name": "arc89_set_immutable", "returns": {"type": "void"}, "desc": "Set Asset Metadata as immutable, restricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "arc89_get_metadata_registry_parameters", "returns": {"type": "(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", "desc": "Tuple of (HEADER_SIZE, MAX_METADATA_SIZE, SHORT_METADATA_SIZE, PAGE_SIZE, FIRST_PAYLOAD_MAX_SIZE, EXTRA_PAYLOAD_MAX_SIZE, REPLACE_PAYLOAD_MAX_SIZE, FLAT_MBR, BYTE_MBR)", "struct": "RegistryParameters"}, "desc": "Return the ASA Metadata Registry parameters.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "arc89_get_metadata_partial_uri", "returns": {"type": "string", "desc": "Asset Metadata ARC-90 partial URI, without compliance fragment"}, "desc": "Return the Asset Metadata ARC-90 partial URI, without compliance fragment (optional)", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to calculate the Asset Metadata MBR Delta for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Asset Metadata byte size", "name": "new_metadata_size"}], "name": "arc89_get_metadata_mbr_delta", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Return the Asset Metadata Box MBR Delta for an ASA, given a new Asset Metadata byte size.\nIf the Asset Metadata Box does not exist, the creation MBR Delta is returned.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the ASA and Asset Metadata existence for", "name": "asset_id"}], "name": "arc89_check_metadata_exists", "returns": {"type": "(bool,bool)", "desc": "Tuple of (ASA exists, Asset Metadata exists)", "struct": "MetadataExistence"}, "desc": "Checks whether the specified ASA exists and whether its associated Asset Metadata is available.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the Asset Metadata immutability for", "name": "asset_id"}], "name": "arc89_is_metadata_immutable", "returns": {"type": "bool", "desc": "Asset Metadata for the ASA is immutable"}, "desc": "Return True if the Asset Metadata for an ASA is immutable, False otherwise.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the Asset Metadata size classification for", "name": "asset_id"}], "name": "arc89_is_metadata_short", "returns": {"type": "(bool,uint64)", "desc": "Tuple of (is short metadata, Metadata Last Modified Round)", "struct": "MutableFlag"}, "desc": "Return True if Asset Metadata for an ASA is short (up to 4096 bytes), False otherwise.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata Header for", "name": "asset_id"}], "name": "arc89_get_metadata_header", "returns": {"type": "(byte,byte,byte,byte[32],uint64,uint64)", "desc": "Asset Metadata Header: (Identifiers, Reversible Flags, Irreversible Flags, Hash, Last Modified Round, Deprecated By)", "struct": "MetadataHeader"}, "desc": "Return the Asset Metadata Header for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata pagination for", "name": "asset_id"}], "name": "arc89_get_metadata_pagination", "returns": {"type": "(uint16,uint16,uint8)", "desc": "Tuple of (total metadata byte size, PAGE_SIZE, total number of pages)", "struct": "Pagination"}, "desc": "Return the Asset Metadata pagination for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata for", "name": "asset_id"}, {"type": "uint8", "desc": "The 0-based Metadata page number", "name": "page"}], "name": "arc89_get_metadata", "returns": {"type": "(bool,uint64,byte[])", "desc": "Tuple of (has next page, Metadata Last Modified Round, page content)", "struct": "PaginatedMetadata"}, "desc": "Return paginated Asset Metadata (without Header) for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata slice for", "name": "asset_id"}, {"type": "uint16", "desc": "The 0-based byte offset within the Metadata (body) bytes", "name": "offset"}, {"type": "uint16", "desc": "The slice bytes size to return", "name": "size"}], "name": "arc89_get_metadata_slice", "returns": {"type": "byte[]", "desc": "Asset Metadata slice (size limited to PAGE_SIZE)"}, "desc": "Return a slice of the Asset Metadata for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Metadata Header Hash for", "name": "asset_id"}], "name": "arc89_get_metadata_header_hash", "returns": {"type": "byte[32]", "desc": "Asset Metadata Header Hash"}, "desc": "Return the Metadata Header Hash for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata page hash for", "name": "asset_id"}, {"type": "uint8", "desc": "The 0-based Metadata page number", "name": "page"}], "name": "arc89_get_metadata_page_hash", "returns": {"type": "byte[32]", "desc": "The SHA512-256 of the Metadata page"}, "desc": "Return the SHA512-256 of a Metadata page for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Metadata Hash for", "name": "asset_id"}], "name": "arc89_get_metadata_hash", "returns": {"type": "byte[32]", "desc": "Asset Metadata Hash"}, "desc": "Return the Metadata Hash for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose string value to fetch", "name": "key"}], "name": "arc89_get_metadata_string_by_key", "returns": {"type": "string", "desc": "The string value from valid UTF-8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the UTF-8 string value for a top-level JSON key of type JSON String\nfrom short Metadata for an ASA; errors if the key does not exist or is not a JSON String", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose uint64 value to fetch", "name": "key"}], "name": "arc89_get_metadata_uint64_by_key", "returns": {"type": "uint64", "desc": "The uint64 value from valid UTF-8 JSON Metadata"}, "desc": "Return the uint64 value for a top-level JSON key of type JSON Uint64 from\nshort Metadata for an ASA; errors if the key does not exist or is not a JSON Uint64", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose object value to fetch", "name": "key"}], "name": "arc89_get_metadata_object_by_key", "returns": {"type": "string", "desc": "The object value from valid UTF-8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the UTF-8 object value for a top-level JSON key of type JSON Object\nfrom short Metadata for an ASA; errors if the key does not exist or is not a JSON Object", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top-level JSON key whose base64 string value to fetch and decode", "name": "key"}, {"type": "uint8", "desc": "base64 encoding enum: 0 = URLEncoding, 1 = StdEncoding", "name": "b64_encoding"}], "name": "arc89_get_metadata_b64_bytes_by_key", "returns": {"type": "byte[]", "desc": "The base64-decoded bytes from valid UTF-8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the base64-decoded bytes for a top-level JSON key of type JSON String\nfrom short Metadata for an ASA; errors if the key does not exist, is not a JSON String, or is not valid base64 for the chosen encoding", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "extra_resources", "returns": {"type": "void"}, "desc": "Non-normative placeholder method to acquire AVM extra resources.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "withdraw_balance_excess", "returns": {"type": "void"}, "desc": "Non-normative method to withdraw balance excess due to accidental deposits\n(it should never happen if deposits match exactly the required MBR. Deleted metadata MBR is not included in the excess, since it is immediately returned on delete).", "events": [], "readonly": false, "recommendations": {}}], "name": "AsaMetadataRegistry", "state": {"keys": {"box": {}, "global": {}, "local": {}}, "maps": {"box": {"asset_metadata": {"keyType": "uint64", "valueType": "AVMBytes", "prefix": ""}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 0}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"MbrDelta": [{"name": "sign", "type": "uint8"}, {"name": "amount", "type": "uint64"}], "MetadataExistence": [{"name": "asa_exists", "type": "bool"}, {"name": "metadata_exists", "type": "bool"}], "MetadataHeader": [{"name": "identifiers", "type": "byte"}, {"name": "reversible_flags", "type": "byte"}, {"name": "irreversible_flags", "type": "byte"}, {"name": "hash", "type": "byte[32]"}, {"name": "last_modified_round", "type": "uint64"}, {"name": "deprecated_by", "type": "uint64"}], "MutableFlag": [{"name": "flag", "type": "bool"}, {"name": "last_modified_round", "type": "uint64"}], "PaginatedMetadata": [{"name": "has_next_page", "type": "bool"}, {"name": "last_modified_round", "type": "uint64"}, {"name": "page_content", "type": "byte[]"}], "Pagination": [{"name": "metadata_size", "type": "uint16"}, {"name": "page_size", "type": "uint16"}, {"name": "total_pages", "type": "uint8"}], "RegistryParameters": [{"name": "header_size", "type": "uint16"}, {"name": "max_metadata_size", "type": "uint16"}, {"name": "short_metadata_size", "type": "uint16"}, {"name": "page_size", "type": "uint16"}, {"name": "first_payload_max_size", "type": "uint16"}, {"name": "extra_payload_max_size", "type": "uint16"}, {"name": "replace_payload_max_size", "type": "uint16"}, {"name": "flat_mbr", "type": "uint64"}, {"name": "byte_mbr", "type": "uint64"}]}, "byteCode": {"approval": "DCAHAQAIAu8H7geq7gEmCAQVH3x1AAEABDesdV0DBoEBBRUffHUBAAAxG0EBATEZFEQxGESCBgR4QHgxBLgup+8EEkX6+wQEXy5uBN3/y5IEFbJ1siuCFgS1Eh2KBEn7rpEEC1OM4wSaqa8lBAifrqEEjl4QJAQkTEfEBC1Z9uAE7oW0cwS3WTG8BI8l73IEEcOEdgSwq/ZbBM6dvtcEylL7HgQiY5G5BHoT1TIEU8IiAwTTdyrTBH2ir0AEAFbZwQS5LiZ6NhoAjh0BSwMdA6YEIASBBMsFTAV4Bc8GFQADBi0GOQa3Bt8HEAc3B4AHvAgsCG4IhAi7CNQJBQkxCWIAAQmtACJDgCIVH3x1ADN3KhAAA+8H7gfyB/AAAAAAAAAJxAAAAAAAAAGQsCJDMRkUMRgUEEQxACcGEkQiQ4oCAIv+gQoIiwAyDA1BACqxgQayEIEFshknBLIeJwSyH4v/jQIACwAEs0L/2zIAsgFC//UjsgFC/++JigIBi/8Vi/4VSg5ESU8CCUlLAg9LAkxNi/5MTwJSi/8SiYoCASNJKTIRgCDAYcTY/B293tLXYEvkVo4/bQQZh6w3veS2ILWrOSSK3xJBAIEpgAthbGdvcmFuZDovL0xQgARhcHAvUIwBKYwAi/6MAosCQQBAiwJJgQoYSYEKD0sBgQpPAk1MIghJgQoPgQpMTUlLAgxLAkxNgAowMTIzNDU2Nzg5TgJSiwBQjACBCgqMAkL/u4sASRWAATBOAk2LAUxQgAU/Ym94PVCL/1CMAIknB0L/eyNHAylJNhoBSRUkEkQXSTYaAklOAhUiEkQ2GgNJTgIVIhJENhoESRUlEkQ2GgVJI1klCEsBFRJEMRYiCUlOBEk4ECISRE8CF0lOBEsDTIgKQU8CFklOA0m9RQEUREw4BzIKEkQyCnMBTE4DRCO5SFcCAEkVQQAHgbwFI4j+cUsHSUsFSwOICC1JiAkXSwcXFlcHAUsESU4CIk8Cu0sHFxZXBwElTLtxBkSAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE0EA+UsCJSK6I1NESwdxBkxFDERLAkmBA0sNuzIGFksBgSNPArsjFksBgStPArslIrqBB1NBAB5LB0lxBExJTgNFEERxBUxFDkSABGFyYzMSQQBtIkRLAiUiuoEGU0EAIzIIKYj+GklFD0sIcQVMSU4CRQ9EFUlFDEwVSUULDEEAISNESwdLC4gJmDIKcwFESwIJSwU4CEsBD0QWJwVMULAiQ0sISUsLSU4DDkRJSwIPTE4CTUsMI08CUksOEkL/wksMFYEFD0EAE0sMgAVAYXJjM4j9iUEABCJC/3hLCxWBBQ9BABNLC4AFI2FyYzOI/W1BAAQiQv9cI0L/WEsHiAhqRQtC/w02GgFJFSQSRBdJNhoCSRUlEkQ2GgNJI1klCEsBFRJETBdLAksBiAivSwKIBpNLAQ9EMgpzAURPAlcCAEsDSwNPAogGn0sCiAkmTwKIBnJPAhJEMgpzAUQJSUAAFCMWSZMkDkRXBwFLARZQKExQsCJDgf8BsUsCcQdESwKyCLIHIrIQI7IBs0L/1DYaAUkVJBJEFzYaAkkVJRJENhoDSSNZJQhLARUSRDEWIglJOBAiEkRPAhdLA0sBiAgcSwOIBgBLAQxESwE4BzIKEkQyCnMBRE8DVwIASwRLA08CiAYESwOICItPA4gF108CEkQyCnMBREwJTDgISwEPRBYnBUxQsCJDNhoBSRUkEkQXSTYaAkkVJRJENhoDSSNZJQhLARUSREsCiAWZSwNMiAeqTBdMVwIASU4DSRVLAksBCEsEiAV+DkRPAxZJTgSBM08ECElOBE8CuhNBAAlKSwS7SwOICA0iQzYaAUkVJBJESRc2GgJJFSQSREsBiAeIF0kyCBNETBZMFksBgStPArsyBhYyBxZPAoErJLoXFk8DTFBPAlBMUIAEyHAjv0xQsCJDKTYaAUcCFSQSRBdHAhZJTgK9RQFEcQtFAUEADkklIrojUxRESwGIB7xEMgpzAURLAbxIMgpzAUQJRQSxSwFxC0UBQQA3SwFxB0RLBEmyCEyyByKyECOyAbMyBhYyBxZLBU8CUExQgAS8PyDRTFCwFoAFFR98df9MULAiQzEAQv/JNhoBSRUkEkQXNhoCSSNZJQhMFRJEMgQlD0RJcQtFAURJFr1FAUSIBztEIkM2GgFJFSQSRBdJNhoCSRUiEkQ2GgNJFSISREsCiAaJTBdJgQcORE8CFklOAyJJuoEHTwIJSU4DU0wjU0lPAhNBABNLAkkiSbpLA0sDVCJMu0sDiAa/IkM2GgFJFSQSRBdJNhoCSRUiEkRMiAY7F0klD0EAJUmBBg5BAB4iREsBFiUiuoEHSwIJU0AAC0sBSUsCiAO8iAZ9IkMjQv/fNhoBSRUkEkQXSYgF/kmBB4gDoIgGYSJDMggpiPpkKExQsCJDKUk2GgFJFSQSRBdJNhoCSRUlEkQXSU4CIQYORBa9RQFBAExLAYgDfElFBCNFBUsBEkEAHiNJgZADTwILSwUITBZJkyQORFcHAUwWUChMULAiQ0lLAw1BAAoiSwFLBAlMQv/Tgf8BSwNLAglMQv/HgcQTRQQigTtLAghMQv+4NhoBSRUkEkQXSXELRQEqI08CVEwWvUUBKiNPAlQjUyJMVChMULAiQzYaAUkVJBJEF0cCiAUhFiUiuiNTQAAKSXEHRDIDEkEADCIqI08CVChMULAiQyNC//E2GgFJFSQSRBdJiATxFkkjIrojUyojTwJUTIEjJLoXFlAoTFCwIkM2GgFJFSQSRBdJiATKFkkjIrpLASJJuksCJSK6SwODAgMguksEgSMkuhcWTwWBKyS6FxZPBU8FUE8EUE8DUE8CUExQKExQsCJDNhoBSRUkEkQXSYgEgUmIAkwWSZOBEA5EVwYCTIgCPiEFCCEEChZJkyQORFcHAUyAAgPvUExQKExQsCJDKTYaAUkVJBJEF0k2GgJJTgIVIhJESYgEOYgCBSEFCCEECklOAkEAPhdJSwJJTgIMRCIJSwENRQRLAkyIAqUqI0sFVEsDFoEjJLoXFk8CSRUWVwYCTFBOAlCAAgALUExQKExQsCJDFxREI0UDKUL/zjYaAUkVJBJEFzYaAkkVJRJENhoDSRUlEkRLAogDxBdJIQQOREwXSUsCCEsDiAGCDkRPAhaBM08CCE8CuihMULAiQzYaAUkVJBJEF0mIA5OIAowoTFCwIkM2GgFJFSQSRBc2GgJJFSISREsBiAN0SwGIAT4hBQghBApJREwXSU8CDERKiAHtiAKYKExQsCJDNhoBSRUkEkQXSYgDRhaDAgMguihMULAiQzYaAUkVJBJEFzYaAkkjWSUISwEVEkRLAYgDH0yIAeRMVwIAXwBJFSEEDkQoTFCwIkM2GgFJFSQSRBc2GgJJI1klCEsBFRJESwGIAu5MiAGzTFcCAF8BFihMULAiQzYaAUkVJBJEFzYaAkkjWSUISwEVEkRLAYgCwkyIAYdMVwIAXwJJFSEEDkQoTFCwIkM2GgFJFSQSRBc2GgJJI1klCEsBFRJENhoDSRUiEkRLAogCiRdJIg5ETwKIAUhPAlcCAF8ATEAADl4ASRUhBA5EKExQsCJDXgFC/+8yCnMARDIKcwFECbEyCbIHsggishAjsgGzIkOKAgCL/hZJJSK6gQeL/wkiVCVMu4mKAQGL/xa9RIEzCYmKAgCL/hZJvUSL/xVLAQhLAkzTi/+7iYoDAIv9FkmBM9OL/Yv/iP/Yi/2I/8eL/g5EMgQxFiIIiwKLAQxBAG2LAjgQgQYSQQBfiwI4GDIIEkEAVYsCOBlAAE4iQQBGiwIjwhorEkEAPIsCIsIaiwASQQAxIkEAJIsCJcIaVwIAi/2I/3BLARUIi/4ORIv9TIj/bov9iP9di/4ORIsCIgiMAkL/kyNC/8wjQv+vi/2I/0OL/hJEiYoCAYv+iP82SYv/IQQLSU8CD0EABCmMAImLAIsBSU4CCSEESwEMIQRMTYv+FoEzTwMITwK6jACJigEBi/8WSSMiuiNTRIv/iP70gTNMuomKAQCL/4j+54v/FkkjIrpPAoGAIA4jTFQjTLuJigEBgW4jiPUni/8WSSMiuksBIkm6SwIlIrqL/4j+tBZXBgKADmFyYzAwODkvaGVhZGVyTwVQTwRQTwNQTwJQTFADiYoDAYGWASOI9OOL/RaL/hZXBwGL/xUWVwYCgAxhcmMwMDg5L3BhZ2VPA1BPAlBMUIv/UAOJigEBKYv/iP9/i/+I/k0hBQghBApJKUxBACsjjACLAIsCDEEAIIv/iwBJTgKI/u6L/0sCTwKI/5OLA0xQjAMiCIwAQv/YgAphcmMwMDg5L2FtiwFQiwNQA4wAiYoCAIv+cQtFAUSL/ogAxESL/yEGDkSJigIAi/6L/4j/34v+Fkm9RQFEJSK6I1MURImKAQCL/3ELRQFEi/8WvUUBRImKAQCL/4j/5ov/iACDRIv/FiUiuiNTFESJigIAi/4WMgYWMgcWSwIiSboXFkmTJA5EVwcBSwMlIroXFkmTJA5EVwcBSwQjIrojUyojTwJUTwVPBVBPBFBPA1BPAlBMUIv/UIAEiwNQhExQsImKAQCL/4j+Wov/iP7pi/8WSYEDSwO7MgYWgSNMu4v/TIj/iomKAQExAIv/cQdEEok=", "clear": "DIEBQw=="}, "desc": "\n    Singleton Application providing ASA metadata via Algod API and AVM\n    ", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}, {"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "new_registry_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataMigrated", "desc": "Event emitted when Asset Metadata has been migrated to a new ASA Metadata Registry version"}, {"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataDeleted", "desc": "Event emitted when Asset Metadata is deleted"}], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEyCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAxIDAgOCAyIDEwMDcgMTAwNiAzMDUwNgogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1IDB4IDB4MDAgMHgzN2FjNzU1ZCAweDA2ODEwMSAweDE1MWY3Yzc1MDEgVE1QTF9UUlVTVEVEX0RFUExPWUVSIFRNUExfQVJDOTBfTkVUQVVUSAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNwogICAgLy8gY2xhc3MgQXNhTWV0YWRhdGFSZWdpc3RyeShBcmM4OUludGVyZmFjZSwgQXNhVmFsaWRhdGlvbik6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9kZXBsb3lAMzgKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydAogICAgcHVzaGJ5dGVzcyAweDc4NDA3ODMxIDB4YjgyZWE3ZWYgMHgxMjQ1ZmFmYiAweDA0NWYyZTZlIDB4ZGRmZmNiOTIgMHgxNWIyNzViMiAvLyBtZXRob2QgImFyYzg5X2NyZWF0ZV9tZXRhZGF0YSh1aW50NjQsYnl0ZSxieXRlLHVpbnQxNixieXRlW10scGF5KSh1aW50OCx1aW50NjQpIiwgbWV0aG9kICJhcmM4OV9yZXBsYWNlX21ldGFkYXRhKHVpbnQ2NCx1aW50MTYsYnl0ZVtdKSh1aW50OCx1aW50NjQpIiwgbWV0aG9kICJhcmM4OV9yZXBsYWNlX21ldGFkYXRhX2xhcmdlcih1aW50NjQsdWludDE2LGJ5dGVbXSxwYXkpKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfc2xpY2UodWludDY0LHVpbnQxNixieXRlW10pdm9pZCIsIG1ldGhvZCAiYXJjODlfbWlncmF0ZV9tZXRhZGF0YSh1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgImFyYzg5X2RlbGV0ZV9tZXRhZGF0YSh1aW50NjQpKHVpbnQ4LHVpbnQ2NCkiCiAgICBieXRlY18zIC8vIG1ldGhvZCAiYXJjODlfZXh0cmFfcGF5bG9hZCh1aW50NjQsYnl0ZVtdKXZvaWQiCiAgICBwdXNoYnl0ZXNzIDB4YjUxMjFkOGEgMHg0OWZiYWU5MSAweDBiNTM4Y2UzIDB4OWFhOWFmMjUgMHgwODlmYWVhMSAweDhlNWUxMDI0IDB4MjQ0YzQ3YzQgMHgyZDU5ZjZlMCAweGVlODViNDczIDB4Yjc1OTMxYmMgMHg4ZjI1ZWY3MiAweDExYzM4NDc2IDB4YjBhYmY2NWIgMHhjZTlkYmVkNyAweGNhNTJmYjFlIDB4MjI2MzkxYjkgMHg3YTEzZDUzMiAweDUzYzIyMjAzIDB4ZDM3NzJhZDMgMHg3ZGEyYWY0MCAweDAwNTZkOWMxIDB4YjkyZTI2N2EgLy8gbWV0aG9kICJhcmM4OV9zZXRfcmV2ZXJzaWJsZV9mbGFnKHVpbnQ2NCx1aW50OCxib29sKXZvaWQiLCBtZXRob2QgImFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZyh1aW50NjQsdWludDgpdm9pZCIsIG1ldGhvZCAiYXJjODlfc2V0X2ltbXV0YWJsZSh1aW50NjQpdm9pZCIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3JlZ2lzdHJ5X3BhcmFtZXRlcnMoKSh1aW50MTYsdWludDE2LHVpbnQxNix1aW50MTYsdWludDE2LHVpbnQxNix1aW50MTYsdWludDY0LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9wYXJ0aWFsX3VyaSgpc3RyaW5nIiwgbWV0aG9kICJhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhKHVpbnQ2NCx1aW50MTYpKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2NoZWNrX21ldGFkYXRhX2V4aXN0cyh1aW50NjQpKGJvb2wsYm9vbCkiLCBtZXRob2QgImFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZSh1aW50NjQpYm9vbCIsIG1ldGhvZCAiYXJjODlfaXNfbWV0YWRhdGFfc2hvcnQodWludDY0KShib29sLHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXIodWludDY0KShieXRlLGJ5dGUsYnl0ZSxieXRlWzMyXSx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2luYXRpb24odWludDY0KSh1aW50MTYsdWludDE2LHVpbnQ4KSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhKHVpbnQ2NCx1aW50OCkoYm9vbCx1aW50NjQsYnl0ZVtdKSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3NsaWNlKHVpbnQ2NCx1aW50MTYsdWludDE2KWJ5dGVbXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlcl9oYXNoKHVpbnQ2NClieXRlWzMyXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaCh1aW50NjQsdWludDgpYnl0ZVszMl0iLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9oYXNoKHVpbnQ2NClieXRlWzMyXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3N0cmluZ19ieV9rZXkodWludDY0LHN0cmluZylzdHJpbmciLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5KHVpbnQ2NCxzdHJpbmcpdWludDY0IiwgbWV0aG9kICJhcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleSh1aW50NjQsc3RyaW5nKXN0cmluZyIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX2I2NF9ieXRlc19ieV9rZXkodWludDY0LHN0cmluZyx1aW50OClieXRlW10iLCBtZXRob2QgImV4dHJhX3Jlc291cmNlcygpdm9pZCIsIG1ldGhvZCAid2l0aGRyYXdfYmFsYW5jZV9leGNlc3MoKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBhcmM4OV9jcmVhdGVfbWV0YWRhdGEgYXJjODlfcmVwbGFjZV9tZXRhZGF0YSBhcmM4OV9yZXBsYWNlX21ldGFkYXRhX2xhcmdlciBhcmM4OV9yZXBsYWNlX21ldGFkYXRhX3NsaWNlIGFyYzg5X21pZ3JhdGVfbWV0YWRhdGEgYXJjODlfZGVsZXRlX21ldGFkYXRhIGFyYzg5X2V4dHJhX3BheWxvYWQgYXJjODlfc2V0X3JldmVyc2libGVfZmxhZyBhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWcgYXJjODlfc2V0X2ltbXV0YWJsZSBtYWluX2FyYzg5X2dldF9tZXRhZGF0YV9yZWdpc3RyeV9wYXJhbWV0ZXJzX3JvdXRlQDE2IGFyYzg5X2dldF9tZXRhZGF0YV9wYXJ0aWFsX3VyaSBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhIGFyYzg5X2NoZWNrX21ldGFkYXRhX2V4aXN0cyBhcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGUgYXJjODlfaXNfbWV0YWRhdGFfc2hvcnQgYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlciBhcmM4OV9nZXRfbWV0YWRhdGFfcGFnaW5hdGlvbiBhcmM4OV9nZXRfbWV0YWRhdGEgYXJjODlfZ2V0X21ldGFkYXRhX3NsaWNlIGFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJfaGFzaCBhcmM4OV9nZXRfbWV0YWRhdGFfcGFnZV9oYXNoIGFyYzg5X2dldF9tZXRhZGF0YV9oYXNoIGFyYzg5X2dldF9tZXRhZGF0YV9zdHJpbmdfYnlfa2V5IGFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5IGFyYzg5X2dldF9tZXRhZGF0YV9vYmplY3RfYnlfa2V5IGFyYzg5X2dldF9tZXRhZGF0YV9iNjRfYnl0ZXNfYnlfa2V5IG1haW5fZXh0cmFfcmVzb3VyY2VzX3JvdXRlQDMzIHdpdGhkcmF3X2JhbGFuY2VfZXhjZXNzCiAgICBlcnIKCm1haW5fZXh0cmFfcmVzb3VyY2VzX3JvdXRlQDMzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjU5CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCm1haW5fYXJjODlfZ2V0X21ldGFkYXRhX3JlZ2lzdHJ5X3BhcmFtZXRlcnNfcm91dGVAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc3OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NTAwMzM3NzJhMTAwMDAzZWYwN2VlMDdmMjA3ZjAwMDAwMDAwMDAwMDAwOWM0MDAwMDAwMDAwMDAwMDE5MAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2RlcGxveUAzODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzY3CiAgICAvLyBAYXJjNC5iYXJlbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgJiYKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNzItMzczCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IFRlbXBsYXRlVmFyW0FjY291bnRdKAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNzItMzc1CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IFRlbXBsYXRlVmFyW0FjY291bnRdKAogICAgLy8gICAgIFRSVVNURURfREVQTE9ZRVIKICAgIC8vICksIGVyci5VTlRSVVNURURfREVQTE9ZRVIKICAgIGJ5dGVjIDYgLy8gVE1QTF9UUlVTVEVEX0RFUExPWUVSCiAgICA9PQogICAgYXNzZXJ0IC8vIFRoZSBkZXBsb3llciBhZGRyZXNzIGlzIG5vdCB0cnVzdGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2NwogICAgLy8gQGFyYzQuYmFyZW1ldGhvZChjcmVhdGU9InJlcXVpcmUiKQogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIF9wdXlhX2xpYi51dGlsLmVuc3VyZV9idWRnZXQocmVxdWlyZWRfYnVkZ2V0OiB1aW50NjQsIGZlZV9zb3VyY2U6IHVpbnQ2NCkgLT4gdm9pZDoKZW5zdXJlX2J1ZGdldDoKICAgIHByb3RvIDIgMAogICAgZnJhbWVfZGlnIC0yCiAgICBwdXNoaW50IDEwCiAgICArCgplbnN1cmVfYnVkZ2V0X3doaWxlX3RvcEAxOgogICAgZnJhbWVfZGlnIDAKICAgIGdsb2JhbCBPcGNvZGVCdWRnZXQKICAgID4KICAgIGJ6IGVuc3VyZV9idWRnZXRfYWZ0ZXJfd2hpbGVANgogICAgaXR4bl9iZWdpbgogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIHB1c2hpbnQgNSAvLyBEZWxldGVBcHBsaWNhdGlvbgogICAgaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KICAgIGJ5dGVjIDQgLy8gMHgwNjgxMDEKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCiAgICBieXRlYyA0IC8vIDB4MDY4MTAxCiAgICBpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCiAgICBmcmFtZV9kaWcgLTEKICAgIHN3aXRjaCBlbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlXzBAMyBlbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlXzFANAoKZW5zdXJlX2J1ZGdldF9zd2l0Y2hfY2FzZV9uZXh0QDU6CiAgICBpdHhuX3N1Ym1pdAogICAgYiBlbnN1cmVfYnVkZ2V0X3doaWxlX3RvcEAxCgplbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlXzFANDoKICAgIGdsb2JhbCBNaW5UeG5GZWUKICAgIGl0eG5fZmllbGQgRmVlCiAgICBiIGVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfbmV4dEA1CgplbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlXzBAMzoKICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgYiBlbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlX25leHRANQoKZW5zdXJlX2J1ZGdldF9hZnRlcl93aGlsZUA2OgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmF2bV9jb21tb24uZW5kc3dpdGgoczogYnl0ZXMsIHN1ZmZpeDogYnl0ZXMpIC0+IHVpbnQ2NDoKZW5kc3dpdGg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTo1Mi01MwogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBlbmRzd2l0aChzOiBCeXRlcywgc3VmZml4OiBCeXRlcykgLT4gYm9vbDoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6NTQKICAgIC8vIGFzc2VydCBzdWZmaXgubGVuZ3RoIDw9IHMubGVuZ3RoCiAgICBmcmFtZV9kaWcgLTEKICAgIGxlbgogICAgZnJhbWVfZGlnIC0yCiAgICBsZW4KICAgIGR1cDIKICAgIDw9CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjU1CiAgICAvLyByZXR1cm4gc1tzLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGggOl0gPT0gc3VmZml4CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgLQogICAgZHVwCiAgICBkaWcgMgogICAgPj0KICAgIGRpZyAyCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXZtX2NvbW1vbi5hcmM5MF9ib3hfcXVlcnkoYXBwOiB1aW50NjQsIGJveF9uYW1lOiBieXRlcykgLT4gYnl0ZXM6CmFyYzkwX2JveF9xdWVyeToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjU4LTU5CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGFyYzkwX2JveF9xdWVyeShhcHA6IEFwcGxpY2F0aW9uLCBib3hfbmFtZTogQnl0ZXMpIC0+IEJ5dGVzOgogICAgcHJvdG8gMiAxCiAgICBpbnRjXzEgLy8gMAogICAgZHVwCiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTo2MAogICAgLy8gaWYgR2xvYmFsLmdlbmVzaXNfaGFzaCA9PSBCeXRlcy5mcm9tX2Jhc2U2NChNQUlOTkVUX0dIX0I2NCk6CiAgICBnbG9iYWwgR2VuZXNpc0hhc2gKICAgIHB1c2hieXRlcyBiYXNlNjQod0dIRTJQd2R2ZDdTMTJCTDVGYU9QMjBFR1llc043M2t0aUMxcXpra2l0OD0pCiAgICA9PQogICAgYnogYXJjOTBfYm94X3F1ZXJ5X2Vsc2VfYm9keUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTo2MQogICAgLy8gYXJjOTBfbmV0YXV0aCA9IEJ5dGVzKCkKICAgIGJ5dGVjXzEgLy8gMHgKCmFyYzkwX2JveF9xdWVyeV9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTo2NQogICAgLy8gQVJDOTBfVVJJX1NDSEVNRQogICAgcHVzaGJ5dGVzIDB4NjE2YzY3NmY3MjYxNmU2NDNhMmYyZgogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6NjUtNjYKICAgIC8vIEFSQzkwX1VSSV9TQ0hFTUUKICAgIC8vICsgYXJjOTBfbmV0YXV0aAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTo2NwogICAgLy8gKyBBUkM5MF9VUklfQVBQX1BBVEgKICAgIHB1c2hieXRlcyAweDYxNzA3MDJmCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTo2NS02NwogICAgLy8gQVJDOTBfVVJJX1NDSEVNRQogICAgLy8gKyBhcmM5MF9uZXRhdXRoCiAgICAvLyArIEFSQzkwX1VSSV9BUFBfUEFUSAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjM2CiAgICAvLyBhY2MgPSBCeXRlcyhiIiIpCiAgICBieXRlY18xIC8vIDB4CiAgICBmcmFtZV9idXJ5IDAKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfYnVyeSAyCgphcmM5MF9ib3hfcXVlcnlfd2hpbGVfdG9wQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTozOAogICAgLy8gd2hpbGUgaSA+IDA6CiAgICBmcmFtZV9kaWcgMgogICAgYnogYXJjOTBfYm94X3F1ZXJ5X2FmdGVyX3doaWxlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjM5CiAgICAvLyBkID0gaSAlIFVJbnQ2NCgxMCkKICAgIGZyYW1lX2RpZyAyCiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjQwCiAgICAvLyBhY2MgPSBkaWdpdHNbZCA6IGQgKyBVSW50NjQoMSldICsgYWNjCiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgID49CiAgICBkaWcgMQogICAgcHVzaGludCAxMAogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIHN3YXAKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgID49CiAgICBwdXNoaW50IDEwCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIGR1cAogICAgZGlnIDIKICAgIDwKICAgIGRpZyAyCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjM0LTM1CiAgICAvLyAjIEFTQ0lJIGRpZ2l0cyAodmFsaWQgVVRGLTgpCiAgICAvLyBkaWdpdHMgPSBCeXRlcyhiIjAxMjM0NTY3ODkiKQogICAgcHVzaGJ5dGVzIDB4MzAzMTMyMzMzNDM1MzYzNzM4MzkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjQwCiAgICAvLyBhY2MgPSBkaWdpdHNbZCA6IGQgKyBVSW50NjQoMSldICsgYWNjCiAgICBjb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBmcmFtZV9kaWcgMAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjQxCiAgICAvLyBpIC8vPSBVSW50NjQoMTApCiAgICBwdXNoaW50IDEwCiAgICAvCiAgICBmcmFtZV9idXJ5IDIKICAgIGIgYXJjOTBfYm94X3F1ZXJ5X3doaWxlX3RvcEA1CgphcmM5MF9ib3hfcXVlcnlfYWZ0ZXJfd2hpbGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjQzCiAgICAvLyByZXR1cm4gYWNjIG9yIEJ5dGVzKGIiMCIpCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hieXRlcyAweDMwCiAgICBjb3ZlciAyCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjY1LTY4CiAgICAvLyBBUkM5MF9VUklfU0NIRU1FCiAgICAvLyArIGFyYzkwX25ldGF1dGgKICAgIC8vICsgQVJDOTBfVVJJX0FQUF9QQVRICiAgICAvLyArIGl0b2EoYXBwLmlkKQogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6NjkKICAgIC8vICsgQVJDOTBfVVJJX0JPWF9RVUVSWQogICAgcHVzaGJ5dGVzIDB4M2Y2MjZmNzgzZAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6NjUtNjkKICAgIC8vIEFSQzkwX1VSSV9TQ0hFTUUKICAgIC8vICsgYXJjOTBfbmV0YXV0aAogICAgLy8gKyBBUkM5MF9VUklfQVBQX1BBVEgKICAgIC8vICsgaXRvYShhcHAuaWQpCiAgICAvLyArIEFSQzkwX1VSSV9CT1hfUVVFUlkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6NjUtNzAKICAgIC8vIEFSQzkwX1VSSV9TQ0hFTUUKICAgIC8vICsgYXJjOTBfbmV0YXV0aAogICAgLy8gKyBBUkM5MF9VUklfQVBQX1BBVEgKICAgIC8vICsgaXRvYShhcHAuaWQpCiAgICAvLyArIEFSQzkwX1VSSV9CT1hfUVVFUlkKICAgIC8vICsgYm94X25hbWUKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTo2NC03MQogICAgLy8gcmV0dXJuICgKICAgIC8vICAgICBBUkM5MF9VUklfU0NIRU1FCiAgICAvLyAgICAgKyBhcmM5MF9uZXRhdXRoCiAgICAvLyAgICAgKyBBUkM5MF9VUklfQVBQX1BBVEgKICAgIC8vICAgICArIGl0b2EoYXBwLmlkKQogICAgLy8gICAgICsgQVJDOTBfVVJJX0JPWF9RVUVSWQogICAgLy8gICAgICsgYm94X25hbWUKICAgIC8vICkKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgphcmM5MF9ib3hfcXVlcnlfZWxzZV9ib2R5QDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTo2MwogICAgLy8gYXJjOTBfbmV0YXV0aCA9IFRlbXBsYXRlVmFyW0J5dGVzXShBUkM5MF9ORVRBVVRIKQogICAgYnl0ZWMgNyAvLyBUTVBMX0FSQzkwX05FVEFVVEgKICAgIGIgYXJjOTBfYm94X3F1ZXJ5X2FmdGVyX2lmX2Vsc2VAMwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9jcmVhdGVfbWV0YWRhdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9jcmVhdGVfbWV0YWRhdGE6CiAgICBpbnRjXzEgLy8gMAogICAgZHVwbiAzCiAgICBieXRlY18xIC8vICIiCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mzc3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzAgLy8gMQogICAgLQogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQwMy00MDQKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkLCBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpKQogICAgdW5jb3ZlciAyCiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGRpZyAzCiAgICBzd2FwCiAgICBjYWxsc3ViIF9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDYKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQwNQogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNzZXRfaWQpLCBlcnIuQVNTRVRfTUVUQURBVEFfRVhJU1QKICAgICEKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDA3CiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBzd2FwCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQwNi00MDgKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyX2RlbHRhX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgLy8gKSwgZXJyLk1CUl9ERUxUQV9SRUNFSVZFUl9JTlZBTElECiAgICBhc3NlcnQgLy8gSW52YWxpZCBNQlIgRGVsdGEgcmVjZWl2ZXIsIG11c3QgYmUgdGhlIEFTQSBNZXRhZGF0YSBSZWdpc3RyeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MTAtNDExCiAgICAvLyAjIEluaXRpYWxpemUgZW1wdHkgQXNzZXQgTWV0YWRhdGEgQm94CiAgICAvLyBtYnJfaSA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIHN3YXAKICAgIGNvdmVyIDMKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MTIKICAgIC8vIF9leGlzdHMgPSBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc3NldF9pZCkuY3JlYXRlKHNpemU9VUludDY0KDApKQogICAgaW50Y18xIC8vIDAKICAgIGJveF9jcmVhdGUKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MTQtNDE1CiAgICAvLyAjIFNldCBNZXRhZGF0YSBCb2R5CiAgICAvLyBpZiBwYXlsb2FkLm5hdGl2ZS5sZW5ndGggPiAwOgogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgbGVuCiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQxNgogICAgLy8gZW5zdXJlX2J1ZGdldChyZXF1aXJlZF9idWRnZXQ9Y29uc3QuQVBQX0NBTExfT1BfQlVER0VUKQogICAgcHVzaGludCA3MDAKICAgIGludGNfMSAvLyAwCiAgICBjYWxsc3ViIGVuc3VyZV9idWRnZXQKCmFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQxNwogICAgLy8gc2VsZi5fc2V0X21ldGFkYXRhX3BheWxvYWQoYXNzZXRfaWQsIG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCksIHBheWxvYWQubmF0aXZlKQogICAgZGlnIDcKICAgIGR1cAogICAgZGlnIDUKICAgIGRpZyAzCiAgICBjYWxsc3ViIF9zZXRfbWV0YWRhdGFfcGF5bG9hZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MTktNDIwCiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBIZWFkZXIKICAgIC8vIHNlbGYuX2lkZW50aWZ5X21ldGFkYXRhKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9pZGVudGlmeV9tZXRhZGF0YQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MjQKICAgIC8vIHVpbnQ9cmV2ZXJzaWJsZV9mbGFncy5hc191aW50NjQoKSwgc2l6ZT1VSW50NjQoY29uc3QuQllURV9TSVpFKQogICAgZGlnIDcKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjE5CiAgICAvLyByZXR1cm4gb3AuZXh0cmFjdChvcC5pdG9iKHVpbnQpLCBzdGFydCwgc2l6ZSkKICAgIGl0b2IKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkxLTkzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICAvLyApCiAgICBkaWcgNAogICAgZHVwCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkxLTkzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQzMAogICAgLy8gdWludD1pcnJldmVyc2libGVfZmxhZ3MuYXNfdWludDY0KCksIHNpemU9VUludDY0KGNvbnN0LkJZVEVfU0laRSkKICAgIGRpZyA3CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToxOQogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBpdG9iCiAgICBleHRyYWN0IDcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDItMTA0CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQzMwogICAgLy8gaWYgYXNzZXRfaWQubWV0YWRhdGFfaGFzaCAhPSBCeXRlcygKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNZXRhZGF0YUhhc2gKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDMzLTQzNQogICAgLy8gaWYgYXNzZXRfaWQubWV0YWRhdGFfaGFzaCAhPSBCeXRlcygKICAgIC8vICAgICBjb25zdC5CWVRFUzMyX1NJWkUgKiBiIlx4MDAiCiAgICAvLyApOiAgIyBOb3QgZW1wdHkgbWV0YWRhdGEgaGFzaAogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgIT0KICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9lbHNlX2JvZHlANQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ni05OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2LTk5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA5CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNy0xMTAKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQzNgogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2ltbXV0YWJsZShhc3NldF9pZCksIGVyci5SRVFVSVJFU19JTU1VVEFCTEUKICAgIGFzc2VydCAvLyBNdXN0IGJlIGZsYWdnZWQgYXMgaW1tdXRhYmxlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQzNwogICAgLy8gbWV0YWRhdGFfaGFzaCA9IGFzc2V0X2lkLm1ldGFkYXRhX2hhc2gKICAgIGRpZyA3CiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWV0YWRhdGFIYXNoCiAgICBzd2FwCiAgICBidXJ5IDEyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjYtMTI4CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIC8vICkKICAgIGRpZyAyCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgdmFsdWU9bWV0YWRhdGFfaGFzaAogICAgcHVzaGludCAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNi0xMjgKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgdmFsdWU9bWV0YWRhdGFfaGFzaAogICAgLy8gKQogICAgZGlnIDEzCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDEKICAgIC8vIHNlbGYuX3NldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkLCBHbG9iYWwucm91bmQpCiAgICBnbG9iYWwgUm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQxCiAgICAvLyB2YWx1ZT1vcC5pdG9iKGxhc3RfbW9kaWZpZWRfcm91bmQpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzktMTQyCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0MAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzOS0xNDIKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICB2YWx1ZT1vcC5pdG9iKGxhc3RfbW9kaWZpZWRfcm91bmQpLAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDIKICAgIC8vIHNlbGYuX3NldF9kZXByZWNhdGVkX2J5KGFzc2V0X2lkLCBVSW50NjQoMCkpCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTUKICAgIC8vIHZhbHVlPW9wLml0b2IoZGVwcmVjYXRlZF9ieSksCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1My0xNTYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICB2YWx1ZT1vcC5pdG9iKGRlcHJlY2F0ZWRfYnkpLAogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTU0CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIHB1c2hpbnQgNDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTUzLTE1NgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9ERVBSRUNBVEVEX0JZLAogICAgLy8gICAgIHZhbHVlPW9wLml0b2IoZGVwcmVjYXRlZF9ieSksCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2LTk5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA5CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIHB1c2hpbnQgNwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDctMTEwCiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9pcnJldmVyc2libGVfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDQtNDQ1CiAgICAvLyAjIFBvc3Rjb25kaXRpb25zCiAgICAvLyBpZiBzZWxmLl9pc19hcmMzKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weToyMgogICAgLy8gYXNhX25hbWUgPSBhc2EubmFtZQogICAgZGlnIDcKICAgIGR1cAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE5hbWUKICAgIHN3YXAKICAgIGR1cAogICAgY292ZXIgMwogICAgYnVyeSAxNgogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjIzCiAgICAvLyBhc2FfdXJsID0gYXNhLnVybAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldFVSTAogICAgc3dhcAogICAgYnVyeSAxNAogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjI3CiAgICAvLyBpZiBhc2FfbmFtZSA9PSBBUkMzX05BTUU6CiAgICBwdXNoYnl0ZXMgMHg2MTcyNjMzMwogICAgPT0KICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDE5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MjgKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnRjXzAgLy8gMQoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLmFzYV92YWxpZGF0aW9uLkFzYVZhbGlkYXRpb24uX2lzX2FyYzNfY29tcGxpYW50QDI2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDYKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hcmMzX2NvbXBsaWFudChhc3NldF9pZCksIGVyci5BU0FfTk9UX0FSQzNfQ09NUExJQU5UCiAgICBhc3NlcnQgLy8gSW52YWxpZCBBUkMtMyBwYXJhbWV0ZXJzIChuYW1lIG9yIFVSTCkKCmFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2LTk5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYtOTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDkKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgcHVzaGludCA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNy0xMTAKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0NwogICAgLy8gaWYgc2VsZi5faXNfYXJjODlfbmF0aXZlKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6NDEtNDIKICAgIC8vICMgVGhpcyB2YWxpZGF0aW9uIGRvZXMgbm90IGVuZm9yY2UgQVJDLTkwIGNvbXBsaWFuY2UgZnJhZ21lbnRzIChvcHRpb25hbCkKICAgIC8vIGFyYzg5X3BhcnRpYWxfdXJpID0gYXJjOTBfYm94X3F1ZXJ5KEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLCBCeXRlcygpKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBieXRlY18xIC8vIDB4CiAgICBjYWxsc3ViIGFyYzkwX2JveF9xdWVyeQogICAgZHVwCiAgICBidXJ5IDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6NDMKICAgIC8vIGFzYV91cmwgPSBhc2EudXJsCiAgICBkaWcgOAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldFVSTAogICAgc3dhcAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDE1CiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6NDUKICAgIC8vIGlmIGFzYV91cmwubGVuZ3RoIDwgYXJjODlfcGFydGlhbF91cmkubGVuZ3RoOgogICAgbGVuCiAgICBkdXAKICAgIGJ1cnkgMTIKICAgIHN3YXAKICAgIGxlbgogICAgZHVwCiAgICBidXJ5IDExCiAgICA8CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjQ2CiAgICAvLyByZXR1cm4gRmFsc2UKICAgIGludGNfMSAvLyAwCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMuYXNhX3ZhbGlkYXRpb24uQXNhVmFsaWRhdGlvbi5faXNfYXJjODlfY29tcGxpYW50QDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDgKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hcmM4OV9jb21wbGlhbnQoYXNzZXRfaWQpLCBlcnIuQVNBX05PVF9BUkM4OV9DT01QTElBTlQKICAgIGFzc2VydCAvLyBJbnZhbGlkIEFSQy04OSBwYXJ0aWFsIFVSSQoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1MAogICAgLy8gc2VsZi5fZW1pdF91cGRhdGVkX2V2ZW50KGFzc2V0X2lkLCBtZXRhZGF0YV9oYXNoKQogICAgZGlnIDcKICAgIGRpZyAxMQogICAgY2FsbHN1YiBfZW1pdF91cGRhdGVkX2V2ZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1MgogICAgLy8gbWJyX2RlbHRhX2Ftb3VudCA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UgLSBtYnJfaQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBkaWcgMgogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NTQKICAgIC8vIG1icl9kZWx0YV9wYXltZW50LmFtb3VudCA+PSBtYnJfZGVsdGFfYW1vdW50CiAgICBkaWcgNQogICAgZ3R4bnMgQW1vdW50CiAgICBkaWcgMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDUzLTQ1NQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgLy8gKSwgZXJyLk1CUl9ERUxUQV9BTU9VTlRfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NTgKICAgIC8vIHNpZ249YXJjNC5VSW50OChlbnVtcy5NQlJfREVMVEFfUE9TKSwgYW1vdW50PWFyYzQuVUludDY0KG1icl9kZWx0YV9hbW91bnQpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUwMQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6NDgKICAgIC8vIGFzc2VydCBwcmVmaXgubGVuZ3RoIDw9IHMubGVuZ3RoCiAgICBkaWcgOAogICAgZHVwCiAgICBkaWcgMTEKICAgIGR1cAogICAgY292ZXIgMwogICAgPD0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6NDkKICAgIC8vIHJldHVybiBzWzogcHJlZml4Lmxlbmd0aF0gPT0gcHJlZml4CiAgICBkdXAKICAgIGRpZyAyCiAgICA+PQogICAgc3dhcAogICAgY292ZXIgMgogICAgc2VsZWN0CiAgICBkaWcgMTIKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGRpZyAxNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDQ4CiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXJjODlfY29tcGxpYW50KGFzc2V0X2lkKSwgZXJyLkFTQV9OT1RfQVJDODlfQ09NUExJQU5UCiAgICBiIGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5hc2FfdmFsaWRhdGlvbi5Bc2FWYWxpZGF0aW9uLl9pc19hcmM4OV9jb21wbGlhbnRAMTQKCmFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjMwCiAgICAvLyBpZiBhc2FfbmFtZS5sZW5ndGggPj0gYXJjM19uYW1lX3N1ZmZpeC5sZW5ndGg6CiAgICBkaWcgMTIKICAgIGxlbgogICAgcHVzaGludCA1CiAgICA+PQogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMjIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTozMQogICAgLy8gaWYgZW5kc3dpdGgoYXNhX25hbWUsIGFyYzNfbmFtZV9zdWZmaXgpOgogICAgZGlnIDEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MjQKICAgIC8vIGFyYzNfbmFtZV9zdWZmaXggPSBCeXRlcyhBUkMzX05BTUVfU1VGRklYKQogICAgcHVzaGJ5dGVzIDB4NDA2MTcyNjMzMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjMxCiAgICAvLyBpZiBlbmRzd2l0aChhc2FfbmFtZSwgYXJjM19uYW1lX3N1ZmZpeCk6CiAgICBjYWxsc3ViIGVuZHN3aXRoCiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAyMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjMyCiAgICAvLyByZXR1cm4gVHJ1ZQogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDQ2CiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXJjM19jb21wbGlhbnQoYXNzZXRfaWQpLCBlcnIuQVNBX05PVF9BUkMzX0NPTVBMSUFOVAogICAgYiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMuYXNhX3ZhbGlkYXRpb24uQXNhVmFsaWRhdGlvbi5faXNfYXJjM19jb21wbGlhbnRAMjYKCmFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDIyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjM0CiAgICAvLyBpZiBhc2FfdXJsLmxlbmd0aCA+PSBhcmMzX3VybF9zdWZmaXgubGVuZ3RoOgogICAgZGlnIDExCiAgICBsZW4KICAgIHB1c2hpbnQgNQogICAgPj0KICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDI1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MzUKICAgIC8vIGlmIGVuZHN3aXRoKGFzYV91cmwsIGFyYzNfdXJsX3N1ZmZpeCk6CiAgICBkaWcgMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weToyNQogICAgLy8gYXJjM191cmxfc3VmZml4ID0gQnl0ZXMoQVJDM19VUkxfU1VGRklYKQogICAgcHVzaGJ5dGVzIDB4MjM2MTcyNjMzMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjM1CiAgICAvLyBpZiBlbmRzd2l0aChhc2FfdXJsLCBhcmMzX3VybF9zdWZmaXgpOgogICAgY2FsbHN1YiBlbmRzd2l0aAogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTozNgogICAgLy8gcmV0dXJuIFRydWUKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0NgogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FyYzNfY29tcGxpYW50KGFzc2V0X2lkKSwgZXJyLkFTQV9OT1RfQVJDM19DT01QTElBTlQKICAgIGIgYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLmFzYV92YWxpZGF0aW9uLkFzYVZhbGlkYXRpb24uX2lzX2FyYzNfY29tcGxpYW50QDI2CgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAyNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTozOAogICAgLy8gcmV0dXJuIEZhbHNlCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDYKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hcmMzX2NvbXBsaWFudChhc3NldF9pZCksIGVyci5BU0FfTk9UX0FSQzNfQ09NUExJQU5UCiAgICBiIGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5hc2FfdmFsaWRhdGlvbi5Bc2FWYWxpZGF0aW9uLl9pc19hcmMzX2NvbXBsaWFudEAyNgoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2Vsc2VfYm9keUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MzkKICAgIC8vIG1ldGFkYXRhX2hhc2ggPSBzZWxmLl9jb21wdXRlX21ldGFkYXRhX2hhc2goYXNzZXRfaWQpCiAgICBkaWcgNwogICAgY2FsbHN1YiBfY29tcHV0ZV9tZXRhZGF0YV9oYXNoCiAgICBidXJ5IDExCiAgICBiIGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDYKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfcmVwbGFjZV9tZXRhZGF0YVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3JlcGxhY2VfbWV0YWRhdGE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ2MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDgyLTQ4MwogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucyhhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSkKICAgIHN3YXAKICAgIGJ0b2kKICAgIGRpZyAyCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDg0LTQ4NgogICAgLy8gYXNzZXJ0IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkgPD0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoCiAgICAvLyAgICAgYXNzZXRfaWQKICAgIC8vICksIGVyci5MQVJHRVJfTUVUQURBVEFfU0laRQogICAgZGlnIDIKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBkaWcgMQogICAgPj0KICAgIGFzc2VydCAvLyBJbnZhbGlkIE1ldGFkYXRhIHNpemUsIG11c3QgYmUgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBjdXJyZW50IHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDg4LTQ4OQogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgQm9keQogICAgLy8gbWJyX2kgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkwCiAgICAvLyBzZWxmLl9zZXRfbWV0YWRhdGFfcGF5bG9hZChhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSwgcGF5bG9hZC5uYXRpdmUpCiAgICB1bmNvdmVyIDIKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgMwogICAgZGlnIDMKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfc2V0X21ldGFkYXRhX3BheWxvYWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkyLTQ5MwogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAyCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OTcKICAgIC8vIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSA9PSBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICB1bmNvdmVyIDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ5NS00OTgKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpID09IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIC8vICksIGVyci5NRVRBREFUQV9TSVpFX01JU01BVENICiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgc2l6ZSBtaXNtYXRjaCwgbXVzdCBiZSBleGFjdGx5IGVxdWFsIHRvIGRlY2xhcmVkIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTAwCiAgICAvLyBtYnJfZGVsdGFfYW1vdW50ID0gbWJyX2kgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC0KICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MDEKICAgIC8vIGlmIG1icl9kZWx0YV9hbW91bnQgPT0gMDoKICAgIGJueiBhcmM4OV9yZXBsYWNlX21ldGFkYXRhX2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUwMgogICAgLy8gc2lnbiA9IFVJbnQ2NChlbnVtcy5NQlJfREVMVEFfTlVMTCkKICAgIGludGNfMSAvLyAwCgphcmM4OV9yZXBsYWNlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTEwCiAgICAvLyByZXR1cm4gYWJpLk1ickRlbHRhKHNpZ249YXJjNC5VSW50OChzaWduKSwgYW1vdW50PWFyYzQuVUludDY0KG1icl9kZWx0YV9hbW91bnQpKQogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMiAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgZGlnIDEKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NjEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTA0CiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9ORUcpCiAgICBwdXNoaW50IDI1NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MDUtNTA4CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciwKICAgIC8vICAgICBhbW91bnQ9bWJyX2RlbHRhX2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTA2CiAgICAvLyByZWNlaXZlcj1hc3NldF9pZC5tYW5hZ2VyLAogICAgZGlnIDIKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTA1CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzAgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTA1LTUwOAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWFzc2V0X2lkLm1hbmFnZXIsCiAgICAvLyAgICAgYW1vdW50PW1icl9kZWx0YV9hbW91bnQsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgYiBhcmM4OV9yZXBsYWNlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9yZXBsYWNlX21ldGFkYXRhX2xhcmdlcltyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfbGFyZ2VyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMCAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUzNS01MzYKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQsIG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkpCiAgICB1bmNvdmVyIDIKICAgIGJ0b2kKICAgIGRpZyAzCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTM3LTUzOQogICAgLy8gYXNzZXJ0IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkgPiBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLlNNQUxMRVJfTUVUQURBVEFfU0laRQogICAgZGlnIDMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBkaWcgMQogICAgPAogICAgYXNzZXJ0IC8vIEludmFsaWQgTWV0YWRhdGEgc2l6ZSwgbXVzdCBiZSBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU0MQogICAgLy8gbWJyX2RlbHRhX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZGlnIDEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTQwLTU0MgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfZGVsdGFfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLCBlcnIuTUJSX0RFTFRBX1JFQ0VJVkVSX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1CUiBEZWx0YSByZWNlaXZlciwgbXVzdCBiZSB0aGUgQVNBIE1ldGFkYXRhIFJlZ2lzdHJ5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU0NC01NDUKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEJvZHkKICAgIC8vIG1icl9pID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU0NgogICAgLy8gc2VsZi5fc2V0X21ldGFkYXRhX3BheWxvYWQoYXNzZXRfaWQsIG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCksIHBheWxvYWQubmF0aXZlKQogICAgdW5jb3ZlciAzCiAgICBleHRyYWN0IDIgMAogICAgZGlnIDQKICAgIGRpZyAzCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgX3NldF9tZXRhZGF0YV9wYXlsb2FkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU0OC01NDkKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEhlYWRlcgogICAgLy8gc2VsZi5fdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQoYXNzZXRfaWQpCiAgICBkaWcgMwogICAgY2FsbHN1YiBfdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTUzCiAgICAvLyBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc3NldF9pZCkgPT0gbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKQogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgdW5jb3ZlciAyCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NTEtNTU0CiAgICAvLyAjIFBvc3Rjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSA9PSBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpCiAgICAvLyApLCBlcnIuTUVUQURBVEFfU0laRV9NSVNNQVRDSAogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIHNpemUgbWlzbWF0Y2gsIG11c3QgYmUgZXhhY3RseSBlcXVhbCB0byBkZWNsYXJlZCBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1NgogICAgLy8gbWJyX2RlbHRhX2Ftb3VudCA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UgLSBtYnJfaQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBzd2FwCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1OAogICAgLy8gbWJyX2RlbHRhX3BheW1lbnQuYW1vdW50ID49IG1icl9kZWx0YV9hbW91bnQKICAgIHN3YXAKICAgIGd0eG5zIEFtb3VudAogICAgZGlnIDEKICAgID49CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1Ny01NTkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyX2RlbHRhX3BheW1lbnQuYW1vdW50ID49IG1icl9kZWx0YV9hbW91bnQKICAgIC8vICksIGVyci5NQlJfREVMVEFfQU1PVU5UX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1CUiBEZWx0YSBhbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYyCiAgICAvLyBzaWduPWFyYzQuVUludDgoZW51bXMuTUJSX0RFTFRBX1BPUyksIGFtb3VudD1hcmM0LlVJbnQ2NChtYnJfZGVsdGFfYW1vdW50KQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgYnl0ZWMgNSAvLyAweDE1MWY3Yzc1MDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfc2xpY2Vbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9yZXBsYWNlX21ldGFkYXRhX3NsaWNlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NjUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU4Mi01ODMKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQsIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSkKICAgIGRpZyAyCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgZGlnIDMKICAgIHN3YXAKICAgIGNhbGxzdWIgX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU4NAogICAgLy8gYXNzZXJ0IG9mZnNldC5hc191aW50NjQoKSArIHBheWxvYWQubmF0aXZlLmxlbmd0aCA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIHN3YXAKICAgIGJ0b2kKICAgIHN3YXAKICAgIGV4dHJhY3QgMiAwCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgbGVuCiAgICBkaWcgMgogICAgZGlnIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTg0LTU4NgogICAgLy8gYXNzZXJ0IG9mZnNldC5hc191aW50NjQoKSArIHBheWxvYWQubmF0aXZlLmxlbmd0aCA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLkVYQ0VFRFNfTUVUQURBVEFfU0laRQogICAgZGlnIDQKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICA8PQogICAgYXNzZXJ0IC8vIFNsaWNlIGV4Y2VlZHMgbWV0YWRhdGEgcmFuZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjU3CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgdW5jb3ZlciAzCiAgICBpdG9iCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjU4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBvZmZzZXQsIGxlbmd0aD1zaXplCiAgICBwdXNoaW50IDUxCiAgICB1bmNvdmVyIDQKICAgICsKICAgIGR1cAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNTctMjU5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldCwgbGVuZ3RoPXNpemUKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTkyCiAgICAvLyBpZiBwYXlsb2FkLm5hdGl2ZSAhPSBleGlzdGluZ19zbGljZToKICAgICE9CiAgICBieiBhcmM4OV9yZXBsYWNlX21ldGFkYXRhX3NsaWNlX2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1OTMtNTk3CiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBCb2R5CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc3NldF9pZCkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBvZmZzZXQuYXNfdWludDY0KCksCiAgICAvLyAgICAgdmFsdWU9cGF5bG9hZC5uYXRpdmUsCiAgICAvLyApCiAgICBkdXAyCiAgICBkaWcgNAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTk5LTYwMAogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZV9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X21pZ3JhdGVfbWV0YWRhdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9taWdyYXRlX21ldGFkYXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MDIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgZHVwCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYxNy02MTgKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyMAogICAgLy8gbmV3X3JlZ2lzdHJ5X2lkLmFzX3VpbnQ2NCgpICE9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkCiAgICBidG9pCiAgICBkdXAKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgIT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjE5LTYyMQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBuZXdfcmVnaXN0cnlfaWQuYXNfdWludDY0KCkgIT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQuaWQKICAgIC8vICksIGVyci5ORVdfUkVHSVNUUllfSURfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgbmV3IEFTQSBNZXRhZGF0YSBSZWdpc3RyeSBJRCwgbXVzdCBiZSBkaWZmZXJlbnQgZnJvbSBjdXJyZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1MwogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgc3dhcAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTUKICAgIC8vIHZhbHVlPW9wLml0b2IoZGVwcmVjYXRlZF9ieSksCiAgICBzd2FwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1My0xNTYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICB2YWx1ZT1vcC5pdG9iKGRlcHJlY2F0ZWRfYnkpLAogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTU0CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIHB1c2hpbnQgNDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTUzLTE1NgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9ERVBSRUNBVEVEX0JZLAogICAgLy8gICAgIHZhbHVlPW9wLml0b2IoZGVwcmVjYXRlZF9ieSksCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyOQogICAgLy8gcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIGdsb2JhbCBSb3VuZAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MzAKICAgIC8vIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0Ni0xNDkKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuREVQUkVDQVRFRF9CWV9TSVpFLAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0NwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICBwdXNoaW50IDQzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0OAogICAgLy8gbGVuZ3RoPWNvbnN0LkRFUFJFQ0FURURfQllfU0laRSwKICAgIGludGNfMiAvLyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0Ni0xNDkKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuREVQUkVDQVRFRF9CWV9TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQ1LTE1MAogICAgLy8gcmV0dXJuIG9wLmJ0b2koCiAgICAvLyAgICAgc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICAgICAgbGVuZ3RoPWNvbnN0LkRFUFJFQ0FURURfQllfU0laRSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYzMQogICAgLy8gbmV3X3JlZ2lzdHJ5X2lkPWFyYzQuVUludDY0KHNlbGYuX2dldF9kZXByZWNhdGVkX2J5KGFzc2V0X2lkKSksCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyNy02MzIKICAgIC8vIGFiaS5BcmM4OU1ldGFkYXRhTWlncmF0ZWQoCiAgICAvLyAgICAgYXNzZXRfaWQ9YXJjNC5VSW50NjQoYXNzZXRfaWQuaWQpLAogICAgLy8gICAgIHJvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICAvLyAgICAgdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIC8vICAgICBuZXdfcmVnaXN0cnlfaWQ9YXJjNC5VSW50NjQoc2VsZi5fZ2V0X2RlcHJlY2F0ZWRfYnkoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIHVuY292ZXIgMwogICAgc3dhcAogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyNi02MzMKICAgIC8vIGFyYzQuZW1pdCgKICAgIC8vICAgICBhYmkuQXJjODlNZXRhZGF0YU1pZ3JhdGVkKAogICAgLy8gICAgICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZC5pZCksCiAgICAvLyAgICAgICAgIHJvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICAvLyAgICAgICAgIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICAvLyAgICAgICAgIG5ld19yZWdpc3RyeV9pZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfZGVwcmVjYXRlZF9ieShhc3NldF9pZCkpLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIHB1c2hieXRlcyAweGM4NzAyM2JmIC8vIG1ldGhvZCAiQXJjODlNZXRhZGF0YU1pZ3JhdGVkKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MDIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9kZWxldGVfbWV0YWRhdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9kZWxldGVfbWV0YWRhdGE6CiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYzNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXBuIDIKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDYKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgaXRvYgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjUwLTY1MQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzc2V0X2lkKSwgZXJyLkFTU0VUX01FVEFEQVRBX05PVF9FWElTVAogICAgYXNzZXJ0IC8vIEFzc2V0IE1ldGFkYXRhIGRvZXMgbm90IGV4aXN0IGZvciB0aGUgc3BlY2lmaWVkIEFTQQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjE1CiAgICAvLyBfY3JlYXRvciwgZXhpc3RzID0gb3AuQXNzZXRQYXJhbXNHZXQuYXNzZXRfY3JlYXRvcihhc2EpCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0Q3JlYXRvcgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY1MgogICAgLy8gaWYgc2VsZi5fYXNhX2V4aXN0cyhhc3NldF9pZCk6CiAgICBieiBhcmM4OV9kZWxldGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2LTk5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2LTk5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA5CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNy0xMTAKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY1MwogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLl9pc19pbW11dGFibGUoYXNzZXRfaWQpLCBlcnIuSU1NVVRBQkxFCiAgICAhCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgaW1tdXRhYmxlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY1NAogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FzYV9tYW5hZ2VyKGFzc2V0X2lkKSwgZXJyLlVOQVVUSE9SSVpFRAogICAgZGlnIDEKICAgIGNhbGxzdWIgX2lzX2FzYV9tYW5hZ2VyCiAgICBhc3NlcnQgLy8gVW5hdXRob3JpemVkLCBtdXN0IGJlIHRoZSBBc3NldCBNYW5hZ2VyCgphcmM4OV9kZWxldGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NTYtNjU3CiAgICAvLyAjIERlbGV0ZSBNZXRhZGF0YSBhbmQgcmVmdW5kIE1CUgogICAgLy8gbWJyX2kgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjU4CiAgICAvLyBkZWwgc2VsZi5hc3NldF9tZXRhZGF0YVthc3NldF9pZF0KICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjU5CiAgICAvLyBtYnJfZGVsdGFfYW1vdW50ID0gbWJyX2kgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC0KICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjAtNjYzCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciBpZiBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSBlbHNlIFR4bi5zZW5kZXIsCiAgICAvLyAgICAgYW1vdW50PW1icl9kZWx0YV9hbW91bnQsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MTUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGRpZyAxCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0Q3JlYXRvcgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY2MQogICAgLy8gcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciBpZiBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSBlbHNlIFR4bi5zZW5kZXIsCiAgICBieiBhcmM4OV9kZWxldGVfbWV0YWRhdGFfdGVybmFyeV9mYWxzZUA1CiAgICBkaWcgMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKCmFyYzg5X2RlbGV0ZV9tZXRhZGF0YV90ZXJuYXJ5X21lcmdlQDY6CiAgICBkaWcgNAogICAgZHVwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgc3dhcAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjAKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMCAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjAtNjYzCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciBpZiBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSBlbHNlIFR4bi5zZW5kZXIsCiAgICAvLyAgICAgYW1vdW50PW1icl9kZWx0YV9hbW91bnQsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjgKICAgIC8vIHJvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICBnbG9iYWwgUm91bmQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjY5CiAgICAvLyB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjYtNjcwCiAgICAvLyBhYmkuQXJjODlNZXRhZGF0YURlbGV0ZWQoCiAgICAvLyAgICAgYXNzZXRfaWQ9YXJjNC5VSW50NjQoYXNzZXRfaWQuaWQpLAogICAgLy8gICAgIHJvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICAvLyAgICAgdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIC8vICkKICAgIGRpZyA1CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY2NS02NzEKICAgIC8vIGFyYzQuZW1pdCgKICAgIC8vICAgICBhYmkuQXJjODlNZXRhZGF0YURlbGV0ZWQoCiAgICAvLyAgICAgICAgIGFzc2V0X2lkPWFyYzQuVUludDY0KGFzc2V0X2lkLmlkKSwKICAgIC8vICAgICAgICAgcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIC8vICAgICAgICAgdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBwdXNoYnl0ZXMgMHhiYzNmMjBkMSAvLyBtZXRob2QgIkFyYzg5TWV0YWRhdGFEZWxldGVkKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY3NAogICAgLy8gc2lnbj1hcmM0LlVJbnQ4KGVudW1zLk1CUl9ERUxUQV9ORUcpLCBhbW91bnQ9YXJjNC5VSW50NjQobWJyX2RlbHRhX2Ftb3VudCkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjM1CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHB1c2hieXRlcyAweDE1MWY3Yzc1ZmYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9kZWxldGVfbWV0YWRhdGFfdGVybmFyeV9mYWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjEKICAgIC8vIHJlY2VpdmVyPWFzc2V0X2lkLm1hbmFnZXIgaWYgc2VsZi5fYXNhX2V4aXN0cyhhc3NldF9pZCkgZWxzZSBUeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgYiBhcmM4OV9kZWxldGVfbWV0YWRhdGFfdGVybmFyeV9tZXJnZUA2CgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2V4dHJhX3BheWxvYWRbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9leHRyYV9wYXlsb2FkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NzcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY5MS02OTIKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IEdsb2JhbC5ncm91cF9zaXplID49IDIsIGVyci5OT19QQVlMT0FEX0hFQURfQ0FMTAogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50Y18zIC8vIDIKICAgID49CiAgICBhc3NlcnQgLy8gTm8gcGF5bG9hZCBoZWFkIGNhbGwgaW4gR3JvdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weToxNQogICAgLy8gX2NyZWF0b3IsIGV4aXN0cyA9IG9wLkFzc2V0UGFyYW1zR2V0LmFzc2V0X2NyZWF0b3IoYXNhKQogICAgZHVwCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0Q3JlYXRvcgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY5MwogICAgLy8gYXNzZXJ0IHNlbGYuX2FzYV9leGlzdHMoYXNzZXRfaWQpLCBlcnIuQVNBX05PVF9FWElTVAogICAgYXNzZXJ0IC8vIFRoZSBzcGVjaWZpZWQgQVNBIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ2CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIGR1cAogICAgaXRvYgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY5NAogICAgLy8gYXNzZXJ0IHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc3NldF9pZCksIGVyci5BU1NFVF9NRVRBREFUQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Njk1CiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXNhX21hbmFnZXIoYXNzZXRfaWQpLCBlcnIuVU5BVVRIT1JJWkVECiAgICBjYWxsc3ViIF9pc19hc2FfbWFuYWdlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZCwgbXVzdCBiZSB0aGUgQXNzZXQgTWFuYWdlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NzcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9zZXRfcmV2ZXJzaWJsZV9mbGFnW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfc2V0X3JldmVyc2libGVfZmxhZzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Njk3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuYm9vbAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MTMtNzE0CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMgogICAgY2FsbHN1YiBfY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MTUKICAgIC8vIGFzc2VydCBmbGFnLmFzX3VpbnQ2NCgpIDw9IGZsZy5SRVZfRkxHX1JFU0VSVkVEXzcsIGVyci5GTEFHX0lEWF9JTlZBTElECiAgICBzd2FwCiAgICBidG9pCiAgICBkdXAKICAgIHB1c2hpbnQgNwogICAgPD0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGZsYWcgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzIKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzItNzQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX1JFVl9GTEFHIC0gZmxhZywKICAgIHB1c2hpbnQgNwogICAgdW5jb3ZlciAyCiAgICAtCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzctODAKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X3JldmVyc2libGVfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX1JFVl9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MTkKICAgIC8vIGlmIHZhbHVlLm5hdGl2ZSAhPSBleGlzdGluZ192YWx1ZToKICAgIHN3YXAKICAgIGludGNfMSAvLyAwCiAgICBnZXRiaXQKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICAhPQogICAgYnogYXJjODlfc2V0X3JldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzItNzQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGRpZyAyCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyLTc0CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NS04NwogICAgLy8gdXBkYXRlZF9mbGFncyA9IG9wLnNldGJpdF9ieXRlcygKICAgIC8vICAgICBzZWxmLl9nZXRfcmV2ZXJzaWJsZV9mbGFncyhhc2EpLCBjb25zdC5CSVRfUklHSFRNT1NUX1JFVl9GTEFHIC0gZmxhZywgdmFsdWUKICAgIC8vICkKICAgIGRpZyAzCiAgICBkaWcgMwogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkxLTkzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MjUtNzI2CiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBIZWFkZXIKICAgIC8vIHNlbGYuX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KGFzc2V0X2lkKQogICAgZGlnIDMKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CgphcmM4OV9zZXRfcmV2ZXJzaWJsZV9mbGFnX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Njk3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQyLTc0MwogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgc3dhcAogICAgY2FsbHN1YiBfY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NDUKICAgIC8vIGZsZy5JUlJfRkxHX1JFU0VSVkVEXzIgPD0gZmxhZy5hc191aW50NjQoKSA8PSBmbGcuSVJSX0ZMR19SRVNFUlZFRF82CiAgICBidG9pCiAgICBkdXAKICAgIGludGNfMyAvLyAyCiAgICA+PQogICAgYnogYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfZmFsc2VANAogICAgZHVwCiAgICBwdXNoaW50IDYKICAgIDw9CiAgICBieiBhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzAgLy8gMQoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQ0LTc0NgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBmbGcuSVJSX0ZMR19SRVNFUlZFRF8yIDw9IGZsYWcuYXNfdWludDY0KCkgPD0gZmxnLklSUl9GTEdfUkVTRVJWRURfNgogICAgLy8gKSwgZXJyLkZMQUdfSURYX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIGZsYWcgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBkaWcgMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk4CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ni05OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOQogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICBwdXNoaW50IDcKICAgIGRpZyAyCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNy0xMTAKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1MAogICAgLy8gaWYgbm90IGV4aXN0aW5nX3ZhbHVlOgogICAgYm56IGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUxLTc1MgogICAgLy8gIyBTZXQgSXJyZXZlcnNpYmxlIEZsYWcKICAgIC8vIHNlbGYuX3NldF9pcnJldmVyc2libGVfZmxhZ192YWx1ZShhc3NldF9pZCwgZmxhZy5hc191aW50NjQoKSkKICAgIGRpZyAxCiAgICBkdXAKICAgIGRpZyAyCiAgICBjYWxsc3ViIF9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfdmFsdWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzU0LTc1NQogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CgphcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMSAvLyAwCiAgICBiIGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfc2V0X2ltbXV0YWJsZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3NldF9pbW11dGFibGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc2OS03NzAKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NzItNzczCiAgICAvLyAjIFNldCBJbW11dGFibGUgRmxhZwogICAgLy8gc2VsZi5fc2V0X2lycmV2ZXJzaWJsZV9mbGFnX3ZhbHVlKGFzc2V0X2lkLCBVSW50NjQoZmxnLklSUl9GTEdfSU1NVVRBQkxFKSkKICAgIGR1cAogICAgcHVzaGludCA3CiAgICBjYWxsc3ViIF9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfdmFsdWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Nzc1LTc3NgogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9wYXJ0aWFsX3VyaVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9wYXJ0aWFsX3VyaToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODA4CiAgICAvLyBhcmM5MF9ib3hfcXVlcnkoR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQsIEJ5dGVzKCkpCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIGJ5dGVjXzEgLy8gMHgKICAgIGNhbGxzdWIgYXJjOTBfYm94X3F1ZXJ5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhOgogICAgYnl0ZWNfMSAvLyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODMxCiAgICAvLyBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBjb25zdC5NQVhfTUVUQURBVEFfU0laRQogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjIDYgLy8gMzA1MDYKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgyOS04MzIKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBjb25zdC5NQVhfTUVUQURBVEFfU0laRQogICAgLy8gKSwgZXJyLkVYQ0VFRFNfTUFYX01FVEFEQVRBX1NJWkUKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1ldGFkYXRhIHNpemUsIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDYKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgaXRvYgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgzNAogICAgLy8gaWYgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODM1CiAgICAvLyBtZXRhZGF0YV9zaXplID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGR1cAogICAgYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgzNgogICAgLy8gZmxhdF9tYnIgPSBVSW50NjQoMCkKICAgIGludGNfMSAvLyAwCiAgICBidXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODM3CiAgICAvLyBpZiBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA9PSBtZXRhZGF0YV9zaXplOgogICAgZGlnIDEKICAgID09CiAgICBieiBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2Vsc2VfYm9keUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgzOQogICAgLy8gZGVsdGFfc2l6ZSA9IFVJbnQ2NCgwKQogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODM4CiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9OVUxMKQogICAgZHVwCgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2FmdGVyX2lmX2Vsc2VAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg1NQogICAgLy8gZGVsdGFfYW1vdW50ID0gZmxhdF9tYnIgKyBjb25zdC5CWVRFX01CUiAqIGRlbHRhX3NpemUKICAgIHB1c2hpbnQgNDAwCiAgICB1bmNvdmVyIDIKICAgICoKICAgIGRpZyA1CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg1NwogICAgLy8gcmV0dXJuIGFiaS5NYnJEZWx0YShzaWduPWFyYzQuVUludDgoc2lnbiksIGFtb3VudD1hcmM0LlVJbnQ2NChkZWx0YV9hbW91bnQpKQogICAgc3dhcAogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMiAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2Vsc2VfYm9keUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDAKICAgIC8vIGVsaWYgbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkgPiBtZXRhZGF0YV9zaXplOgogICAgZHVwCiAgICBkaWcgMwogICAgPgogICAgYnogYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9lbHNlX2JvZHlANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDEKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX1BPUykKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg0MgogICAgLy8gZGVsdGFfc2l6ZSA9IG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpIC0gbWV0YWRhdGFfc2l6ZQogICAgZGlnIDEKICAgIGRpZyA0CiAgICAtCiAgICBzd2FwCiAgICBiIGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfYWZ0ZXJfaWZfZWxzZUAxMAoKYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9lbHNlX2JvZHlANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODQ0CiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9ORUcpCiAgICBwdXNoaW50IDI1NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDUKICAgIC8vIGRlbHRhX3NpemUgPSBtZXRhZGF0YV9zaXplIC0gbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIGRpZyAzCiAgICBkaWcgMgogICAgLQogICAgc3dhcAogICAgYiBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2FmdGVyX2lmX2Vsc2VAMTAKCmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg0NwogICAgLy8gZmxhdF9tYnIgPSBVSW50NjQoY29uc3QuRkxBVF9NQlIpCiAgICBwdXNoaW50IDI1MDAKICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDgKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX1BPUykKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg1MC04NTEKICAgIC8vIGNvbnN0LkFTU0VUX01FVEFEQVRBX0JPWF9LRVlfU0laRQogICAgLy8gKyBjb25zdC5IRUFERVJfU0laRQogICAgcHVzaGludCA1OQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NTAtODUyCiAgICAvLyBjb25zdC5BU1NFVF9NRVRBREFUQV9CT1hfS0VZX1NJWkUKICAgIC8vICsgY29uc3QuSEVBREVSX1NJWkUKICAgIC8vICsgbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIGRpZyAyCiAgICArCiAgICBzd2FwCiAgICBiIGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfYWZ0ZXJfaWZfZWxzZUAxMAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9jaGVja19tZXRhZGF0YV9leGlzdHNbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9jaGVja19tZXRhZGF0YV9leGlzdHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg1OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MTUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGR1cAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NzUKICAgIC8vIGFzYV9leGlzdHM9YXJjNC5Cb29sKHNlbGYuX2FzYV9leGlzdHMoYXNzZXRfaWQpKSwKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ2CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIHN3YXAKICAgIGl0b2IKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NzYKICAgIC8vIG1ldGFkYXRhX2V4aXN0cz1hcmM0LkJvb2woc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzc2V0X2lkKSksCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NzQtODc3CiAgICAvLyByZXR1cm4gYWJpLk1ldGFkYXRhRXhpc3RlbmNlKAogICAgLy8gICAgIGFzYV9leGlzdHM9YXJjNC5Cb29sKHNlbGYuX2FzYV9leGlzdHMoYXNzZXRfaWQpKSwKICAgIC8vICAgICBtZXRhZGF0YV9leGlzdHM9YXJjNC5Cb29sKHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc3NldF9pZCkpLAogICAgLy8gKQogICAgaW50Y18xIC8vIDAKICAgIGdldGJpdAogICAgaW50Y18wIC8vIDEKICAgIHN3YXAKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NTkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg3OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODk0LTg5NQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk4CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ni05OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOQogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDctMTEwCiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9pcnJldmVyc2libGVfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4OTgKICAgIC8vIHNlbGYuX2lzX2ltbXV0YWJsZShhc3NldF9pZCkgb3IgYXNzZXRfaWQubWFuYWdlciA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBibnogYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlX2Jvb2xfdHJ1ZUAzCiAgICBkdXAKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICBieiBhcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF9mYWxzZUA0CgphcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF90cnVlQDM6CiAgICBpbnRjXzAgLy8gMQoKYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODk3LTg5OQogICAgLy8gcmV0dXJuIGFyYzQuQm9vbCgKICAgIC8vICAgICBzZWxmLl9pc19pbW11dGFibGUoYXNzZXRfaWQpIG9yIGFzc2V0X2lkLm1hbmFnZXIgPT0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgLy8gKQogICAgYnl0ZWNfMiAvLyAweDAwCiAgICBpbnRjXzEgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODc5CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZV9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzEgLy8gMAogICAgYiBhcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2lzX21ldGFkYXRhX3Nob3J0W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfaXNfbWV0YWRhdGFfc2hvcnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkxNi05MTcKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NS01OAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1LTU4CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY4CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Ni02OQogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTIwCiAgICAvLyBmbGFnPWFyYzQuQm9vbChzZWxmLl9pc19zaG9ydChhc3NldF9pZCkpLAogICAgYnl0ZWNfMiAvLyAweDAwCiAgICBpbnRjXzEgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMyLTEzNQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICAvLyApCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzNAogICAgLy8gbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIGludGNfMiAvLyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMi0xMzUKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMxLTEzNgogICAgLy8gcmV0dXJuIG9wLmJ0b2koCiAgICAvLyAgICAgc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyMQogICAgLy8gbGFzdF9tb2RpZmllZF9yb3VuZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCkpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MTktOTIyCiAgICAvLyByZXR1cm4gYWJpLk11dGFibGVGbGFnKAogICAgLy8gICAgIGZsYWc9YXJjNC5Cb29sKHNlbGYuX2lzX3Nob3J0KGFzc2V0X2lkKSksCiAgICAvLyAgICAgbGFzdF9tb2RpZmllZF9yb3VuZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCkpLAogICAgLy8gKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfaGVhZGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NDAtOTQxCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTUtNTgKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NwogICAgLy8gbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NS01OAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3Mi03NAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyLTc0CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ni05OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2LTk5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIxLTEyMwogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0hBU0hfU0laRQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIyCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0hBU0hfU0laRQogICAgcHVzaGludHMgMyAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjEtMTIzCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSEFTSF9TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzItMTM1CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICkKICAgIGRpZyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzNAogICAgLy8gbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIGludGNfMiAvLyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMi0xMzUKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMxLTEzNgogICAgLy8gcmV0dXJuIG9wLmJ0b2koCiAgICAvLyAgICAgc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk1MAogICAgLy8gbGFzdF9tb2RpZmllZF9yb3VuZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCkpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDYtMTQ5CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkRFUFJFQ0FURURfQllfU0laRSwKICAgIC8vICkKICAgIHVuY292ZXIgNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9ERVBSRUNBVEVEX0JZLAogICAgcHVzaGludCA0MwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDgKICAgIC8vIGxlbmd0aD1jb25zdC5ERVBSRUNBVEVEX0JZX1NJWkUsCiAgICBpbnRjXzIgLy8gOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDYtMTQ5CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkRFUFJFQ0FURURfQllfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0NS0xNTAKICAgIC8vIHJldHVybiBvcC5idG9pKAogICAgLy8gICAgIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICAvLyAgICAgICAgIGxlbmd0aD1jb25zdC5ERVBSRUNBVEVEX0JZX1NJWkUsCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NTEKICAgIC8vIGRlcHJlY2F0ZWRfYnk9YXJjNC5VSW50NjQoc2VsZi5fZ2V0X2RlcHJlY2F0ZWRfYnkoYXNzZXRfaWQpKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTQzLTk1MgogICAgLy8gcmV0dXJuIGFiaS5NZXRhZGF0YUhlYWRlcigKICAgIC8vICAgICBpZGVudGlmaWVycz1hcmM0LkJ5dGUuZnJvbV9ieXRlcyhzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNzZXRfaWQpKSwKICAgIC8vICAgICByZXZlcnNpYmxlX2ZsYWdzPWFyYzQuQnl0ZS5mcm9tX2J5dGVzKHNlbGYuX2dldF9yZXZlcnNpYmxlX2ZsYWdzKGFzc2V0X2lkKSksCiAgICAvLyAgICAgaXJyZXZlcnNpYmxlX2ZsYWdzPWFyYzQuQnl0ZS5mcm9tX2J5dGVzKAogICAgLy8gICAgICAgICBzZWxmLl9nZXRfaXJyZXZlcnNpYmxlX2ZsYWdzKGFzc2V0X2lkKQogICAgLy8gICAgICksCiAgICAvLyAgICAgaGFzaD1hYmkuSGFzaC5mcm9tX2J5dGVzKHNlbGYuX2dldF9tZXRhZGF0YV9oYXNoKGFzc2V0X2lkKSksCiAgICAvLyAgICAgbGFzdF9tb2RpZmllZF9yb3VuZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCkpLAogICAgLy8gICAgIGRlcHJlY2F0ZWRfYnk9YXJjNC5VSW50NjQoc2VsZi5fZ2V0X2RlcHJlY2F0ZWRfYnkoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIHVuY292ZXIgNQogICAgdW5jb3ZlciA1CiAgICBjb25jYXQKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfcGFnaW5hdGlvbltyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9wYWdpbmF0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NjgtOTY5CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NzIKICAgIC8vIG1ldGFkYXRhX3NpemU9YXJjNC5VSW50MTYoc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpKSwKICAgIGR1cAogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBwdXNoaW50IDE2CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDYgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMzEKICAgIC8vIG4gPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjkKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIGludGMgNSAvLyAxMDA2CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzMgogICAgLy8gcmV0dXJuIGNlaWxfZGl2KG51bT1uLCBkZW49VUludDY0KGNvbnN0LlBBR0VfU0laRSkpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjkKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTc0CiAgICAvLyB0b3RhbF9wYWdlcz1hcmM0LlVJbnQ4KHNlbGYuX2dldF90b3RhbF9wYWdlcyhhc3NldF9pZCkpLAogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMiAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NzEtOTc1CiAgICAvLyByZXR1cm4gYWJpLlBhZ2luYXRpb24oCiAgICAvLyAgICAgbWV0YWRhdGFfc2l6ZT1hcmM0LlVJbnQxNihzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc3NldF9pZCkpLAogICAgLy8gICAgIHBhZ2Vfc2l6ZT1hcmM0LlVJbnQxNihjb25zdC5QQUdFX1NJWkUpLAogICAgLy8gICAgIHRvdGFsX3BhZ2VzPWFyYzQuVUludDgoc2VsZi5fZ2V0X3RvdGFsX3BhZ2VzKGFzc2V0X2lkKSksCiAgICAvLyApCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3MwogICAgLy8gcGFnZV9zaXplPWFyYzQuVUludDE2KGNvbnN0LlBBR0VfU0laRSksCiAgICBwdXNoYnl0ZXMgMHgwM2VmCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3MS05NzUKICAgIC8vIHJldHVybiBhYmkuUGFnaW5hdGlvbigKICAgIC8vICAgICBtZXRhZGF0YV9zaXplPWFyYzQuVUludDE2KHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSksCiAgICAvLyAgICAgcGFnZV9zaXplPWFyYzQuVUludDE2KGNvbnN0LlBBR0VfU0laRSksCiAgICAvLyAgICAgdG90YWxfcGFnZXM9YXJjNC5VSW50OChzZWxmLl9nZXRfdG90YWxfcGFnZXMoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk1NAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YToKICAgIGJ5dGVjXzEgLy8gIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTc3CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5NC05OTUKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzMQogICAgLy8gbiA9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyOQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgaW50YyA1IC8vIDEwMDYKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjMyCiAgICAvLyByZXR1cm4gY2VpbF9kaXYobnVtPW4sIGRlbj1VSW50NjQoY29uc3QuUEFHRV9TSVpFKSkKICAgIGludGMgNCAvLyAxMDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyOQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgZHVwCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5NwogICAgLy8gaWYgdG90YWxfcGFnZXMgPiAwOgogICAgYnogYXJjODlfZ2V0X21ldGFkYXRhX2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5OAogICAgLy8gYXNzZXJ0IHBhZ2UuYXNfdWludDY0KCkgPCB0b3RhbF9wYWdlcywgZXJyLlBBR0VfSURYX0lOVkFMSUQKICAgIGJ0b2kKICAgIGR1cAogICAgZGlnIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgPAogICAgYXNzZXJ0IC8vIEludmFsaWQgcGFnZSBpbmRleAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OTkKICAgIC8vIGhhc19uZXh0X3BhZ2UgPSBwYWdlLmFzX3VpbnQ2NCgpIDwgdG90YWxfcGFnZXMgLSAxCiAgICBpbnRjXzAgLy8gMQogICAgLQogICAgZGlnIDEKICAgID4KICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDAwCiAgICAvLyBwYWdlX2NvbnRlbnQgPSBzZWxmLl9nZXRfbWV0YWRhdGFfcGFnZShhc3NldF9pZCwgcGFnZS5hc191aW50NjQoKSkKICAgIGRpZyAyCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfcGFnZQoKYXJjODlfZ2V0X21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAwNwogICAgLy8gaGFzX25leHRfcGFnZT1hcmM0LkJvb2woaGFzX25leHRfcGFnZSksCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICBkaWcgNQogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZGlnIDMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMzCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIHB1c2hpbnQgMzUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTM0CiAgICAvLyBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgaW50Y18yIC8vIDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMyLTEzNQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzEtMTM2CiAgICAvLyByZXR1cm4gb3AuYnRvaSgKICAgIC8vICAgICBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAwOAogICAgLy8gbGFzdF9tb2RpZmllZF9yb3VuZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCkpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDA5CiAgICAvLyBwYWdlX2NvbnRlbnQ9YXJjNC5EeW5hbWljQnl0ZXMocGFnZV9jb250ZW50KSwKICAgIHVuY292ZXIgMgogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAwNi0xMDEwCiAgICAvLyByZXR1cm4gYWJpLlBhZ2luYXRlZE1ldGFkYXRhKAogICAgLy8gICAgIGhhc19uZXh0X3BhZ2U9YXJjNC5Cb29sKGhhc19uZXh0X3BhZ2UpLAogICAgLy8gICAgIGxhc3RfbW9kaWZpZWRfcm91bmQ9YXJjNC5VSW50NjQoc2VsZi5fZ2V0X2xhc3RfbW9kaWZpZWRfcm91bmQoYXNzZXRfaWQpKSwKICAgIC8vICAgICBwYWdlX2NvbnRlbnQ9YXJjNC5EeW5hbWljQnl0ZXMocGFnZV9jb250ZW50KSwKICAgIC8vICkKICAgIGNvdmVyIDIKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MDAwYgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTc3CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X2dldF9tZXRhZGF0YV9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAwMgogICAgLy8gYXNzZXJ0IHBhZ2UuYXNfdWludDY0KCkgPT0gMCwgZXJyLlBBR0VfSURYX0lOVkFMSUQKICAgIGJ0b2kKICAgICEKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBhZ2UgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAwMwogICAgLy8gaGFzX25leHRfcGFnZSA9IEZhbHNlCiAgICBpbnRjXzEgLy8gMAogICAgYnVyeSAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMDQKICAgIC8vIHBhZ2VfY29udGVudCA9IEJ5dGVzKCkKICAgIGJ5dGVjXzEgLy8gMHgKICAgIGIgYXJjODlfZ2V0X21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfc2xpY2Vbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfc2xpY2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDMxLTEwMzIKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMgogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAzMwogICAgLy8gYXNzZXJ0IHNpemUuYXNfdWludDY0KCkgPD0gY29uc3QuUEFHRV9TSVpFLCBlcnIuRVhDRUVEU19QQUdFX1NJWkUKICAgIGJ0b2kKICAgIGR1cAogICAgaW50YyA0IC8vIDEwMDcKICAgIDw9CiAgICBhc3NlcnQgLy8gUGF5bG9hZCBleGNlZWRzIHBhZ2Ugc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDM0CiAgICAvLyBhc3NlcnQgb2Zmc2V0LmFzX3VpbnQ2NCgpICsgc2l6ZS5hc191aW50NjQoKSA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIHN3YXAKICAgIGJ0b2kKICAgIGR1cAogICAgZGlnIDIKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAzNC0xMDM2CiAgICAvLyBhc3NlcnQgb2Zmc2V0LmFzX3VpbnQ2NCgpICsgc2l6ZS5hc191aW50NjQoKSA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLkVYQ0VFRFNfTUVUQURBVEFfU0laRQogICAgZGlnIDMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICA8PQogICAgYXNzZXJ0IC8vIFNsaWNlIGV4Y2VlZHMgbWV0YWRhdGEgcmFuZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAzOAogICAgLy8gbWV0YWRhdGFfc2xpY2UgPSBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc3NldF9pZCkuZXh0cmFjdCgKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDM5CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBvZmZzZXQuYXNfdWludDY0KCksIGxlbmd0aD1zaXplLmFzX3VpbnQ2NCgpCiAgICBwdXNoaW50IDUxCiAgICB1bmNvdmVyIDIKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAzOC0xMDQwCiAgICAvLyBtZXRhZGF0YV9zbGljZSA9IHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzc2V0X2lkKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldC5hc191aW50NjQoKSwgbGVuZ3RoPXNpemUuYXNfdWludDY0KCkKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAxMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJfaGFzaFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA0MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNTgtMTA1OQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA2MQogICAgLy8gcmV0dXJuIGFiaS5IYXNoLmZyb21fYnl0ZXMoc2VsZi5fY29tcHV0ZV9oZWFkZXJfaGFzaChhc3NldF9pZCkpCiAgICBjYWxsc3ViIF9jb21wdXRlX2hlYWRlcl9oYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfcGFnZV9oYXNoW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA2MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4MC0xMDgxCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzMQogICAgLy8gbiA9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjkKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIGludGMgNSAvLyAxMDA2CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzMgogICAgLy8gcmV0dXJuIGNlaWxfZGl2KG51bT1uLCBkZW49VUludDY0KGNvbnN0LlBBR0VfU0laRSkpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjkKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4MwogICAgLy8gaWYgdG90YWxfcGFnZXMgPiAwOgogICAgZHVwCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgZW1wdHkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4NAogICAgLy8gYXNzZXJ0IHBhZ2UuYXNfdWludDY0KCkgPCB0b3RhbF9wYWdlcywgZXJyLlBBR0VfSURYX0lOVkFMSUQKICAgIHN3YXAKICAgIGJ0b2kKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICA8CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYWdlIGluZGV4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwODgKICAgIC8vIHBhZ2VfY29udGVudCA9IHNlbGYuX2dldF9tZXRhZGF0YV9wYWdlKGFzc2V0X2lkLCBwYWdlLmFzX3VpbnQ2NCgpKQogICAgZHVwMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3BhZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4OQogICAgLy8gcGFnZV9oYXNoID0gc2VsZi5fY29tcHV0ZV9wYWdlX2hhc2goYXNzZXRfaWQsIHBhZ2UuYXNfdWludDY0KCksIHBhZ2VfY29udGVudCkKICAgIGNhbGxzdWIgX2NvbXB1dGVfcGFnZV9oYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNjMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfaGFzaFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9oYXNoOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDkyCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEwNy0xMTA4CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjEKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMgogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIHB1c2hpbnRzIDMgMzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIxLTEyMwogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0hBU0hfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA5MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9zdHJpbmdfYnlfa2V5W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX3N0cmluZ19ieV9rZXk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTMxLTExMzIKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEzNC0xMTM5CiAgICAvLyAjIEZldGNoIGtleSdzIHZhbHVlCiAgICAvLyAjIOKaoO+4jyBXQVJOSU5HOiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgY2F1c2UgQVZNIHJ1bnRpbWUgZXJyb3I6CiAgICAvLyAjIC0gVGhlIHNob3J0IE1ldGFkYXRhIGlzIG5vdCBhIHZhbGlkIFVURi04IGVuY29kZWQgSlNPTiBvYmplY3QKICAgIC8vICMgLSBUaGUgdG9wLWxldmVsIGtleSBkb2VzIG5vdCBleGlzdAogICAgLy8gIyAtIFRoZSB0b3AtbGV2ZWwga2V5J3MgdmFsdWUgaXMgbm90IGEgSlNPTiBTdHJpbmcKICAgIC8vIG9iaiA9IHNlbGYuX2dldF9zaG9ydF9tZXRhZGF0YShhc3NldF9pZCkKICAgIHN3YXAKICAgIGNhbGxzdWIgX2dldF9zaG9ydF9tZXRhZGF0YQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTQwCiAgICAvLyB2YWx1ZSA9IG9wLkpzb25SZWYuanNvbl9zdHJpbmcob2JqLCBrZXkubmF0aXZlLmJ5dGVzKQogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGpzb25fcmVmIEpTT05TdHJpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE0Mi0xMTQzCiAgICAvLyAjIFBvc3Rjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgdmFsdWUubGVuZ3RoIDw9IGNvbnN0LlBBR0VfU0laRSwgZXJyLkVYQ0VFRFNfUEFHRV9TSVpFCiAgICBkdXAKICAgIGxlbgogICAgaW50YyA0IC8vIDEwMDcKICAgIDw9CiAgICBhc3NlcnQgLy8gUGF5bG9hZCBleGNlZWRzIHBhZ2Ugc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTEyCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX3VpbnQ2NF9ieV9rZXlbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfdWludDY0X2J5X2tleToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE0NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNjYtMTE2NwogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTY5LTExNzQKICAgIC8vICMgRmV0Y2gga2V5J3MgdmFsdWUKICAgIC8vICMg4pqg77iPIFdBUk5JTkc6IFRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBjYXVzZSBBVk0gcnVudGltZSBlcnJvcjoKICAgIC8vICMgLSBUaGUgc2hvcnQgTWV0YWRhdGEgaXMgbm90IGEgdmFsaWQgVVRGLTggZW5jb2RlZCBKU09OIG9iamVjdAogICAgLy8gIyAtIFRoZSB0b3AtbGV2ZWwga2V5IGRvZXMgbm90IGV4aXN0CiAgICAvLyAjIC0gVGhlIHRvcC1sZXZlbCBrZXkncyB2YWx1ZSBpcyBub3QgYSBKU09OIFVpbnQ2NAogICAgLy8gb2JqID0gc2VsZi5fZ2V0X3Nob3J0X21ldGFkYXRhKGFzc2V0X2lkKQogICAgc3dhcAogICAgY2FsbHN1YiBfZ2V0X3Nob3J0X21ldGFkYXRhCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNzUKICAgIC8vIHZhbHVlID0gb3AuSnNvblJlZi5qc29uX3VpbnQ2NChvYmosIGtleS5uYXRpdmUuYnl0ZXMpCiAgICBzd2FwCiAgICBleHRyYWN0IDIgMAogICAganNvbl9yZWYgSlNPTlVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTc3CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQodmFsdWUpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNDcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9vYmplY3RfYnlfa2V5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTc5CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE5OC0xMTk5CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMDEtMTIwNgogICAgLy8gIyBGZXRjaCBrZXkncyB2YWx1ZQogICAgLy8gIyDimqDvuI8gV0FSTklORzogVGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGNhdXNlIEFWTSBydW50aW1lIGVycm9yOgogICAgLy8gIyAtIFRoZSBzaG9ydCBNZXRhZGF0YSBpcyBub3QgYSB2YWxpZCBVVEYtOCBlbmNvZGVkIEpTT04gb2JqZWN0CiAgICAvLyAjIC0gVGhlIHRvcC1sZXZlbCBrZXkgZG9lcyBub3QgZXhpc3QKICAgIC8vICMgLSBUaGUgdG9wLWxldmVsIGtleSdzIHZhbHVlIGlzIG5vdCBhIEpTT04gT2JqZWN0CiAgICAvLyBvYmogPSBzZWxmLl9nZXRfc2hvcnRfbWV0YWRhdGEoYXNzZXRfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfc2hvcnRfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIwNwogICAgLy8gdmFsdWUgPSBvcC5Kc29uUmVmLmpzb25fb2JqZWN0KG9iaiwga2V5Lm5hdGl2ZS5ieXRlcykKICAgIHN3YXAKICAgIGV4dHJhY3QgMiAwCiAgICBqc29uX3JlZiBKU09OT2JqZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMDktMTIxMAogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IHZhbHVlLmxlbmd0aCA8PSBjb25zdC5QQUdFX1NJWkUsIGVyci5FWENFRURTX1BBR0VfU0laRQogICAgZHVwCiAgICBsZW4KICAgIGludGMgNCAvLyAxMDA3CiAgICA8PQogICAgYXNzZXJ0IC8vIFBheWxvYWQgZXhjZWVkcyBwYWdlIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE3OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9iNjRfYnl0ZXNfYnlfa2V5W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX2I2NF9ieXRlc19ieV9rZXk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMzEtMTIzMgogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAyCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjM0CiAgICAvLyBiNjRfZW5jb2RpbmcuYXNfdWludDY0KCkgPD0gZW51bXMuQjY0X1NURF9FTkNPRElORwogICAgYnRvaQogICAgZHVwCiAgICBpbnRjXzAgLy8gMQogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIzMy0xMjM1CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIGI2NF9lbmNvZGluZy5hc191aW50NjQoKSA8PSBlbnVtcy5CNjRfU1REX0VOQ09ESU5HCiAgICAvLyApLCBlcnIuQjY0X0VOQ09ESU5HX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIGJhc2U2NCBlbmNvZGluZywgbXVzdCBiZSAwIChVUkwgc2FmZSkgb3IgMSAoU3RkKQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjM3LTEyNDIKICAgIC8vICMgRmV0Y2gga2V5J3MgdmFsdWUKICAgIC8vICMg4pqg77iPIFdBUk5JTkc6IFRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBjYXVzZSBBVk0gcnVudGltZSBlcnJvcjoKICAgIC8vICMgLSBUaGUgc2hvcnQgTWV0YWRhdGEgaXMgbm90IGEgdmFsaWQgVVRGLTggZW5jb2RlZCBKU09OIG9iamVjdAogICAgLy8gIyAtIFRoZSB0b3AtbGV2ZWwga2V5IGRvZXMgbm90IGV4aXN0CiAgICAvLyAjIC0gVGhlIHRvcC1sZXZlbCBrZXkncyB2YWx1ZSBpcyBub3QgYSBKU09OIFN0cmluZwogICAgLy8gb2JqID0gc2VsZi5fZ2V0X3Nob3J0X21ldGFkYXRhKGFzc2V0X2lkKQogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIF9nZXRfc2hvcnRfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI0MwogICAgLy8gdmFsdWUgPSBvcC5Kc29uUmVmLmpzb25fc3RyaW5nKG9iaiwga2V5Lm5hdGl2ZS5ieXRlcykKICAgIHVuY292ZXIgMgogICAgZXh0cmFjdCAyIDAKICAgIGpzb25fcmVmIEpTT05TdHJpbmcKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI0NS0xMjQ5CiAgICAvLyAjIERlY29kZSB2YWx1ZQogICAgLy8gIyDimqDvuI8gV0FSTklORzogVGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGNhdXNlIEFWTSBydW50aW1lIGVycm9yOgogICAgLy8gIyAtIFRoZSB0b3AtbGV2ZWwga2V5J3MgdmFsdWUgaXMgbm90IGEgdmFsaWQgYmFzZTY0LWVuY29kaW5nIHN0cmluZyBmb3IKICAgIC8vICMgdGhlIGNob3NlbiBlbmNvZGluZy4KICAgIC8vIGlmIGI2NF9lbmNvZGluZy5hc191aW50NjQoKSA9PSBlbnVtcy5CNjRfVVJMX0VOQ09ESU5HOgogICAgYm56IGFyYzg5X2dldF9tZXRhZGF0YV9iNjRfYnl0ZXNfYnlfa2V5X2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNTAKICAgIC8vIGRlY29kZWRfdmFsdWUgPSBvcC5iYXNlNjRfZGVjb2RlKG9wLkJhc2U2NC5VUkxFbmNvZGluZywgdmFsdWUpCiAgICBiYXNlNjRfZGVjb2RlIFVSTEVuY29kaW5nCgphcmM4OV9nZXRfbWV0YWRhdGFfYjY0X2J5dGVzX2J5X2tleV9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNTQtMTI1NQogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IGRlY29kZWRfdmFsdWUubGVuZ3RoIDw9IGNvbnN0LlBBR0VfU0laRSwgZXJyLkVYQ0VFRFNfUEFHRV9TSVpFCiAgICBkdXAKICAgIGxlbgogICAgaW50YyA0IC8vIDEwMDcKICAgIDw9CiAgICBhc3NlcnQgLy8gUGF5bG9hZCBleGNlZWRzIHBhZ2Ugc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjE0CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X2dldF9tZXRhZGF0YV9iNjRfYnl0ZXNfYnlfa2V5X2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjUyCiAgICAvLyBkZWNvZGVkX3ZhbHVlID0gb3AuYmFzZTY0X2RlY29kZShvcC5CYXNlNjQuU3RkRW5jb2RpbmcsIHZhbHVlKQogICAgYmFzZTY0X2RlY29kZSBTdGRFbmNvZGluZwogICAgYiBhcmM4OV9nZXRfbWV0YWRhdGFfYjY0X2J5dGVzX2J5X2tleV9hZnRlcl9pZl9lbHNlQDQKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkud2l0aGRyYXdfYmFsYW5jZV9leGNlc3Nbcm91dGluZ10oKSAtPiB2b2lkOgp3aXRoZHJhd19iYWxhbmNlX2V4Y2VzczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3NQogICAgLy8gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3NgogICAgLy8gLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3NS0xMjc2CiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UKICAgIC8vIC0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjc4LTEyODEKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1HbG9iYWwuY3JlYXRvcl9hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1leGNlc3NfYmFsYW5jZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3OQogICAgLy8gcmVjZWl2ZXI9R2xvYmFsLmNyZWF0b3JfYWRkcmVzcywKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3OAogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18wIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18xIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNzgtMTI4MQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPUdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50PWV4Y2Vzc19iYWxhbmNlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI2NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfdmFsdWUoYXNhOiB1aW50NjQsIGZsYWc6IHVpbnQ2NCkgLT4gdm9pZDoKX3NldF9pcnJldmVyc2libGVfZmxhZ192YWx1ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEyCiAgICAvLyBkZWYgX3NldF9pcnJldmVyc2libGVfZmxhZ192YWx1ZShzZWxmLCBhc2E6IEFzc2V0LCBmbGFnOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYtOTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYtOTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTUKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgcHVzaGludCA3CiAgICBmcmFtZV9kaWcgLTEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE2CiAgICAvLyBUcnVlLCAgIyBub3FhOiBGQlQwMDMKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMy0xMTcKICAgIC8vIHVwZGF0ZWRfZmxhZ3MgPSBvcC5zZXRiaXRfYnl0ZXMoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gICAgIFRydWUsICAjIG5vcWE6IEZCVDAwMwogICAgLy8gKQogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMi0xMDQKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fZ2V0X21ldGFkYXRhX3NpemUoYXNhOiB1aW50NjQpIC0+IHVpbnQ2NDoKX2dldF9tZXRhZGF0YV9zaXplOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTgKICAgIC8vIGRlZiBfZ2V0X21ldGFkYXRhX3NpemUoc2VsZiwgYXNhOiBBc3NldCkgLT4gVUludDY0OgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkubGVuZ3RoIC0gY29uc3QuSEVBREVSX1NJWkUKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgYm94X2xlbgogICAgYXNzZXJ0IC8vIGNoZWNrIEJveCBleGlzdHMKICAgIHB1c2hpbnQgNTEKICAgIC0KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fYXBwZW5kX3BheWxvYWQoYXNhOiB1aW50NjQsIHBheWxvYWQ6IGJ5dGVzKSAtPiB2b2lkOgpfYXBwZW5kX3BheWxvYWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2MQogICAgLy8gZGVmIF9hcHBlbmRfcGF5bG9hZChzZWxmLCBhc2E6IEFzc2V0LCBwYXlsb2FkOiBCeXRlcykgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNjIKICAgIC8vIG9sZF9hc3NldF9tZXRhZGF0YV9ib3hfc2l6ZSA9IHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkubGVuZ3RoCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIGR1cAogICAgYm94X2xlbgogICAgYXNzZXJ0IC8vIGNoZWNrIEJveCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTY0CiAgICAvLyBuZXdfc2l6ZT1vbGRfYXNzZXRfbWV0YWRhdGFfYm94X3NpemUgKyBwYXlsb2FkLmxlbmd0aAogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgIGRpZyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2My0xNjUKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVzaXplKAogICAgLy8gICAgIG5ld19zaXplPW9sZF9hc3NldF9tZXRhZGF0YV9ib3hfc2l6ZSArIHBheWxvYWQubGVuZ3RoCiAgICAvLyApCiAgICBkaWcgMgogICAgc3dhcAogICAgYm94X3Jlc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNjYtMTY4CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9b2xkX2Fzc2V0X21ldGFkYXRhX2JveF9zaXplLCB2YWx1ZT1wYXlsb2FkCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTEKICAgIGJveF9yZXBsYWNlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX3NldF9tZXRhZGF0YV9wYXlsb2FkKGFzYTogdWludDY0LCBtZXRhZGF0YV9zaXplOiB1aW50NjQsIHBheWxvYWQ6IGJ5dGVzKSAtPiB2b2lkOgpfc2V0X21ldGFkYXRhX3BheWxvYWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwMC0yMDIKICAgIC8vIGRlZiBfc2V0X21ldGFkYXRhX3BheWxvYWQoCiAgICAvLyAgICAgc2VsZiwgYXNhOiBBc3NldCwgbWV0YWRhdGFfc2l6ZTogVUludDY0LCBwYXlsb2FkOiBCeXRlcwogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwMy0yMDQKICAgIC8vICMgRXJhc2UgZXhpc3RpbmcgbWV0YWRhdGEgcGF5bG9hZAogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXNpemUobmV3X3NpemU9VUludDY0KGNvbnN0LkhFQURFUl9TSVpFKSkKICAgIGZyYW1lX2RpZyAtMwogICAgaXRvYgogICAgZHVwCiAgICBwdXNoaW50IDUxCiAgICBib3hfcmVzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwNi0yMDcKICAgIC8vICMgQXBwZW5kIHByb3ZpZGVkIHBheWxvYWQKICAgIC8vIHNlbGYuX2FwcGVuZF9wYXlsb2FkKGFzYSwgcGF5bG9hZCkKICAgIGZyYW1lX2RpZyAtMwogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9hcHBlbmRfcGF5bG9hZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMDgKICAgIC8vIGFzc2VydCBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpIDw9IG1ldGFkYXRhX3NpemUsIGVyci5QQVlMT0FEX09WRVJGTE9XCiAgICBmcmFtZV9kaWcgLTMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBmcmFtZV9kaWcgLTIKICAgIDw9CiAgICBhc3NlcnQgLy8gUGF5bG9hZCBvdmVyZmxvdywgZXhjZWVkcyBtZXRhZGF0YSBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxMC0yMTEKICAgIC8vICMgQXBwZW5kIHN0YWdlZCBleHRyYSBwYXlsb2FkIChpbiB0aGUgc2FtZSBHcm91cCwgaWYgYW55KQogICAgLy8gZ3JvdXBfc2l6ZSA9IEdsb2JhbC5ncm91cF9zaXplCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxMgogICAgLy8gZ3JvdXBfaW5kZXggPSBUeG4uZ3JvdXBfaW5kZXgKICAgIHR4biBHcm91cEluZGV4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxMwogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoZ3JvdXBfaW5kZXggKyAxLCBncm91cF9zaXplKToKICAgIGludGNfMCAvLyAxCiAgICArCgpfc2V0X21ldGFkYXRhX3BheWxvYWRfZm9yX2hlYWRlckAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTMKICAgIC8vIGZvciBpZHggaW4gdXJhbmdlKGdyb3VwX2luZGV4ICsgMSwgZ3JvdXBfc2l6ZSk6CiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDEKICAgIDwKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9hZnRlcl9mb3JANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODEKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIGZyYW1lX2RpZyAyCiAgICBndHhucyBUeXBlRW51bQogICAgcHVzaGludCA2IC8vIGFwcGwKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4MS0xODMKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODIKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICBmcmFtZV9kaWcgMgogICAgZ3R4bnMgQXBwbGljYXRpb25JRAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODEtMTgzCiAgICAvLyB0eG4udHlwZSA9PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyBhbmQgdHhuLmFwcF9pZCA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZAogICAgLy8gYW5kIHR4bi5vbl9jb21wbGV0aW9uID09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgYnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfZmFsc2VAMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgzCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICBmcmFtZV9kaWcgMgogICAgZ3R4bnMgT25Db21wbGV0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4MS0xODMKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICBibnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfZmFsc2VAMTMKICAgIGludGNfMCAvLyAxCgpfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9tZXJnZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTg4LTE5MQogICAgLy8gc2VsZi5faXNfcmVnaXN0cnlfY2FsbCh0eG4pCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXJjODlJbnRlcmZhY2UuYXJjODlfZXh0cmFfcGF5bG9hZCkKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDODlfRVhUUkFfUEFZTE9BRF9BUkdfQVNTRVRfSUQpID09IG9wLml0b2IoYXNhLmlkKQogICAgYnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfZmFsc2VAMTgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTg5CiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzEgLy8gMAogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTkwCiAgICAvLyA9PSBhcmM0LmFyYzRfc2lnbmF0dXJlKEFyYzg5SW50ZXJmYWNlLmFyYzg5X2V4dHJhX3BheWxvYWQpCiAgICBieXRlY18zIC8vIG1ldGhvZCAiYXJjODlfZXh0cmFfcGF5bG9hZCh1aW50NjQsYnl0ZVtdKXZvaWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4OS0xOTAKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9BUkdfTUVUSE9EX1NFTEVDVE9SKQogICAgLy8gPT0gYXJjNC5hcmM0X3NpZ25hdHVyZShBcmM4OUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTg4LTE5MQogICAgLy8gc2VsZi5faXNfcmVnaXN0cnlfY2FsbCh0eG4pCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXJjODlJbnRlcmZhY2UuYXJjODlfZXh0cmFfcGF5bG9hZCkKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDODlfRVhUUkFfUEFZTE9BRF9BUkdfQVNTRVRfSUQpID09IG9wLml0b2IoYXNhLmlkKQogICAgYnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfZmFsc2VAMTgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTkxCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX0FTU0VUX0lEKSA9PSBvcC5pdG9iKGFzYS5pZCkKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzAgLy8gMQogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAwCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODgtMTkxCiAgICAvLyBzZWxmLl9pc19yZWdpc3RyeV9jYWxsKHR4bikKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9BUkdfTUVUSE9EX1NFTEVDVE9SKQogICAgLy8gPT0gYXJjNC5hcmM0X3NpZ25hdHVyZShBcmM4OUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxOAogICAgaW50Y18wIC8vIDEKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX21lcmdlQDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTUKICAgIC8vIGlmIHNlbGYuX2lzX2V4dHJhX3BheWxvYWRfY2FsbChhc2EsIHR4bik6CiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE5NS0xOTgKICAgIC8vICMgVGhpcyBzdWJyb3V0aW5lIGFzc3VtZXMgdHhuIGlzIGFscmVhZHkgdmFsaWRhdGVkIGFzIGFuIGV4dHJhIHBheWxvYWQgdHhuCiAgICAvLyByZXR1cm4gYXJjNC5EeW5hbWljQnl0ZXMuZnJvbV9ieXRlcygKICAgIC8vICAgICB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDODlfRVhUUkFfUEFZTE9BRF9BUkdfUEFZTE9BRCkKICAgIC8vICkubmF0aXZlCiAgICBmcmFtZV9kaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTcKICAgIC8vIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19QQVlMT0FEKQogICAgaW50Y18zIC8vIDIKICAgIGd0eG5zYXMgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE5NS0xOTgKICAgIC8vICMgVGhpcyBzdWJyb3V0aW5lIGFzc3VtZXMgdHhuIGlzIGFscmVhZHkgdmFsaWRhdGVkIGFzIGFuIGV4dHJhIHBheWxvYWQgdHhuCiAgICAvLyByZXR1cm4gYXJjNC5EeW5hbWljQnl0ZXMuZnJvbV9ieXRlcygKICAgIC8vICAgICB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDODlfRVhUUkFfUEFZTE9BRF9BUkdfUEFZTE9BRCkKICAgIC8vICkubmF0aXZlCiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTgKICAgIC8vIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkgKyBleHRyYV9wYXlsb2FkLmxlbmd0aCA8PSBtZXRhZGF0YV9zaXplCiAgICBmcmFtZV9kaWcgLTMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBkaWcgMQogICAgbGVuCiAgICArCiAgICBmcmFtZV9kaWcgLTIKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxNy0yMTkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSArIGV4dHJhX3BheWxvYWQubGVuZ3RoIDw9IG1ldGFkYXRhX3NpemUKICAgIC8vICksIGVyci5QQVlMT0FEX09WRVJGTE9XCiAgICBhc3NlcnQgLy8gUGF5bG9hZCBvdmVyZmxvdywgZXhjZWVkcyBtZXRhZGF0YSBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIyMAogICAgLy8gc2VsZi5fYXBwZW5kX3BheWxvYWQoYXNhLCBleHRyYV9wYXlsb2FkKQogICAgZnJhbWVfZGlnIC0zCiAgICBzd2FwCiAgICBjYWxsc3ViIF9hcHBlbmRfcGF5bG9hZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMjIKICAgIC8vIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkgPD0gbWV0YWRhdGFfc2l6ZQogICAgZnJhbWVfZGlnIC0zCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgZnJhbWVfZGlnIC0yCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMjEtMjIzCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkgPD0gbWV0YWRhdGFfc2l6ZQogICAgLy8gKSwgZXJyLlBBWUxPQURfT1ZFUkZMT1cKICAgIGFzc2VydCAvLyBQYXlsb2FkIG92ZXJmbG93LCBleGNlZWRzIG1ldGFkYXRhIHNpemUKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxMwogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoZ3JvdXBfaW5kZXggKyAxLCBncm91cF9zaXplKToKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAyCiAgICBiIF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9mb3JfaGVhZGVyQDEKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX2ZhbHNlQDE4OgogICAgaW50Y18xIC8vIDAKICAgIGIgX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfbWVyZ2VAMTkKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX2ZhbHNlQDEzOgogICAgaW50Y18xIC8vIDAKICAgIGIgX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfbWVyZ2VAMTQKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9hZnRlcl9mb3JANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjI0CiAgICAvLyBhc3NlcnQgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSA9PSBtZXRhZGF0YV9zaXplLCBlcnIuTUVUQURBVEFfU0laRV9NSVNNQVRDSAogICAgZnJhbWVfZGlnIC0zCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgZnJhbWVfZGlnIC0yCiAgICA9PQogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIHNpemUgbWlzbWF0Y2gsIG11c3QgYmUgZXhhY3RseSBlcXVhbCB0byBkZWNsYXJlZCBzaXplCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2dldF9tZXRhZGF0YV9wYWdlKGFzYTogdWludDY0LCBwYWdlX2luZGV4OiB1aW50NjQpIC0+IGJ5dGVzOgpfZ2V0X21ldGFkYXRhX3BhZ2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzNAogICAgLy8gZGVmIF9nZXRfbWV0YWRhdGFfcGFnZShzZWxmLCBhc2E6IEFzc2V0LCBwYWdlX2luZGV4OiBVSW50NjQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0MgogICAgLy8gbiA9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNDQKICAgIC8vIHN0YXJ0ID0gcGFnZV9pbmRleCAqIHBzCiAgICBmcmFtZV9kaWcgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjQxCiAgICAvLyBwcyA9IFVJbnQ2NChjb25zdC5QQUdFX1NJWkUpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNDQKICAgIC8vIHN0YXJ0ID0gcGFnZV9pbmRleCAqIHBzCiAgICAqCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNDUKICAgIC8vIGlmIHN0YXJ0ID49IG46CiAgICA+PQogICAgYnogX2dldF9tZXRhZGF0YV9wYWdlX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNDYtMjQ3CiAgICAvLyAjIE91dC1vZi1yYW5nZSBwYWdlIChpbmNsdWRpbmcgZW1wdHkgbWV0YWRhdGEgd2l0aCBwYWdlX2luZGV4ID4gMCkKICAgIC8vIHJldHVybiBCeXRlcyhiIiIpCiAgICBieXRlY18xIC8vIDB4CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKX2dldF9tZXRhZGF0YV9wYWdlX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjQ5CiAgICAvLyByZW1haW5pbmcgPSBuIC0gc3RhcnQKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBjb3ZlciAyCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0MQogICAgLy8gcHMgPSBVSW50NjQoY29uc3QuUEFHRV9TSVpFKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjI0CiAgICAvLyByZXR1cm4gYSBpZiBhIDwgYiBlbHNlIGIKICAgIGRpZyAxCiAgICA8CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0MQogICAgLy8gcHMgPSBVSW50NjQoY29uc3QuUEFHRV9TSVpFKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjI0CiAgICAvLyByZXR1cm4gYSBpZiBhIDwgYiBlbHNlIGIKICAgIHN3YXAKICAgIHNlbGVjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNTIKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjUzCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBzdGFydCwgbGVuZ3RoPWxlbmd0aAogICAgcHVzaGludCA1MQogICAgdW5jb3ZlciAzCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI1Mi0yNTQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgc3RhcnQsIGxlbmd0aD1sZW5ndGgKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9nZXRfc2hvcnRfbWV0YWRhdGEoYXNhOiB1aW50NjQpIC0+IGJ5dGVzOgpfZ2V0X3Nob3J0X21ldGFkYXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjEKICAgIC8vIGRlZiBfZ2V0X3Nob3J0X21ldGFkYXRhKHNlbGYsIGFzYTogQXNzZXQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1LTU4CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NgogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTcKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTUtNTgKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjgKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY2LTY5CiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjIKICAgIC8vIGFzc2VydCBzZWxmLl9pc19zaG9ydChhc2EpLCBlcnIuTUVUQURBVEFfTk9UX1NIT1JUCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgbm90IHNob3J0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2MwogICAgLy8gcmV0dXJuIHNlbGYuX2dldF9zbGljZShhc2EsIFVJbnQ2NCgwKSwgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjU4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBvZmZzZXQsIGxlbmd0aD1zaXplCiAgICBwdXNoaW50IDUxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI1Ny0yNTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LCBsZW5ndGg9c2l6ZQogICAgLy8gKQogICAgc3dhcAogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjYzCiAgICAvLyByZXR1cm4gc2VsZi5fZ2V0X3NsaWNlKGFzYSwgVUludDY0KDApLCBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpKQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9pZGVudGlmeV9tZXRhZGF0YShhc2E6IHVpbnQ2NCkgLT4gdm9pZDoKX2lkZW50aWZ5X21ldGFkYXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjUKICAgIC8vIGRlZiBfaWRlbnRpZnlfbWV0YWRhdGEoc2VsZiwgYXNhOiBBc3NldCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjYKICAgIC8vIG1ldGFkYXRhX3NpemUgPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1LTU4CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NgogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTcKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTUtNTgKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTIKICAgIC8vIHJldHVybiBtZXRhZGF0YV9zaXplIDw9IGNvbnN0LlNIT1JUX01FVEFEQVRBX1NJWkUKICAgIHVuY292ZXIgMgogICAgcHVzaGludCA0MDk2CiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjkKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2Ny0yNzEKICAgIC8vIGlkZW50aWZpZXJzID0gb3Auc2V0Yml0X2J5dGVzKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIC8vICAgICBzZWxmLl9pc19zaG9ydF9tZXRhZGF0YV9zaXplKG1ldGFkYXRhX3NpemUpLAogICAgLy8gKQogICAgc3dhcAogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsIHZhbHVlPWlkZW50aWZpZXJzCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MS02MwogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywgdmFsdWU9aWRlbnRpZmllcnMKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NvbXB1dGVfaGVhZGVyX2hhc2goYXNhOiB1aW50NjQpIC0+IGJ5dGVzOgpfY29tcHV0ZV9oZWFkZXJfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjc0CiAgICAvLyBkZWYgX2NvbXB1dGVfaGVhZGVyX2hhc2goc2VsZiwgYXNhOiBBc3NldCkgLT4gQnl0ZXM6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjc1LTI3NwogICAgLy8gIyBoaCA9IFNIQS01MTIvMjU2KCJhcmMwMDg5L2hlYWRlciIgfHwgQXNzZXQgSUQgfHwgTWV0YWRhdGEgSWRlbnRpZmllcnMKICAgIC8vICMgfHwgUmV2ZXJzaWJsZSBGbGFncyB8fCBJcnJldmVyc2libGUgRmxhZ3MgfHwgTWV0YWRhdGEgU2l6ZSkKICAgIC8vIGVuc3VyZV9idWRnZXQocmVxdWlyZWRfYnVkZ2V0PWNvbnN0LkhFQURFUl9IQVNIX09QX0JVREdFVCkKICAgIHB1c2hpbnQgMTEwCiAgICBpbnRjXzEgLy8gMAogICAgY2FsbHN1YiBlbnN1cmVfYnVkZ2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3OQogICAgLy8gYXNzZXRfaWQgPSBvcC5pdG9iKGFzYS5pZCkKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NS01OAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1LTU4CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyLTc0CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBkaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzItNzQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2LTk5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYtOTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODQKICAgIC8vIHVpbnQ9c2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSwKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjE5CiAgICAvLyByZXR1cm4gb3AuZXh0cmFjdChvcC5pdG9iKHVpbnQpLCBzdGFydCwgc2l6ZSkKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3OAogICAgLy8gZG9tYWluID0gQnl0ZXMoY29uc3QuSEFTSF9ET01BSU5fSEVBREVSKQogICAgcHVzaGJ5dGVzIDB4NjE3MjYzMzAzMDM4MzkyZjY4NjU2MTY0NjU3MgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODgtMjg5CiAgICAvLyBkb21haW4KICAgIC8vICsgYXNzZXRfaWQKICAgIHVuY292ZXIgNQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI4OC0yOTAKICAgIC8vIGRvbWFpbgogICAgLy8gKyBhc3NldF9pZAogICAgLy8gKyBtZXRhZGF0YV9pZGVudGlmaWVycwogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjg4LTI5MQogICAgLy8gZG9tYWluCiAgICAvLyArIGFzc2V0X2lkCiAgICAvLyArIG1ldGFkYXRhX2lkZW50aWZpZXJzCiAgICAvLyArIHJldmVyc2libGVfZmxhZ3MKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI4OC0yOTIKICAgIC8vIGRvbWFpbgogICAgLy8gKyBhc3NldF9pZAogICAgLy8gKyBtZXRhZGF0YV9pZGVudGlmaWVycwogICAgLy8gKyByZXZlcnNpYmxlX2ZsYWdzCiAgICAvLyArIGlycmV2ZXJzaWJsZV9mbGFncwogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjg4LTI5MwogICAgLy8gZG9tYWluCiAgICAvLyArIGFzc2V0X2lkCiAgICAvLyArIG1ldGFkYXRhX2lkZW50aWZpZXJzCiAgICAvLyArIHJldmVyc2libGVfZmxhZ3MKICAgIC8vICsgaXJyZXZlcnNpYmxlX2ZsYWdzCiAgICAvLyArIG1ldGFkYXRhX3NpemUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODctMjk0CiAgICAvLyByZXR1cm4gb3Auc2hhNTEyXzI1NigKICAgIC8vICAgICBkb21haW4KICAgIC8vICAgICArIGFzc2V0X2lkCiAgICAvLyAgICAgKyBtZXRhZGF0YV9pZGVudGlmaWVycwogICAgLy8gICAgICsgcmV2ZXJzaWJsZV9mbGFncwogICAgLy8gICAgICsgaXJyZXZlcnNpYmxlX2ZsYWdzCiAgICAvLyAgICAgKyBtZXRhZGF0YV9zaXplCiAgICAvLyApCiAgICBzaGE1MTJfMjU2CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NvbXB1dGVfcGFnZV9oYXNoKGFzYTogdWludDY0LCBwYWdlX2luZGV4OiB1aW50NjQsIHBhZ2VfY29udGVudDogYnl0ZXMpIC0+IGJ5dGVzOgpfY29tcHV0ZV9wYWdlX2hhc2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI5Ni0yOTgKICAgIC8vIGRlZiBfY29tcHV0ZV9wYWdlX2hhc2goCiAgICAvLyAgICAgc2VsZiwgYXNhOiBBc3NldCwgcGFnZV9pbmRleDogVUludDY0LCBwYWdlX2NvbnRlbnQ6IEJ5dGVzCiAgICAvLyApIC0+IEJ5dGVzOgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI5OS0zMDAKICAgIC8vICMgcGhbaV0gPSBTSEEtNTEyLzI1NigiYXJjMDA4OS9wYWdlIiB8fCBBc3NldCBJRCB8fCBQYWdlIEluZGV4IHx8IFBhZ2UgU2l6ZSB8fCBQYWdlIENvbnRlbnQpCiAgICAvLyBlbnN1cmVfYnVkZ2V0KHJlcXVpcmVkX2J1ZGdldD1jb25zdC5QQUdFX0hBU0hfT1BfQlVER0VUKQogICAgcHVzaGludCAxNTAKICAgIGludGNfMSAvLyAwCiAgICBjYWxsc3ViIGVuc3VyZV9idWRnZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzAyCiAgICAvLyBhc3NldF9pZCA9IG9wLml0b2IoYXNhLmlkKQogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToxOQogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMwNQogICAgLy8gdWludD1wYWdlX2NvbnRlbnQubGVuZ3RoLCBzaXplPVVJbnQ2NChjb25zdC5VSU5UMTZfU0laRSkKICAgIGZyYW1lX2RpZyAtMQogICAgbGVuCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToxOQogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMDEKICAgIC8vIGRvbWFpbiA9IEJ5dGVzKGNvbnN0LkhBU0hfRE9NQUlOX1BBR0UpCiAgICBwdXNoYnl0ZXMgMHg2MTcyNjMzMDMwMzgzOTJmNzA2MTY3NjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzA3CiAgICAvLyByZXR1cm4gb3Auc2hhNTEyXzI1Nihkb21haW4gKyBhc3NldF9pZCArIHBhZ2VfaWR4ICsgcGFnZV9zaXplICsgcGFnZV9jb250ZW50KQogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBzaGE1MTJfMjU2CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NvbXB1dGVfbWV0YWRhdGFfaGFzaChhc2E6IHVpbnQ2NCkgLT4gYnl0ZXM6Cl9jb21wdXRlX21ldGFkYXRhX2hhc2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMwOQogICAgLy8gZGVmIF9jb21wdXRlX21ldGFkYXRhX2hhc2goc2VsZiwgYXNhOiBBc3NldCkgLT4gQnl0ZXM6CiAgICBwcm90byAxIDEKICAgIGJ5dGVjXzEgLy8gIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzEzCiAgICAvLyBoaCA9IHNlbGYuX2NvbXB1dGVfaGVhZGVyX2hhc2goYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9jb21wdXRlX2hlYWRlcl9oYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzMQogICAgLy8gbiA9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjI5CiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICBpbnRjIDUgLy8gMTAwNgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMzIKICAgIC8vIHJldHVybiBjZWlsX2RpdihudW09biwgZGVuPVVJbnQ2NChjb25zdC5QQUdFX1NJWkUpKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjI5CiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICAvCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzE1CiAgICAvLyBjb25jYXRlbmF0ZWRfcGggPSBCeXRlcygpCiAgICBieXRlY18xIC8vIDB4CiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMxNgogICAgLy8gaWYgdG90YWxfcGFnZXMgPiAwOgogICAgYnogX2NvbXB1dGVfbWV0YWRhdGFfaGFzaF9hZnRlcl9pZl9lbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzE3CiAgICAvLyBmb3IgcGFnZV9pbmRleCBpbiB1cmFuZ2UoMCwgdG90YWxfcGFnZXMpOgogICAgaW50Y18xIC8vIDAKICAgIGZyYW1lX2J1cnkgMAoKX2NvbXB1dGVfbWV0YWRhdGFfaGFzaF9mb3JfaGVhZGVyQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMxNwogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKDAsIHRvdGFsX3BhZ2VzKToKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMgogICAgPAogICAgYnogX2NvbXB1dGVfbWV0YWRhdGFfaGFzaF9hZnRlcl9pZl9lbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzE4CiAgICAvLyBwYWdlX2NvbnRlbnQgPSBzZWxmLl9nZXRfbWV0YWRhdGFfcGFnZShhc2EsIHBhZ2VfaW5kZXgpCiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9wYWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMxOQogICAgLy8gcGggPSBzZWxmLl9jb21wdXRlX3BhZ2VfaGFzaChhc2EsIHBhZ2VfaW5kZXgsIHBhZ2VfY29udGVudCkKICAgIGZyYW1lX2RpZyAtMQogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfY29tcHV0ZV9wYWdlX2hhc2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzIwCiAgICAvLyBjb25jYXRlbmF0ZWRfcGggKz0gcGgKICAgIGZyYW1lX2RpZyAzCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMTcKICAgIC8vIGZvciBwYWdlX2luZGV4IGluIHVyYW5nZSgwLCB0b3RhbF9wYWdlcyk6CiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAwCiAgICBiIF9jb21wdXRlX21ldGFkYXRhX2hhc2hfZm9yX2hlYWRlckAyCgpfY29tcHV0ZV9tZXRhZGF0YV9oYXNoX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzEwLTMxMgogICAgLy8gIyBhbSA9IFNIQS01MTIvMjU2KCJhcmMwMDg5L2FtIiB8fCBoaCB8fCBwaFswXSB8fCBwaFsxXSB8fCAuLi4gfHwgcGhbdG90YWxfcGFnZXMgLSAxXSkgb3IKICAgIC8vICMgYW0gPSBTSEEtNTEyLzI1NigiYXJjMDA4OS9hbSIgfHwgaGgpLCBpZiBubyBwYWdlcwogICAgLy8gZG9tYWluID0gQnl0ZXMoY29uc3QuSEFTSF9ET01BSU5fTUVUQURBVEEpCiAgICBwdXNoYnl0ZXMgMHg2MTcyNjMzMDMwMzgzOTJmNjE2ZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMjEKICAgIC8vIHJldHVybiBvcC5zaGE1MTJfMjU2KGRvbWFpbiArIGhoICsgY29uY2F0ZW5hdGVkX3BoKQogICAgZnJhbWVfZGlnIDEKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDMKICAgIGNvbmNhdAogICAgc2hhNTEyXzI1NgogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NoZWNrX2Jhc2VfcHJlY29uZGl0aW9ucyhhc2E6IHVpbnQ2NCwgbWV0YWRhdGFfc2l6ZTogdWludDY0KSAtPiB2b2lkOgpfY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMjMKICAgIC8vIGRlZiBfY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zKHNlbGYsIGFzYTogQXNzZXQsIG1ldGFkYXRhX3NpemU6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjE1CiAgICAvLyBfY3JlYXRvciwgZXhpc3RzID0gb3AuQXNzZXRQYXJhbXNHZXQuYXNzZXRfY3JlYXRvcihhc2EpCiAgICBmcmFtZV9kaWcgLTIKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzI0CiAgICAvLyBhc3NlcnQgc2VsZi5fYXNhX2V4aXN0cyhhc2EpLCBlcnIuQVNBX05PVF9FWElTVAogICAgYXNzZXJ0IC8vIFRoZSBzcGVjaWZpZWQgQVNBIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMyNQogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FzYV9tYW5hZ2VyKGFzYSksIGVyci5VTkFVVEhPUklaRUQKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBfaXNfYXNhX21hbmFnZXIKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQsIG11c3QgYmUgdGhlIEFzc2V0IE1hbmFnZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkKICAgIC8vIHJldHVybiBtZXRhZGF0YV9zaXplIDw9IGNvbnN0Lk1BWF9NRVRBREFUQV9TSVpFCiAgICBmcmFtZV9kaWcgLTEKICAgIGludGMgNiAvLyAzMDUwNgogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzI2LTMyOAogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX3ZhbGlkX21heF9tZXRhZGF0YV9zaXplKAogICAgLy8gICAgIG1ldGFkYXRhX3NpemUKICAgIC8vICksIGVyci5FWENFRURTX01BWF9NRVRBREFUQV9TSVpFCiAgICBhc3NlcnQgLy8gSW52YWxpZCBNZXRhZGF0YSBzaXplLCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzaXplCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zKGFzYTogdWludDY0LCBtZXRhZGF0YV9zaXplOiB1aW50NjQpIC0+IHZvaWQ6Cl9jaGVja191cGRhdGVfcHJlY29uZGl0aW9uczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzMwCiAgICAvLyBkZWYgX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zKHNlbGYsIGFzYTogQXNzZXQsIG1ldGFkYXRhX3NpemU6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMzEKICAgIC8vIHNlbGYuX2NoZWNrX2Jhc2VfcHJlY29uZGl0aW9ucyhhc2EsIG1ldGFkYXRhX3NpemUpCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ2CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzMyCiAgICAvLyBhc3NlcnQgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzYSksIGVyci5BU1NFVF9NRVRBREFUQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYtOTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDkKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3LTExMAogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfaXJyZXZlcnNpYmxlX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzMzCiAgICAvLyBhc3NlcnQgbm90IHNlbGYuX2lzX2ltbXV0YWJsZShhc2EpLCBlcnIuSU1NVVRBQkxFCiAgICAhCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgaW1tdXRhYmxlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzYTogdWludDY0KSAtPiB2b2lkOgpfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMzNQogICAgLy8gZGVmIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhzZWxmLCBhc2E6IEFzc2V0KSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MTUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMzYKICAgIC8vIGFzc2VydCBzZWxmLl9hc2FfZXhpc3RzKGFzYSksIGVyci5BU0FfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gVGhlIHNwZWNpZmllZCBBU0EgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDYKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzM3CiAgICAvLyBhc3NlcnQgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzYSksIGVyci5BU1NFVF9NRVRBREFUQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhhc2E6IHVpbnQ2NCkgLT4gdm9pZDoKX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMzOQogICAgLy8gZGVmIF9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zKHNlbGYsIGFzYTogQXNzZXQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzQwCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM0MQogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FzYV9tYW5hZ2VyKGFzYSksIGVyci5VTkFVVEhPUklaRUQKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfaXNfYXNhX21hbmFnZXIKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQsIG11c3QgYmUgdGhlIEFzc2V0IE1hbmFnZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYtOTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDkKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3LTExMAogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfaXJyZXZlcnNpYmxlX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzQyCiAgICAvLyBhc3NlcnQgbm90IHNlbGYuX2lzX2ltbXV0YWJsZShhc2EpLCBlcnIuSU1NVVRBQkxFCiAgICAhCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgaW1tdXRhYmxlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2VtaXRfdXBkYXRlZF9ldmVudChhc2E6IHVpbnQ2NCwgbWV0YWRhdGFfaGFzaDogYnl0ZXMpIC0+IHZvaWQ6Cl9lbWl0X3VwZGF0ZWRfZXZlbnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM0NAogICAgLy8gZGVmIF9lbWl0X3VwZGF0ZWRfZXZlbnQoc2VsZiwgYXNhOiBBc3NldCwgbWV0YWRhdGFfaGFzaDogQnl0ZXMpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzQ3CiAgICAvLyBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc2EuaWQpLAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM0OAogICAgLy8gcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIGdsb2JhbCBSb3VuZAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDkKICAgIC8vIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyLTc0CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzItNzQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM1MAogICAgLy8gcmV2ZXJzaWJsZV9mbGFncz1hcmM0LkJ5dGUob3AuYnRvaShzZWxmLl9nZXRfcmV2ZXJzaWJsZV9mbGFncyhhc2EpKSksCiAgICBidG9pCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2LTk5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYtOTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNTIKICAgIC8vIG9wLmJ0b2koc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpKQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNTEtMzUzCiAgICAvLyBpcnJldmVyc2libGVfZmxhZ3M9YXJjNC5CeXRlKAogICAgLy8gICAgIG9wLmJ0b2koc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpKQogICAgLy8gKSwKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTUtNTgKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgZGlnIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1LTU4CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY4CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Ni02OQogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzU0CiAgICAvLyBpc19zaG9ydD1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNhKSksCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDYtMzU2CiAgICAvLyBhYmkuQXJjODlNZXRhZGF0YVVwZGF0ZWQoCiAgICAvLyAgICAgYXNzZXRfaWQ9YXJjNC5VSW50NjQoYXNhLmlkKSwKICAgIC8vICAgICByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICAvLyAgICAgcmV2ZXJzaWJsZV9mbGFncz1hcmM0LkJ5dGUob3AuYnRvaShzZWxmLl9nZXRfcmV2ZXJzaWJsZV9mbGFncyhhc2EpKSksCiAgICAvLyAgICAgaXJyZXZlcnNpYmxlX2ZsYWdzPWFyYzQuQnl0ZSgKICAgIC8vICAgICAgICAgb3AuYnRvaShzZWxmLl9nZXRfaXJyZXZlcnNpYmxlX2ZsYWdzKGFzYSkpCiAgICAvLyAgICAgKSwKICAgIC8vICAgICBpc19zaG9ydD1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNhKSksCiAgICAvLyAgICAgaGFzaD1hYmkuSGFzaC5mcm9tX2J5dGVzKG1ldGFkYXRhX2hhc2gpLAogICAgLy8gKQogICAgdW5jb3ZlciA1CiAgICB1bmNvdmVyIDUKICAgIGNvbmNhdAogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDUtMzU3CiAgICAvLyBhcmM0LmVtaXQoCiAgICAvLyAgICAgYWJpLkFyYzg5TWV0YWRhdGFVcGRhdGVkKAogICAgLy8gICAgICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc2EuaWQpLAogICAgLy8gICAgICAgICByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgICAgICB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgICAgICByZXZlcnNpYmxlX2ZsYWdzPWFyYzQuQnl0ZShvcC5idG9pKHNlbGYuX2dldF9yZXZlcnNpYmxlX2ZsYWdzKGFzYSkpKSwKICAgIC8vICAgICAgICAgaXJyZXZlcnNpYmxlX2ZsYWdzPWFyYzQuQnl0ZSgKICAgIC8vICAgICAgICAgICAgIG9wLmJ0b2koc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpKQogICAgLy8gICAgICAgICApLAogICAgLy8gICAgICAgICBpc19zaG9ydD1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNhKSksCiAgICAvLyAgICAgICAgIGhhc2g9YWJpLkhhc2guZnJvbV9ieXRlcyhtZXRhZGF0YV9oYXNoKSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBwdXNoYnl0ZXMgMHg4YjAzNTA4NCAvLyBtZXRob2QgIkFyYzg5TWV0YWRhdGFVcGRhdGVkKHVpbnQ2NCx1aW50NjQsdWludDY0LGJ5dGUsYnl0ZSxib29sLGJ5dGVbMzJdKSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KGFzYTogdWludDY0KSAtPiB2b2lkOgpfdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM1OQogICAgLy8gZGVmIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChzZWxmLCBhc2E6IEFzc2V0KSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2MC0zNjEKICAgIC8vICMg4pqg77iPIFRoZSBzdWJyb3V0aW5lIGFzc3VtZXMgdGhhdCBNZXRhZGF0YSBGbGFncyBoYXZlIGFscmVhZHkgYmVlbiBzZXQKICAgIC8vIHNlbGYuX2lkZW50aWZ5X21ldGFkYXRhKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfaWRlbnRpZnlfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzYyCiAgICAvLyBtZXRhZGF0YV9oYXNoID0gc2VsZi5fY29tcHV0ZV9tZXRhZGF0YV9oYXNoKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfY29tcHV0ZV9tZXRhZGF0YV9oYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNi0xMjgKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgdmFsdWU9bWV0YWRhdGFfaGFzaAogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIHB1c2hpbnQgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjYtMTI4CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIC8vICkKICAgIGRpZyAzCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNjQKICAgIC8vIHNlbGYuX3NldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzYSwgR2xvYmFsLnJvdW5kKQogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0MQogICAgLy8gdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQwCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIHB1c2hpbnQgMzUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTM5LTE0MgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgIHZhbHVlPW9wLml0b2IobGFzdF9tb2RpZmllZF9yb3VuZCksCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNjUKICAgIC8vIHNlbGYuX2VtaXRfdXBkYXRlZF9ldmVudChhc2EsIG1ldGFkYXRhX2hhc2gpCiAgICBmcmFtZV9kaWcgLTEKICAgIHN3YXAKICAgIGNhbGxzdWIgX2VtaXRfdXBkYXRlZF9ldmVudAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV92YWxpZGF0aW9uLkFzYVZhbGlkYXRpb24uX2lzX2FzYV9tYW5hZ2VyKGFzYTogdWludDY0KSAtPiB1aW50NjQ6Cl9pc19hc2FfbWFuYWdlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weToxOAogICAgLy8gZGVmIF9pc19hc2FfbWFuYWdlcihzZWxmLCBhc2E6IEFzc2V0KSAtPiBib29sOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MTkKICAgIC8vIHJldHVybiBUeG4uc2VuZGVyID09IGFzYS5tYW5hZ2VyCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICA9PQogICAgcmV0c3ViCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEyCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMQogICAgcmV0dXJuCg=="}, "sourceInfo": {"approval": {"pcOffsetMethod": "cblocks", "sourceInfo": [{"pc": [643], "errorMessage": "Asset Metadata already exists for the specified ASA"}, {"pc": [1467, 1613, 3297, 3322], "errorMessage": "Asset Metadata does not exist for the specified ASA"}, {"pc": [839], "errorMessage": "Invalid ARC-3 parameters (name or URL)"}, {"pc": [885], "errorMessage": "Invalid ARC-89 partial URI"}, {"pc": [908, 1267], "errorMessage": "Invalid MBR Delta amount"}, {"pc": [650, 1220], "errorMessage": "Invalid MBR Delta receiver, must be the ASA Metadata Registry"}, {"pc": [1840, 3278], "errorMessage": "Invalid Metadata size, exceeds maximum allowed size"}, {"pc": [1212], "errorMessage": "Invalid Metadata size, must be larger than the current size"}, {"pc": [1065], "errorMessage": "Invalid Metadata size, must be smaller than or equal to the current size"}, {"pc": [2661], "errorMessage": "Invalid base64 encoding, must be 0 (URL safe) or 1 (Std)"}, {"pc": [1657, 1744], "errorMessage": "Invalid flag index"}, {"pc": [1401], "errorMessage": "Invalid new ASA Metadata Registry ID, must be different from current"}, {"pc": [2248, 2304, 2441], "errorMessage": "Invalid page index"}, {"pc": [2434], "errorMessage": "Metadata is empty"}, {"pc": [1482, 3304, 3347], "errorMessage": "Metadata is immutable"}, {"pc": [3007], "errorMessage": "Metadata is not short"}, {"pc": [1098, 1253, 2937], "errorMessage": "Metadata size mismatch, must be exactly equal to declared size"}, {"pc": [765], "errorMessage": "Must be flagged as immutable"}, {"pc": [1601], "errorMessage": "No payload head call in Group"}, {"pc": [2347, 2522, 2615, 2685], "errorMessage": "Payload exceeds page size"}, {"pc": [2805, 2896, 2911], "errorMessage": "Payload overflow, exceeds metadata size"}, {"pc": [1340, 2360], "errorMessage": "Slice exceeds metadata range"}, {"pc": [275], "errorMessage": "The deployer address is not trusted"}, {"pc": [1607, 3266, 3315], "errorMessage": "The specified ASA does not exist"}, {"pc": [1488, 1617, 3272, 3337], "errorMessage": "Unauthorized, must be the Asset Manager"}, {"pc": [658, 897, 1070, 1103, 1225, 1258, 1493, 1502, 2701, 2706], "errorMessage": "account funded"}, {"pc": [719, 773, 821, 827, 870, 1137, 1520, 2005, 3477], "errorMessage": "asset exists"}, {"pc": [2752, 2765], "errorMessage": "check Box exists"}, {"pc": [599, 1040, 1176, 1299, 1590, 2494, 2543, 2587, 2636], "errorMessage": "invalid array length header"}, {"pc": [1645], "errorMessage": "invalid number of bytes for arc4.bool"}, {"pc": [606, 1047, 1183, 1306, 1596, 2501, 2550, 2594, 2643], "errorMessage": "invalid number of bytes for arc4.dynamic_array<arc4.uint8>"}, {"pc": [593, 1034, 1170, 1293, 1832, 2328, 2336], "errorMessage": "invalid number of bytes for arc4.uint16"}, {"pc": [563, 1024, 1161, 1283, 1380, 1390, 1456, 1583, 1627, 1714, 1784, 1822, 1946, 1986, 2035, 2074, 2147, 2208, 2319, 2385, 2407, 2462, 2487, 2536, 2580, 2629], "errorMessage": "invalid number of bytes for arc4.uint64"}, {"pc": [575, 585, 1637, 1724, 2220, 2416, 2651], "errorMessage": "invalid number of bytes for arc4.uint8"}, {"pc": [1115, 1882, 2163, 2182, 3372, 3387], "errorMessage": "overflow"}, {"pc": [619, 1193], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {"TRUSTED_DEPLOYER": {"type": "address"}, "ARC90_NETAUTH": {"type": "AVMBytes"}}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class MbrDelta:
    """Struct for MbrDelta"""
    sign: int
    amount: int

@dataclasses.dataclass(frozen=True)
class MetadataExistence:
    """Struct for MetadataExistence"""
    asa_exists: bool
    metadata_exists: bool

@dataclasses.dataclass(frozen=True)
class MetadataHeader:
    """Struct for MetadataHeader"""
    identifiers: int
    reversible_flags: int
    irreversible_flags: int
    hash: bytes
    last_modified_round: int
    deprecated_by: int

@dataclasses.dataclass(frozen=True)
class MutableFlag:
    """Struct for MutableFlag"""
    flag: bool
    last_modified_round: int

@dataclasses.dataclass(frozen=True)
class PaginatedMetadata:
    """Struct for PaginatedMetadata"""
    has_next_page: bool
    last_modified_round: int
    page_content: bytes

@dataclasses.dataclass(frozen=True)
class Pagination:
    """Struct for Pagination"""
    metadata_size: int
    page_size: int
    total_pages: int

@dataclasses.dataclass(frozen=True)
class RegistryParameters:
    """Struct for RegistryParameters"""
    header_size: int
    max_metadata_size: int
    short_metadata_size: int
    page_size: int
    first_payload_max_size: int
    extra_payload_max_size: int
    replace_payload_max_size: int
    flat_mbr: int
    byte_mbr: int


@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89CreateMetadataArgs:
    """Dataclass for arc89_create_metadata arguments"""
    asset_id: int
    reversible_flags: int
    irreversible_flags: int
    metadata_size: int
    payload: bytes | str
    mbr_delta_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataArgs:
    """Dataclass for arc89_replace_metadata arguments"""
    asset_id: int
    metadata_size: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataLargerArgs:
    """Dataclass for arc89_replace_metadata_larger arguments"""
    asset_id: int
    metadata_size: int
    payload: bytes | str
    mbr_delta_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataSliceArgs:
    """Dataclass for arc89_replace_metadata_slice arguments"""
    asset_id: int
    offset: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata_slice(uint64,uint16,byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89MigrateMetadataArgs:
    """Dataclass for arc89_migrate_metadata arguments"""
    asset_id: int
    new_registry_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_migrate_metadata(uint64,uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89DeleteMetadataArgs:
    """Dataclass for arc89_delete_metadata arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_delete_metadata(uint64)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ExtraPayloadArgs:
    """Dataclass for arc89_extra_payload arguments"""
    asset_id: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_extra_payload(uint64,byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetReversibleFlagArgs:
    """Dataclass for arc89_set_reversible_flag arguments"""
    asset_id: int
    flag: int
    value: bool

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_reversible_flag(uint64,uint8,bool)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetIrreversibleFlagArgs:
    """Dataclass for arc89_set_irreversible_flag arguments"""
    asset_id: int
    flag: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_irreversible_flag(uint64,uint8)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetImmutableArgs:
    """Dataclass for arc89_set_immutable arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_immutable(uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataMbrDeltaArgs:
    """Dataclass for arc89_get_metadata_mbr_delta arguments"""
    asset_id: int
    new_metadata_size: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89CheckMetadataExistsArgs:
    """Dataclass for arc89_check_metadata_exists arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_check_metadata_exists(uint64)(bool,bool)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89IsMetadataImmutableArgs:
    """Dataclass for arc89_is_metadata_immutable arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_is_metadata_immutable(uint64)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89IsMetadataShortArgs:
    """Dataclass for arc89_is_metadata_short arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_is_metadata_short(uint64)(bool,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHeaderArgs:
    """Dataclass for arc89_get_metadata_header arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataPaginationArgs:
    """Dataclass for arc89_get_metadata_pagination arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataArgs:
    """Dataclass for arc89_get_metadata arguments"""
    asset_id: int
    page: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataSliceArgs:
    """Dataclass for arc89_get_metadata_slice arguments"""
    asset_id: int
    offset: int
    size: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHeaderHashArgs:
    """Dataclass for arc89_get_metadata_header_hash arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_header_hash(uint64)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataPageHashArgs:
    """Dataclass for arc89_get_metadata_page_hash arguments"""
    asset_id: int
    page: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_page_hash(uint64,uint8)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHashArgs:
    """Dataclass for arc89_get_metadata_hash arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_hash(uint64)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataStringByKeyArgs:
    """Dataclass for arc89_get_metadata_string_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_string_by_key(uint64,string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataUint64ByKeyArgs:
    """Dataclass for arc89_get_metadata_uint64_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_uint64_by_key(uint64,string)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataObjectByKeyArgs:
    """Dataclass for arc89_get_metadata_object_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_object_by_key(uint64,string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataB64BytesByKeyArgs:
    """Dataclass for arc89_get_metadata_b64_bytes_by_key arguments"""
    asset_id: int
    key: str
    b64_encoding: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]"


class AsaMetadataRegistryParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }))

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_migrate_metadata(uint64,uint64)void",
            "args": method_args,
        }))

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }))

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }))

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }))

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }))

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }))

    def arc89_get_metadata_partial_uri(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_partial_uri()string",
        }))

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }))

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }))

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }))

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }))

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }))

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }))

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class AsaMetadataRegistryCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }))

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_migrate_metadata(uint64,uint64)void",
            "args": method_args,
        }))

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }))

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }))

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }))

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }))

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }))

    def arc89_get_metadata_partial_uri(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_partial_uri()string",
        }))

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }))

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }))

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }))

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }))

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }))

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }))

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class AsaMetadataRegistrySend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_migrate_metadata(uint64,uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[RegistryParameters]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(RegistryParameters, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[RegistryParameters], parsed_response)

    def arc89_get_metadata_partial_uri(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_partial_uri()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MetadataExistence]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MetadataExistence, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MetadataExistence], parsed_response)

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MutableFlag]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MutableFlag, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MutableFlag], parsed_response)

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MetadataHeader]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MetadataHeader, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MetadataHeader], parsed_response)

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[Pagination]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(Pagination, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[Pagination], parsed_response)

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[PaginatedMetadata]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(PaginatedMetadata, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[PaginatedMetadata], parsed_response)

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class AsaMetadataRegistryState:
    """Methods to access state for the current AsaMetadataRegistry app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def asset_metadata(self) -> "_MapState[int, bytes]":
        """Get values from the asset_metadata map in box state"""
        return _MapState(
            self.app_client.state.box,
            "asset_metadata",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class AsaMetadataRegistryClient:
    """Client for interacting with AsaMetadataRegistry smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = AsaMetadataRegistryParams(self.app_client)
        self.create_transaction = AsaMetadataRegistryCreateTransactionParams(self.app_client)
        self.send = AsaMetadataRegistrySend(self.app_client)
        self.state = AsaMetadataRegistryState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "AsaMetadataRegistryComposer":
        return AsaMetadataRegistryComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata_slice(uint64,uint16,byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_migrate_metadata(uint64,uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_delete_metadata(uint64)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_extra_payload(uint64,byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_reversible_flag(uint64,uint8,bool)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_irreversible_flag(uint64,uint8)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_immutable(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> RegistryParameters | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_partial_uri()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_check_metadata_exists(uint64)(bool,bool)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MetadataExistence | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_is_metadata_immutable(uint64)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_is_metadata_short(uint64)(bool,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MutableFlag | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MetadataHeader | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> Pagination | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])"],
        return_value: algokit_utils.ABIReturn | None
    ) -> PaginatedMetadata | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_slice(uint64,uint16,uint16)byte[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_header_hash(uint64)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_page_hash(uint64,uint8)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_hash(uint64)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_string_by_key(uint64,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_uint64_by_key(uint64,string)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_object_by_key(uint64,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["extra_resources()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["withdraw_balance_excess()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | MbrDelta | MetadataExistence | MetadataHeader | MutableFlag | None | PaginatedMetadata | Pagination | RegistryParameters | bool | bytes | int | str:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class AsaMetadataRegistryBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating AsaMetadataRegistry contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class AsaMetadataRegistryFactory(algokit_utils.TypedAppFactoryProtocol[AsaMetadataRegistryBareCallCreateParams, None, None]):
    """Factory for deploying and managing AsaMetadataRegistryClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = AsaMetadataRegistryFactoryParams(self.app_factory)
        self.create_transaction = AsaMetadataRegistryFactoryCreateTransaction(self.app_factory)
        self.send = AsaMetadataRegistryFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: AsaMetadataRegistryBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[AsaMetadataRegistryClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return AsaMetadataRegistryClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AsaMetadataRegistryClient:
        """Get an app client by creator address and name"""
        return AsaMetadataRegistryClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AsaMetadataRegistryClient:
        """Get an app client by app ID"""
        return AsaMetadataRegistryClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class AsaMetadataRegistryFactoryParams:
    """Parameters for creating transactions for AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactoryCreateParams(app_factory)
        self.update = AsaMetadataRegistryFactoryUpdateParams(app_factory)
        self.delete = AsaMetadataRegistryFactoryDeleteParams(app_factory)

class AsaMetadataRegistryFactoryCreateParams:
    """Parameters for 'create' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata_slice(uint64,uint16,byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_migrate_metadata(uint64,uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_migrate_metadata(uint64,uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_delete_metadata(uint64)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_extra_payload(uint64,byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_extra_payload(uint64,byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_reversible_flag(uint64,uint8,bool)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_irreversible_flag(uint64,uint8)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_irreversible_flag(uint64,uint8)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_immutable(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_immutable(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_registry_parameters(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_partial_uri(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_partial_uri()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_partial_uri()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_check_metadata_exists(uint64)(bool,bool) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_is_metadata_immutable(uint64)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_is_metadata_immutable(uint64)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_is_metadata_short(uint64)(bool,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata(uint64,uint8)(bool,uint64,byte[]) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_slice(uint64,uint16,uint16)byte[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_header_hash(uint64)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_page_hash(uint64,uint8)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_hash(uint64)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_hash(uint64)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_string_by_key(uint64,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_string_by_key(uint64,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_uint64_by_key(uint64,string)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_object_by_key(uint64,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_object_by_key(uint64,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def extra_resources(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the extra_resources()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "extra_resources()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def withdraw_balance_excess(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the withdraw_balance_excess()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "withdraw_balance_excess()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class AsaMetadataRegistryFactoryUpdateParams:
    """Parameters for 'update' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class AsaMetadataRegistryFactoryDeleteParams:
    """Parameters for 'delete' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class AsaMetadataRegistryFactoryCreateTransaction:
    """Create transactions for AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactoryCreateTransactionCreate(app_factory)


class AsaMetadataRegistryFactoryCreateTransactionCreate:
    """Create new instances of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class AsaMetadataRegistryFactorySend:
    """Send calls to AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactorySendCreate(app_factory)


class AsaMetadataRegistryFactorySendCreate:
    """Send create calls to AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[AsaMetadataRegistryClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return AsaMetadataRegistryClient(result[0]), result[1]


class AsaMetadataRegistryComposer:
    """Composer for creating transaction groups for AsaMetadataRegistry contract calls"""

    def __init__(self, client: "AsaMetadataRegistryClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_create_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata_larger(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata_slice(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata_slice(uint64,uint16,byte[])void", v
            )
        )
        return self

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_migrate_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_migrate_metadata(uint64,uint64)void", v
            )
        )
        return self

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_delete_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_delete_metadata(uint64)(uint8,uint64)", v
            )
        )
        return self

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_extra_payload(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_extra_payload(uint64,byte[])void", v
            )
        )
        return self

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_reversible_flag(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_reversible_flag(uint64,uint8,bool)void", v
            )
        )
        return self

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_irreversible_flag(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_irreversible_flag(uint64,uint8)void", v
            )
        )
        return self

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_immutable(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_immutable(uint64)void", v
            )
        )
        return self

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_registry_parameters(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_partial_uri(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_partial_uri(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_partial_uri()string", v
            )
        )
        return self

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_mbr_delta(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)", v
            )
        )
        return self

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_check_metadata_exists(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_check_metadata_exists(uint64)(bool,bool)", v
            )
        )
        return self

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_is_metadata_immutable(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_is_metadata_immutable(uint64)bool", v
            )
        )
        return self

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_is_metadata_short(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_is_metadata_short(uint64)(bool,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_header(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_pagination(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)", v
            )
        )
        return self

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])", v
            )
        )
        return self

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_slice(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]", v
            )
        )
        return self

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_header_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_header_hash(uint64)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_page_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_page_hash(uint64,uint8)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_hash(uint64)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_string_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_string_by_key(uint64,string)string", v
            )
        )
        return self

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_uint64_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_uint64_by_key(uint64,string)uint64", v
            )
        )
        return self

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_object_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_object_by_key(uint64,string)string", v
            )
        )
        return self

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_b64_bytes_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]", v
            )
        )
        return self

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.extra_resources(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "extra_resources()void", v
            )
        )
        return self

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.withdraw_balance_excess(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "withdraw_balance_excess()void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "AsaMetadataRegistryComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
