# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to create the Asset Metadata for", "name": "asset_id"}, {"type": "byte", "desc": "The Metadata Flags. WARNING: if the MSB is True the Asset Metadata is IMMUTABLE", "name": "flags"}, {"type": "uint16", "desc": "The Metadata byte size to be created", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}, {"type": "pay", "desc": "Payment of the MBR Delta amount (microALGO) for the Asset Metadata Box creation", "name": "mbr_delta_payment"}], "name": "arc89_create_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Create Asset Metadata for an existing ASA, restricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Metadata byte size, must be less than or equal to the existing", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}], "name": "arc89_replace_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Replace mutable Metadata with a smaller or equal size payload for an existing ASA,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Metadata byte size, must be larger than the existing", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}, {"type": "pay", "desc": "Payment of the MBR Delta amount (microALGO) for the larger Asset Metadata Box replace", "name": "mbr_delta_payment"}], "name": "arc89_replace_metadata_larger", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Replace mutable Metadata with a larger size payload for an existing ASA,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata slice for", "name": "asset_id"}, {"type": "uint16", "desc": "The 0-based byte offset within the Metadata (body) bytes", "name": "offset"}, {"type": "byte[]", "desc": "The slice payload", "name": "payload"}], "name": "arc89_replace_metadata_slice", "returns": {"type": "void"}, "desc": "Replace a slice of the Asset Metadata for an ASA with a payload of the same size,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to delete the Asset Metadata for", "name": "asset_id"}], "name": "arc89_delete_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Delete Asset Metadata for an ASA, restricted to the ASA Manager Address (if the ASA still exists).", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataDeleted", "desc": "Event emitted when Asset Metadata is deleted"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to provide Metadata extra payload for", "name": "asset_id"}, {"type": "byte[]", "desc": "The Metadata extra payload to concatenate", "name": "payload"}], "name": "arc89_extra_payload", "returns": {"type": "void"}, "desc": "Concatenate extra payload to Asset Metadata head call methods (creation or replacement).", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set the Metadata Flag for", "name": "asset_id"}, {"type": "uint8", "desc": "The reversible flag index to set. WARNING: must be 0 ... 3", "name": "flag"}, {"type": "bool", "desc": "The flag value to set", "name": "value"}], "name": "arc89_set_reversible_flag", "returns": {"type": "void"}, "desc": "Set a reversible Asset Metadata Flag, restricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set the Metadata Flag for", "name": "asset_id"}, {"type": "uint8", "desc": "The irreversible flag index to set. WARNING: must be 6, 7", "name": "flag"}], "name": "arc89_set_irreversible_flag", "returns": {"type": "void"}, "desc": "Set an irreversible Asset Metadata Flag, restricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set immutable Asset Metadata for", "name": "asset_id"}], "name": "arc89_set_immutable", "returns": {"type": "void"}, "desc": "Set Asset Metadata as immutable, restricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "arc89_get_metadata_registry_parameters", "returns": {"type": "(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", "desc": "Tuple of (HEADER_SIZE, MAX_METADATA_SIZE, SHORT_METADATA_SIZE, PAGE_SIZE, FIRST_PAYLOAD_MAX_SIZE, EXTRA_PAYLOAD_MAX_SIZE, REPLACE_PAYLOAD_MAX_SIZE, FLAT_MBR, BYTE_MBR)", "struct": "RegistryParameters"}, "desc": "Return the ASA Metadata Registry parameters.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to calculate the Asset Metadata MBR Delta for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Asset Metadata byte size", "name": "new_metadata_size"}], "name": "arc89_get_metadata_mbr_delta", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Return the Asset Metadata Box MBR Delta for an ASA, given a new Asset Metadata byte size.\nIf the Asset Metadata Box does not exist, the creation MBR Delta is returned.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the ASA and Asset Metadata existence for", "name": "asset_id"}], "name": "arc89_check_metadata_exists", "returns": {"type": "(bool,bool)", "desc": "Tuple of (ASA exists, Asset Metadata exists)", "struct": "MetadataExistence"}, "desc": "Checks whether the specified ASA exists and whether its associated Asset Metadata is available.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the Asset Metadata immutability for", "name": "asset_id"}], "name": "arc89_is_metadata_immutable", "returns": {"type": "bool", "desc": "Asset Metadata for the ASA is immutable"}, "desc": "Return True if the Asset Metadata for an ASA is immutable, False otherwise.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the Asset Metadata size classification for", "name": "asset_id"}], "name": "arc89_is_metadata_short", "returns": {"type": "(bool,uint64)", "desc": "Tuple of (is short metadata, Metadata Last Modified Round)", "struct": "MutableFlag"}, "desc": "Return True if Asset Metadata for an ASA is short (up to 4096 bytes), False otherwise.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata Header for", "name": "asset_id"}], "name": "arc89_get_metadata_header", "returns": {"type": "(byte,byte,byte[32],uint64)", "desc": "Asset Metadata Header: (Identifiers, Flags, Hash, Last Modified Round)", "struct": "MetadataHeader"}, "desc": "Return the Asset Metadata Header for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata pagination for", "name": "asset_id"}], "name": "arc89_get_metadata_pagination", "returns": {"type": "(uint16,uint16,uint8)", "desc": "Tuple of (total metadata byte size, PAGE_SIZE, total number of pages)", "struct": "Pagination"}, "desc": "Return the Asset Metadata pagination for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata for", "name": "asset_id"}, {"type": "uint8", "desc": "The 0-based Metadata page number", "name": "page"}], "name": "arc89_get_metadata", "returns": {"type": "(bool,uint64,byte[])", "desc": "Tuple of (has next page, Metadata Last Modified Round, page content)", "struct": "PaginatedMetadata"}, "desc": "Return paginated Asset Metadata (without Header) for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata slice for", "name": "asset_id"}, {"type": "uint16", "desc": "The 0-based byte offset within the Metadata (body) bytes", "name": "offset"}, {"type": "uint16", "desc": "The slice bytes size to return", "name": "size"}], "name": "arc89_get_metadata_slice", "returns": {"type": "byte[]", "desc": "Asset Metadata slice (size limited to PAGE_SIZE)"}, "desc": "Return a slice of the Asset Metadata for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Metadata Header Hash for", "name": "asset_id"}], "name": "arc89_get_metadata_header_hash", "returns": {"type": "byte[32]", "desc": "Asset Metadata Header Hash"}, "desc": "Return the Metadata Header Hash for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata page hash for", "name": "asset_id"}, {"type": "uint8", "desc": "The 0-based Metadata page number", "name": "page"}], "name": "arc89_get_metadata_page_hash", "returns": {"type": "byte[32]", "desc": "The SHA512-256 of the Metadata page"}, "desc": "Return the SHA512-256 of a Metadata page for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Metadata Hash for", "name": "asset_id"}], "name": "arc89_get_metadata_hash", "returns": {"type": "byte[32]", "desc": "Asset Metadata Hash"}, "desc": "Return the Metadata Hash for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose string value to fetch", "name": "key"}], "name": "arc89_get_metadata_string_by_key", "returns": {"type": "string", "desc": "The string value from valid UTF 8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the UTF 8 string value for a top level JSON key from short Metadata for an ASA;\nerrors if the key is not a string or does not exist", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose uint64 value to fetch", "name": "key"}], "name": "arc89_get_metadata_uint64_by_key", "returns": {"type": "uint64", "desc": "The uint64 value from valid UTF 8 JSON Metadata"}, "desc": "Return the uint64 value for a top level JSON key from short Metadata for an ASA;\nerrors if the key is not an uint64 or does not exist", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose object value to fetch", "name": "key"}], "name": "arc89_get_metadata_object_by_key", "returns": {"type": "string", "desc": "The object value from valid UTF 8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the UTF 8 object value for a top level JSON key from short Metadata for an ASA;\nerrors if the key is not an object or does not exist", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "extra_resources", "returns": {"type": "void"}, "desc": "Placeholder method to acquire AVM extra resources.", "events": [], "readonly": false, "recommendations": {}}], "name": "AsaMetadataRegistry", "state": {"keys": {"box": {}, "global": {}, "local": {}}, "maps": {"box": {"asset_metadata": {"keyType": "uint64", "valueType": "AVMBytes", "prefix": ""}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 0}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"MbrDelta": [{"name": "sign", "type": "uint8"}, {"name": "amount", "type": "uint64"}], "MetadataExistence": [{"name": "asa_exists", "type": "bool"}, {"name": "metadata_exists", "type": "bool"}], "MetadataHeader": [{"name": "identifiers", "type": "byte"}, {"name": "flags", "type": "byte"}, {"name": "hash", "type": "byte[32]"}, {"name": "last_modified_round", "type": "uint64"}], "MutableFlag": [{"name": "flag", "type": "bool"}, {"name": "last_modified_round", "type": "uint64"}], "PaginatedMetadata": [{"name": "has_next_page", "type": "bool"}, {"name": "last_modified_round", "type": "uint64"}, {"name": "page_content", "type": "byte[]"}], "Pagination": [{"name": "metadata_size", "type": "uint16"}, {"name": "page_size", "type": "uint16"}, {"name": "total_pages", "type": "uint8"}], "RegistryParameters": [{"name": "header_size", "type": "uint16"}, {"name": "max_metadata_size", "type": "uint16"}, {"name": "short_metadata_size", "type": "uint16"}, {"name": "page_size", "type": "uint16"}, {"name": "first_payload_max_size", "type": "uint16"}, {"name": "extra_payload_max_size", "type": "uint16"}, {"name": "replace_payload_max_size", "type": "uint16"}, {"name": "flat_mbr", "type": "uint64"}, {"name": "byte_mbr", "type": "uint64"}]}, "byteCode": {"approval": "CyAHAQAIAu8H7ger7gEmCAQVH3x1AAEABDesdV0DBoEBBPV3wB8FFR98dQEAMRtBAOUxGRREMRhEggUEK+quVgS4LqfvBBJF+vsEBF8ubgQVsnWyK4ITBLUSHYoESfuukQQLU4zjBJqpryUEjl4QJAQkTEfEBC1Z9uAE7oW0cwQ88vNeBI8l73IEEcOEdgSwq/ZbBM6dvtcEylL7HgQiY5G5BHoT1TIEU8IiAwTTdyrTBABW2cE2GgCOGQA6Af8CiAMCA2MD5AQLBGIEuAADBNYFVAV8Ba0F1AYJBkUGtQb3Bw0HTAdkB5UHwQABACJDgCIVH3x1ACp3KxAAA+8H7wfyB/AAAAAAAAAJxAAAAAAAAAGQsCJDMRkUMRgUEEQxACcHEkQiQyMpNhoBRwIVJBJEF0k2GgJJTgIVIhJENhoDSRUlEkQ2GgRJI1klCEsBFRJEMRYiCUlOBEk4ECISRE8CF0lOBEsDTIgJUE8CFklOA0m9RQEUREw4BzIKEkQyCnMBTE4DRCO5SFcCAEkVQQAhgcYFMgwNQQAYsYEGshCBBbIZJwSyHicEsh8jsgGzQv/fSwZJSwVLA4gHUUmICCFLBhcWVwcBSwQiTwK7cQZEgCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNBAO1LAiJJuiNTREsGcQZESwNJJUsDuzIGFjIHFksCIyK6I1MqI08CVEsMTwNQTwJQSwlQTFBPAlAnBUxQsDIGFksBgSJPArsiSbolU0EAiDIIRQkpRQpLCEEAQEsISYEKGEmBCg9LAYEKTwJNTCIISYEKD4EKTE1JSwIMSwJMTYAKMDEyMzQ1Njc4OU4CUksLUEULgQoKRQlC/7tLCUkVgAEwTgJNgA9hbGdvcmFuZDovL2FwcC9MUIAFP2JveD1QSwdxBURJFUsCFUlLAg9MTgJNI0xSEkQyCnMBREsCCUsFOAhLAQ9EFicGTFCwIkNLBogHeEL/GDYaAUkVJBJEF0k2GgJJFSUSRDYaA0kjWSUISwEVEkRMF0sCSwGIB79LAogF0ksBD0QyCnMBRE8CVwIASwNLA08CiAXeSwKIB+NPAogFsU8CEkQyCnMBRAlJQAAUIxZJkyQORFcHAUsBFlAoTFCwIkOB/wGxSwJxB0RLArIIsgcishAjsgGzQv/UNhoBSRUkEkQXNhoCSRUlEkQ2GgNJI1klCEsBFRJEMRYiCUk4ECISRE8CF0sDSwGIByxLA4gFP0sBDERLATgHMgoSRDIKcwFETwNXAgBLBEsDTwKIBUNLA4gHSE8DiAUWTwISRDIKcwFETAlMOAhLAQ9EFicGTFCwIkM2GgFJFSQSRBdJNhoCSRUlEkQ2GgNJI1klCEsBFRJESwKIBNhLA0yIBrpMF0xXAgBJTgNJFUsCSwEISwSIBL0ORE8DFklOBIEqTwQISU4ETwK6E0EACUpLBLtLA4gGyiJDKTYaAUcCFSQSRBdHAhZJTgK9RQFEcQtFAUEADkkiSbojUxRESwGIBGZEMgpzAURLAbxIMgpzAUQJRQSxSwFxC0UBQQA3SwFxB0RLBEmyCEyyByKyECOyAbMyBhYyBxZLBU8CUExQgAS8PyDRTFCwFoAFFR98df9MULAiQzEAQv/JNhoBSRUkEkQXNhoCSSNZJQhMFRJESXELRQFESRa9RQFEiAPqRCJDNhoBSRUkEkQXSTYaAkkVIhJENhoDSRUiEkRLAogF6EwXSYEDDkRPAhZJTgMiSbqBB08CCUlOA1NMI1NJTwITQQATSwJJIkm6SwNLA1QiTLtLA4gFyyJDIyk2GgFJFSQSRBdJNhoCSRUiEkRMiAWYF0mBBg9BADJJgQcOQQArIkRLARZJRQUiSbqBB0sCCUlFBVNAABJLA0kiSbpLBCJUIky7SwGIBXkiQyNC/9I2GgFJFSQSRBdJiAVNSRZJIkm6IyJUIky7iAVXIkMpSTYaAUkVJBJEF0k2GgJJFSUSRBdJTgIhBg5EFr1FAUEATEsBiAMASUUEI0UFSwESQQAeI0mBkANPAgtLBQhMFkmTJA5EVwcBTBZQKExQsCJDSUsDDUEACiJLAUsECUxC/9OB/wFLA0sCCUxC/8eBxBNFBCKBMksCCExC/7g2GgFJFSQSRBdJcQtFASojTwJUTBa9RQEqI08CVCNTIkxUKExQsCJDNhoBSRUkEkQXRwKIBHYWIkm6I1NAAApJcQdEMgMSQQAMIiojTwJUKExQsCJDI0L/8TYaAUkVJBJEF0mIBEYWSSMiuiNTKiNPAlRMgSIkuhcWUChMULAiQzYaAUkVJBJEF0mIBB8WSSMiuksBIkm6SwIlgSC6TwOBIiS6FxZPA08DUE8CUExQKExQsCJDNhoBSRUkEkQXSYgD6kmIAeQWSZOBEA5EVwYCTIgB1iEFCCEEChZJkyQORFcHAUyAAgPvUExQKExQsCJDKTYaAUkVJBJEF0k2GgJJTgIVIhJESYgDoogBnSEFCCEECklOAkEAPhdJSwJJTgIMRCIJSwENRQRLAkyIAiMqI0sFVEsDFoEiJLoXFk8CSRUWVwYCTFBOAlCAAgALUExQKExQsCJDFxREI0UDKUL/zjYaAUkVJBJEFzYaAkkVJRJENhoDSRUlEkRLAogDLRdJIQQOREwXSUsCCEsDiAEaDkRPAhaBKk8CCE8CuihMULAiQzYaAUkVJBJEF0mIAvyIAgooTFCwIkM2GgFJFSQSRBc2GgJJFSISREsBiALdSwGIANYhBQghBApEF0sBiADJIQUIIQQKSwENREqIAWOIAgAoTFCwIkM2GgFJFSQSRBdJiAKnFiWBILooTFCwIkM2GgFJFSQSRBc2GgJJI1klCEsBFRJESwGIAoFMiAFbTFcCAF8ASRUhBA5EKExQsCJDNhoBSRUkEkQXNhoCSSNZJQhLARUSREsBiAJQTIgBKkxXAgBfARYoTFCwIkM2GgFJFSQSRBc2GgJJI1klCEsBFRJESwGIAiRMiAD+TFcCAF8CSRUhBA5EKExQsCJDigEBMQCL/3EHRBKJigEBi/8WvUSBKgmJigIAi/4WSb1Ei/8VSwEISwJM04v/u4mKAwCL/RZJgSrTi/2L/4j/2DIEMRYiCIsCiwEMQQBciwI4EIEGEkEATosCOBgyCBJBAESLAjgZQAA9iwIjwhorEkEAM4sCIsIaiwASQQAoIkEAG4sCJcIaVwIAi/2I/31LARUIi/4ORIv9TIj/e4sCIgiMAkL/oCNC/9WL/Yj/XYv+EkSJigIBi/6I/1BJi/8hBAtJTwIPQQAEKYwAiYsAiwFJTgIJIQRLAQwhBExNi/4WgSpPAwhPArqMAImKAQGL/xZJIyK6I1NEi/+I/w6BKky6iYoBAIv/iP8Bi/8WSSMiuk8CgYAgDiNMVCNMu4mKAQGL/xZJIyK6SwEiSbqL/4j+2RZXBgKADmFyYzAwODkvaGVhZGVyTwRQTwNQTwJQTFADiYoDAYv9Fov+FlcHAYv/FRZXBgKADGFyYzAwODkvcGFnZU8DUE8CUExQi/9QA4mKAQEpi/+I/5SL/4j+fCEFCCEECkkpTEEAKyOMAIsAiwIMQQAgi/+LAElOAoj/A4v/SwJPAoj/mosDTFCMAyIIjABC/9iACmFyYzAwODkvYW2LAVCLA1ADjACJigIAi/5xC0UBRIv+iP4URIv/IQYORImKAgCL/ov/iP/fi/4WSb1FAUQiSbojUxREiYoBAIv/cQtFAUSL/xa9RQFEiYoBAIv/iP/mi/8WIkm6I1MURIv/iP3JRImKAQCL/4j+wov/iP88i/8WSSVLA7syBhZLAYEiTwK7MgYWMgcWSwIiSboXFkmTJA5EVwcBSwMjIrojUyojTwJUTwRPBFBPA1BPAlBMUExQJwVMULCJ", "clear": "C4EBQw=="}, "desc": "\n    Singleton Application providing ASA metadata via Algod API and AVM\n    ", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}, {"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataDeleted", "desc": "Event emitted when Asset Metadata is deleted"}], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAxIDAgOCAyIDEwMDcgMTAwNiAzMDUwNwogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1IDB4IDB4MDAgMHgzN2FjNzU1ZCAweDA2ODEwMSAweGY1NzdjMDFmIDB4MTUxZjdjNzUwMSBUTVBMX1RSVVNURURfREVQTE9ZRVIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzYKICAgIC8vIGNsYXNzIEFzYU1ldGFkYXRhUmVnaXN0cnkoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZSk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9kZXBsb3lAMzQKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydAogICAgcHVzaGJ5dGVzcyAweDJiZWFhZTU2IDB4YjgyZWE3ZWYgMHgxMjQ1ZmFmYiAweDA0NWYyZTZlIDB4MTViMjc1YjIgLy8gbWV0aG9kICJhcmM4OV9jcmVhdGVfbWV0YWRhdGEodWludDY0LGJ5dGUsdWludDE2LGJ5dGVbXSxwYXkpKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X3JlcGxhY2VfbWV0YWRhdGEodWludDY0LHVpbnQxNixieXRlW10pKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfbGFyZ2VyKHVpbnQ2NCx1aW50MTYsYnl0ZVtdLHBheSkodWludDgsdWludDY0KSIsIG1ldGhvZCAiYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZSh1aW50NjQsdWludDE2LGJ5dGVbXSl2b2lkIiwgbWV0aG9kICJhcmM4OV9kZWxldGVfbWV0YWRhdGEodWludDY0KSh1aW50OCx1aW50NjQpIgogICAgYnl0ZWNfMyAvLyBtZXRob2QgImFyYzg5X2V4dHJhX3BheWxvYWQodWludDY0LGJ5dGVbXSl2b2lkIgogICAgcHVzaGJ5dGVzcyAweGI1MTIxZDhhIDB4NDlmYmFlOTEgMHgwYjUzOGNlMyAweDlhYTlhZjI1IDB4OGU1ZTEwMjQgMHgyNDRjNDdjNCAweDJkNTlmNmUwIDB4ZWU4NWI0NzMgMHgzY2YyZjM1ZSAweDhmMjVlZjcyIDB4MTFjMzg0NzYgMHhiMGFiZjY1YiAweGNlOWRiZWQ3IDB4Y2E1MmZiMWUgMHgyMjYzOTFiOSAweDdhMTNkNTMyIDB4NTNjMjIyMDMgMHhkMzc3MmFkMyAweDAwNTZkOWMxIC8vIG1ldGhvZCAiYXJjODlfc2V0X3JldmVyc2libGVfZmxhZyh1aW50NjQsdWludDgsYm9vbCl2b2lkIiwgbWV0aG9kICJhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWcodWludDY0LHVpbnQ4KXZvaWQiLCBtZXRob2QgImFyYzg5X3NldF9pbW11dGFibGUodWludDY0KXZvaWQiLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9yZWdpc3RyeV9wYXJhbWV0ZXJzKCkodWludDE2LHVpbnQxNix1aW50MTYsdWludDE2LHVpbnQxNix1aW50MTYsdWludDE2LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhKHVpbnQ2NCx1aW50MTYpKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2NoZWNrX21ldGFkYXRhX2V4aXN0cyh1aW50NjQpKGJvb2wsYm9vbCkiLCBtZXRob2QgImFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZSh1aW50NjQpYm9vbCIsIG1ldGhvZCAiYXJjODlfaXNfbWV0YWRhdGFfc2hvcnQodWludDY0KShib29sLHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXIodWludDY0KShieXRlLGJ5dGUsYnl0ZVszMl0sdWludDY0KSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2luYXRpb24odWludDY0KSh1aW50MTYsdWludDE2LHVpbnQ4KSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhKHVpbnQ2NCx1aW50OCkoYm9vbCx1aW50NjQsYnl0ZVtdKSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3NsaWNlKHVpbnQ2NCx1aW50MTYsdWludDE2KWJ5dGVbXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlcl9oYXNoKHVpbnQ2NClieXRlWzMyXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaCh1aW50NjQsdWludDgpYnl0ZVszMl0iLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9oYXNoKHVpbnQ2NClieXRlWzMyXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3N0cmluZ19ieV9rZXkodWludDY0LHN0cmluZylzdHJpbmciLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5KHVpbnQ2NCxzdHJpbmcpdWludDY0IiwgbWV0aG9kICJhcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleSh1aW50NjQsc3RyaW5nKXN0cmluZyIsIG1ldGhvZCAiZXh0cmFfcmVzb3VyY2VzKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggYXJjODlfY3JlYXRlX21ldGFkYXRhIGFyYzg5X3JlcGxhY2VfbWV0YWRhdGEgYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9sYXJnZXIgYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZSBhcmM4OV9kZWxldGVfbWV0YWRhdGEgYXJjODlfZXh0cmFfcGF5bG9hZCBhcmM4OV9zZXRfcmV2ZXJzaWJsZV9mbGFnIGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZyBhcmM4OV9zZXRfaW1tdXRhYmxlIG1haW5fYXJjODlfZ2V0X21ldGFkYXRhX3JlZ2lzdHJ5X3BhcmFtZXRlcnNfcm91dGVAMTUgYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YSBhcmM4OV9jaGVja19tZXRhZGF0YV9leGlzdHMgYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlIGFyYzg5X2lzX21ldGFkYXRhX3Nob3J0IGFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXIgYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2luYXRpb24gYXJjODlfZ2V0X21ldGFkYXRhIGFyYzg5X2dldF9tZXRhZGF0YV9zbGljZSBhcmM4OV9nZXRfbWV0YWRhdGFfaGVhZGVyX2hhc2ggYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaCBhcmM4OV9nZXRfbWV0YWRhdGFfaGFzaCBhcmM4OV9nZXRfbWV0YWRhdGFfc3RyaW5nX2J5X2tleSBhcmM4OV9nZXRfbWV0YWRhdGFfdWludDY0X2J5X2tleSBhcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleSBtYWluX2V4dHJhX3Jlc291cmNlc19yb3V0ZUAzMAogICAgZXJyCgptYWluX2V4dHJhX3Jlc291cmNlc19yb3V0ZUAzMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2FyYzg5X2dldF9tZXRhZGF0YV9yZWdpc3RyeV9wYXJhbWV0ZXJzX3JvdXRlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2ODQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzUwMDJhNzcyYjEwMDAwM2VmMDdlZjA3ZjIwN2YwMDAwMDAwMDAwMDAwMDljNDAwMDAwMDAwMDAwMDAxOTAKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl9kZXBsb3lAMzQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMwNwogICAgLy8gQGFyYzQuYmFyZW1ldGhvZChjcmVhdGU9InJlcXVpcmUiKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgICYmCiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzEyLTMxMwogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBUZW1wbGF0ZVZhcltBY2NvdW50XSgKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzEyLTMxNQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBUZW1wbGF0ZVZhcltBY2NvdW50XSgKICAgIC8vICAgICBUUlVTVEVEX0RFUExPWUVSCiAgICAvLyApLCBlcnIuVU5UUlVTVEVEX0RFUExPWUVSCiAgICBieXRlYyA3IC8vIFRNUExfVFJVU1RFRF9ERVBMT1lFUgogICAgPT0KICAgIGFzc2VydCAvLyBUaGUgZGVwbG95ZXIgYWRkcmVzcyBpcyBub3QgdHJ1c3RlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMDcKICAgIC8vIEBhcmM0LmJhcmVtZXRob2QoY3JlYXRlPSJyZXF1aXJlIikKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfY3JlYXRlX21ldGFkYXRhW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfY3JlYXRlX21ldGFkYXRhOgogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzEgLy8gIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzE3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cG4gMgogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18wIC8vIDEKICAgIC0KICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18wIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDEtMzQyCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2Jhc2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSkKICAgIHVuY292ZXIgMgogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkaWcgMwogICAgc3dhcAogICAgY2FsbHN1YiBfY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ5CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDMKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzc2V0X2lkKSwgZXJyLkFTU0VUX01FVEFEQVRBX0VYSVNUCiAgICAhCiAgICBhc3NlcnQgLy8gQXNzZXQgTWV0YWRhdGEgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgQVNBCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM0NQogICAgLy8gbWJyX2RlbHRhX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgc3dhcAogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDQtMzQ2CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG1icl9kZWx0YV9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksIGVyci5NQlJfREVMVEFfUkVDRUlWRVJfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIHJlY2VpdmVyLCBtdXN0IGJlIHRoZSBBU0EgTWV0YWRhdGEgUmVnaXN0cnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzQ4LTM0OQogICAgLy8gIyBJbml0aWFsaXplIGVtcHR5IEFzc2V0IE1ldGFkYXRhIEJveAogICAgLy8gbWJyX2kgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBzd2FwCiAgICBjb3ZlciAzCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzUwCiAgICAvLyBfZXhpc3RzID0gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNzZXRfaWQpLmNyZWF0ZShzaXplPVVJbnQ2NCgwKSkKICAgIGludGNfMSAvLyAwCiAgICBib3hfY3JlYXRlCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzUyLTM1MwogICAgLy8gIyBTZXQgTWV0YWRhdGEgQm9keQogICAgLy8gaWYgcGF5bG9hZC5uYXRpdmUubGVuZ3RoID4gMDoKICAgIGV4dHJhY3QgMiAwCiAgICBkdXAKICAgIGxlbgogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMwoKYXJjODlfY3JlYXRlX21ldGFkYXRhX3doaWxlX3RvcEAxNzoKICAgIHB1c2hpbnQgNzEwCiAgICBnbG9iYWwgT3Bjb2RlQnVkZ2V0CiAgICA+CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAzCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgYnl0ZWMgNCAvLyAweDA2ODEwMQogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KICAgIGJ5dGVjIDQgLy8gMHgwNjgxMDEKICAgIGl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGIgYXJjODlfY3JlYXRlX21ldGFkYXRhX3doaWxlX3RvcEAxNwoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzU1CiAgICAvLyBzZWxmLl9zZXRfbWV0YWRhdGFfcGF5bG9hZChhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSwgcGF5bG9hZC5uYXRpdmUpCiAgICBkaWcgNgogICAgZHVwCiAgICBkaWcgNQogICAgZGlnIDMKICAgIGNhbGxzdWIgX3NldF9tZXRhZGF0YV9wYXlsb2FkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM1Ny0zNTgKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEhlYWRlcgogICAgLy8gc2VsZi5faWRlbnRpZnlfbWV0YWRhdGEoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2lkZW50aWZ5X21ldGFkYXRhCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2MQogICAgLy8gdHJpbW1lZF9pdG9iKHVpbnQ9ZmxhZ3MuYXNfdWludDY0KCksIHNpemU9VUludDY0KGNvbnN0LkJZVEVfU0laRSkpLAogICAgZGlnIDYKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjExCiAgICAvLyByZXR1cm4gb3AuZXh0cmFjdChvcC5pdG9iKHVpbnQpLCBzdGFydCwgc2l6ZSkKICAgIGl0b2IKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgZGlnIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODAKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNjMKICAgIC8vIGlmIGFzc2V0X2lkLm1ldGFkYXRhX2hhc2ggIT0gQnl0ZXMoCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWV0YWRhdGFIYXNoCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2My0zNjUKICAgIC8vIGlmIGFzc2V0X2lkLm1ldGFkYXRhX2hhc2ggIT0gQnl0ZXMoCiAgICAvLyAgICAgY29uc3QuQllURVMzMl9TSVpFICogYiJceDAwIgogICAgLy8gKTogICMgTm90IGVtcHR5IG1ldGFkYXRhIGhhc2gKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgICE9CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfZWxzZV9ib2R5QDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTIKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MC05MwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2NgogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2ltbXV0YWJsZShhc3NldF9pZCksIGVyci5SRVFVSVJFU19JTU1VVEFCTEUKICAgIGFzc2VydCAvLyBNdXN0IGJlIGZsYWdnZWQgYXMgaW1tdXRhYmxlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2NwogICAgLy8gbWV0YWRhdGFfaGFzaCA9IGFzc2V0X2lkLm1ldGFkYXRhX2hhc2gKICAgIGRpZyA2CiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWV0YWRhdGFIYXNoCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDctMTA5CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIC8vICkKICAgIGRpZyAzCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgdmFsdWU9bWV0YWRhdGFfaGFzaAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3LTEwOQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCB2YWx1ZT1tZXRhZGF0YV9oYXNoCiAgICAvLyApCiAgICBkaWcgMwogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mzc0CiAgICAvLyByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgZ2xvYmFsIFJvdW5kCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3NQogICAgLy8gdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY0CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg2CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NC04NwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mzc3CiAgICAvLyBpc19zaG9ydD1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNzZXRfaWQpKSwKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3Mi0zNzkKICAgIC8vIGFiaS5BcmM4OU1ldGFkYXRhVXBkYXRlZCgKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZC5pZCksCiAgICAvLyAgICAgcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIC8vICAgICB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgIGZsYWdzPWZsYWdzLAogICAgLy8gICAgIGlzX3Nob3J0PWFyYzQuQm9vbChzZWxmLl9pc19zaG9ydChhc3NldF9pZCkpLAogICAgLy8gICAgIGhhc2g9YWJpLkhhc2guZnJvbV9ieXRlcyhtZXRhZGF0YV9oYXNoKSwKICAgIC8vICkKICAgIGRpZyAxMgogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBkaWcgOQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3MS0zODAKICAgIC8vIGFyYzQuZW1pdCgKICAgIC8vICAgICBhYmkuQXJjODlNZXRhZGF0YVVwZGF0ZWQoCiAgICAvLyAgICAgICAgIGFzc2V0X2lkPWFyYzQuVUludDY0KGFzc2V0X2lkLmlkKSwKICAgIC8vICAgICAgICAgcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIC8vICAgICAgICAgdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIC8vICAgICAgICAgZmxhZ3M9ZmxhZ3MsCiAgICAvLyAgICAgICAgIGlzX3Nob3J0PWFyYzQuQm9vbChzZWxmLl9pc19zaG9ydChhc3NldF9pZCkpLAogICAgLy8gICAgICAgICBoYXNoPWFiaS5IYXNoLmZyb21fYnl0ZXMobWV0YWRhdGFfaGFzaCksCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgYnl0ZWMgNSAvLyBtZXRob2QgIkFyYzg5TWV0YWRhdGFVcGRhdGVkKHVpbnQ2NCx1aW50NjQsdWludDY0LGJ5dGUsYm9vbCxieXRlWzMyXSkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODEKICAgIC8vIHNlbGYuX3NldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkLCBHbG9iYWwucm91bmQpCiAgICBnbG9iYWwgUm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIyCiAgICAvLyB2YWx1ZT1vcC5pdG9iKGxhc3RfbW9kaWZpZWRfcm91bmQpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjAtMTIzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMC0xMjMKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICB2YWx1ZT1vcC5pdG9iKGxhc3RfbW9kaWZpZWRfcm91bmQpLAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MgogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwLTkzCiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzgzLTM4NAogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gaWYgc2VsZi5faXNfYXJjODkoYXNzZXRfaWQpOgogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODcKICAgIC8vICsgaXRvYShHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZC5pZCkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgYnVyeSA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyOQogICAgLy8gYWNjID0gQnl0ZXMoYiIiKQogICAgYnl0ZWNfMSAvLyAweAogICAgYnVyeSAxMAoKYXJjODlfY3JlYXRlX21ldGFkYXRhX3doaWxlX3RvcEAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjMxCiAgICAvLyB3aGlsZSBpID4gMDoKICAgIGRpZyA4CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfd2hpbGVAMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjMyCiAgICAvLyBkID0gaSAlIFVJbnQ2NCgxMCkKICAgIGRpZyA4CiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjMzCiAgICAvLyBhY2MgPSBkaWdpdHNbZCA6IGQgKyBVSW50NjQoMSldICsgYWNjCiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgID49CiAgICBkaWcgMQogICAgcHVzaGludCAxMAogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIHN3YXAKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgID49CiAgICBwdXNoaW50IDEwCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIGR1cAogICAgZGlnIDIKICAgIDwKICAgIGRpZyAyCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjI3LTI4CiAgICAvLyAjIEFTQ0lJIGRpZ2l0cyAodmFsaWQgVVRGLTgpCiAgICAvLyBkaWdpdHMgPSBCeXRlcyhiIjAxMjM0NTY3ODkiKQogICAgcHVzaGJ5dGVzIDB4MzAzMTMyMzMzNDM1MzYzNzM4MzkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjMzCiAgICAvLyBhY2MgPSBkaWdpdHNbZCA6IGQgKyBVSW50NjQoMSldICsgYWNjCiAgICBjb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBkaWcgMTEKICAgIGNvbmNhdAogICAgYnVyeSAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MzQKICAgIC8vIGkgLy89IFVJbnQ2NCgxMCkKICAgIHB1c2hpbnQgMTAKICAgIC8KICAgIGJ1cnkgOQogICAgYiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfd2hpbGVfdG9wQDEwCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfd2hpbGVAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTozNgogICAgLy8gcmV0dXJuIGFjYyBvciBCeXRlcyhiIjAiKQogICAgZGlnIDkKICAgIGR1cAogICAgbGVuCiAgICBwdXNoYnl0ZXMgMHgzMAogICAgY292ZXIgMgogICAgc2VsZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM4NgogICAgLy8gY29uc3QuVVJJX0FSQ184OV9QUkVGSVgKICAgIHB1c2hieXRlcyAweDYxNmM2NzZmNzI2MTZlNjQzYTJmMmY2MTcwNzAyZgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODYtMzg3CiAgICAvLyBjb25zdC5VUklfQVJDXzg5X1BSRUZJWAogICAgLy8gKyBpdG9hKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkKQogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM4OAogICAgLy8gKyBjb25zdC5VUklfQVJDXzg5X1NVRkZJWAogICAgcHVzaGJ5dGVzIDB4M2Y2MjZmNzgzZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODYtMzg4CiAgICAvLyBjb25zdC5VUklfQVJDXzg5X1BSRUZJWAogICAgLy8gKyBpdG9hKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkKQogICAgLy8gKyBjb25zdC5VUklfQVJDXzg5X1NVRkZJWAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM5MAogICAgLy8gYXNhX3VybCA9IGFzc2V0X2lkLnVybAogICAgZGlnIDcKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRVUkwKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzkyCiAgICAvLyBhc2FfdXJsWzogYXJjXzg5X3VyaS5sZW5ndGhdID09IGFyY184OV91cmkKICAgIGR1cAogICAgbGVuCiAgICBkaWcgMgogICAgbGVuCiAgICBkdXAKICAgIGRpZyAyCiAgICA+PQogICAgc3dhcAogICAgY292ZXIgMgogICAgc2VsZWN0CiAgICBpbnRjXzEgLy8gMAogICAgc3dhcAogICAgc3Vic3RyaW5nMwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzkxLTM5MwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBhc2FfdXJsWzogYXJjXzg5X3VyaS5sZW5ndGhdID09IGFyY184OV91cmkKICAgIC8vICksIGVyci5BU0FfVVJMX0lOVkFMSURfQVJDODlfVVJJCiAgICBhc3NlcnQgLy8gSW52YWxpZCBBUkMtODkgVVJJCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozOTUKICAgIC8vIG1icl9kZWx0YV9hbW91bnQgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlIC0gbWJyX2kKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgZGlnIDIKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mzk3CiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgZGlnIDUKICAgIGd0eG5zIEFtb3VudAogICAgZGlnIDEKICAgID49CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM5Ni0zOTgKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyX2RlbHRhX3BheW1lbnQuYW1vdW50ID49IG1icl9kZWx0YV9hbW91bnQKICAgIC8vICksIGVyci5NQlJfREVMVEFfQU1PVU5UX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1CUiBEZWx0YSBhbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDAxCiAgICAvLyBzaWduPWFyYzQuVUludDgoZW51bXMuTUJSX0RFTFRBX1BPUyksIGFtb3VudD1hcmM0LlVJbnQ2NChtYnJfZGVsdGFfYW1vdW50KQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMTcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgYnl0ZWMgNiAvLyAweDE1MWY3Yzc1MDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfZWxzZV9ib2R5QDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2OQogICAgLy8gbWV0YWRhdGFfaGFzaCA9IHNlbGYuX2NvbXB1dGVfbWV0YWRhdGFfaGFzaChhc3NldF9pZCkKICAgIGRpZyA2CiAgICBjYWxsc3ViIF9jb21wdXRlX21ldGFkYXRhX2hhc2gKICAgIGIgYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9yZXBsYWNlX21ldGFkYXRhW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDA0CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MjUtNDI2CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkLCBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpKQogICAgc3dhcAogICAgYnRvaQogICAgZGlnIDIKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MjctNDI5CiAgICAvLyBhc3NlcnQgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLkxBUkdFUl9NRVRBREFUQV9TSVpFCiAgICBkaWcgMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGRpZyAxCiAgICA+PQogICAgYXNzZXJ0IC8vIEludmFsaWQgTWV0YWRhdGEgc2l6ZSwgbXVzdCBiZSBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGN1cnJlbnQgc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MzEtNDMyCiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBCb2R5CiAgICAvLyBtYnJfaSA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MzMKICAgIC8vIHNlbGYuX3NldF9tZXRhZGF0YV9wYXlsb2FkKGFzc2V0X2lkLCBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpLCBwYXlsb2FkLm5hdGl2ZSkKICAgIHVuY292ZXIgMgogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAzCiAgICBkaWcgMwogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIF9zZXRfbWV0YWRhdGFfcGF5bG9hZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MzUtNDM2CiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBIZWFkZXIKICAgIC8vIHNlbGYuX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KGFzc2V0X2lkKQogICAgZGlnIDIKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0MAogICAgLy8gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpID09IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIHVuY292ZXIgMgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDM4LTQ0MQogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc3NldF9pZCkgPT0gbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKQogICAgLy8gKSwgZXJyLk1FVEFEQVRBX1NJWkVfTUlTTUFUQ0gKICAgIGFzc2VydCAvLyBNZXRhZGF0YSBzaXplIG1pc21hdGNoLCBtdXN0IGJlIGV4YWN0bHkgZXF1YWwgdG8gZGVjbGFyZWQgc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDMKICAgIC8vIG1icl9kZWx0YV9hbW91bnQgPSBtYnJfaSAtIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0NAogICAgLy8gaWYgbWJyX2RlbHRhX2Ftb3VudCA9PSAwOgogICAgYm56IGFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDQ1CiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9OVUxMKQogICAgaW50Y18xIC8vIDAKCmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NTMKICAgIC8vIHJldHVybiBhYmkuTWJyRGVsdGEoc2lnbj1hcmM0LlVJbnQ4KHNpZ24pLCBhbW91bnQ9YXJjNC5VSW50NjQobWJyX2RlbHRhX2Ftb3VudCkpCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICBkaWcgMQogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQwNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9yZXBsYWNlX21ldGFkYXRhX2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDcKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX05FRykKICAgIHB1c2hpbnQgMjU1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0OC00NTEKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1hc3NldF9pZC5tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD1tYnJfZGVsdGFfYW1vdW50LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDkKICAgIC8vIHJlY2VpdmVyPWFzc2V0X2lkLm1hbmFnZXIsCiAgICBkaWcgMgogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDgKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMCAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDgtNDUxCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciwKICAgIC8vICAgICBhbW91bnQ9bWJyX2RlbHRhX2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIGFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA1CgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfbGFyZ2VyW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9sYXJnZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18wIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMCAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDc4LTQ3OQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucyhhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSkKICAgIHVuY292ZXIgMgogICAgYnRvaQogICAgZGlnIDMKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0ODAtNDgyCiAgICAvLyBhc3NlcnQgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA+IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgLy8gICAgIGFzc2V0X2lkCiAgICAvLyApLCBlcnIuU01BTExFUl9NRVRBREFUQV9TSVpFCiAgICBkaWcgMwogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGRpZyAxCiAgICA8CiAgICBhc3NlcnQgLy8gSW52YWxpZCBNZXRhZGF0YSBzaXplLCBtdXN0IGJlIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDg0CiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBkaWcgMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0ODMtNDg1CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG1icl9kZWx0YV9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksIGVyci5NQlJfREVMVEFfUkVDRUlWRVJfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIHJlY2VpdmVyLCBtdXN0IGJlIHRoZSBBU0EgTWV0YWRhdGEgUmVnaXN0cnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDg3LTQ4OAogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgQm9keQogICAgLy8gbWJyX2kgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDg5CiAgICAvLyBzZWxmLl9zZXRfbWV0YWRhdGFfcGF5bG9hZChhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSwgcGF5bG9hZC5uYXRpdmUpCiAgICB1bmNvdmVyIDMKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgNAogICAgZGlnIDMKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfc2V0X21ldGFkYXRhX3BheWxvYWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkxLTQ5MgogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OTYKICAgIC8vIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSA9PSBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICB1bmNvdmVyIDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ5NC00OTcKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpID09IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIC8vICksIGVyci5NRVRBREFUQV9TSVpFX01JU01BVENICiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgc2l6ZSBtaXNtYXRjaCwgbXVzdCBiZSBleGFjdGx5IGVxdWFsIHRvIGRlY2xhcmVkIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDk5CiAgICAvLyBtYnJfZGVsdGFfYW1vdW50ID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZSAtIG1icl9pCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTAxCiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgc3dhcAogICAgZ3R4bnMgQW1vdW50CiAgICBkaWcgMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTAwLTUwMgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgLy8gKSwgZXJyLk1CUl9ERUxUQV9BTU9VTlRfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MDUKICAgIC8vIHNpZ249YXJjNC5VSW50OChlbnVtcy5NQlJfREVMVEFfUE9TKSwgYW1vdW50PWFyYzQuVUludDY0KG1icl9kZWx0YV9hbW91bnQpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBieXRlYyA2IC8vIDB4MTUxZjdjNzUwMQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfc2xpY2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUwOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTI1LTUyNgogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucyhhc3NldF9pZCwgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpKQogICAgZGlnIDIKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBkaWcgMwogICAgc3dhcAogICAgY2FsbHN1YiBfY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTI3CiAgICAvLyBhc3NlcnQgb2Zmc2V0LmFzX3VpbnQ2NCgpICsgcGF5bG9hZC5uYXRpdmUubGVuZ3RoIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgc3dhcAogICAgYnRvaQogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgY292ZXIgMwogICAgZHVwCiAgICBsZW4KICAgIGRpZyAyCiAgICBkaWcgMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MjctNTI5CiAgICAvLyBhc3NlcnQgb2Zmc2V0LmFzX3VpbnQ2NCgpICsgcGF5bG9hZC5uYXRpdmUubGVuZ3RoIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgLy8gICAgIGFzc2V0X2lkCiAgICAvLyApLCBlcnIuRVhDRUVEU19NRVRBREFUQV9TSVpFCiAgICBkaWcgNAogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIDw9CiAgICBhc3NlcnQgLy8gU2xpY2UgZXhjZWVkcyBtZXRhZGF0YSByYW5nZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMDYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICB1bmNvdmVyIDMKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMDcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldCwgbGVuZ3RoPXNpemUKICAgIHB1c2hpbnQgNDIKICAgIHVuY292ZXIgNAogICAgKwogICAgZHVwCiAgICBjb3ZlciA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwNi0yMDgKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LCBsZW5ndGg9c2l6ZQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MzUKICAgIC8vIGlmIHBheWxvYWQubmF0aXZlICE9IGV4aXN0aW5nX3NsaWNlOgogICAgIT0KICAgIGJ6IGFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfc2xpY2VfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUzNi01NDAKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEJvZHkKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzc2V0X2lkKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldC5hc191aW50NjQoKSwKICAgIC8vICAgICB2YWx1ZT1wYXlsb2FkLm5hdGl2ZSwKICAgIC8vICkKICAgIGR1cDIKICAgIGRpZyA0CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NDItNTQzCiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBIZWFkZXIKICAgIC8vIHNlbGYuX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KGFzc2V0X2lkKQogICAgZGlnIDMKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CgphcmM4OV9yZXBsYWNlX21ldGFkYXRhX3NsaWNlX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTA4CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZGVsZXRlX21ldGFkYXRhW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZGVsZXRlX21ldGFkYXRhOgogICAgYnl0ZWNfMSAvLyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwbiAyCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ5CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2MC01NjEKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc3NldF9pZCksIGVyci5BU1NFVF9NRVRBREFUQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYyCiAgICAvLyBpZiBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2RlbGV0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTAtOTMKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NjMKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5faXNfaW1tdXRhYmxlKGFzc2V0X2lkKSwgZXJyLklNTVVUQUJMRQogICAgIQogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIGlzIGltbXV0YWJsZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NjQKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hc2FfbWFuYWdlcihhc3NldF9pZCksIGVyci5VTkFVVEhPUklaRUQKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9pc19hc2FfbWFuYWdlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZCwgbXVzdCBiZSB0aGUgQXNzZXQgTWFuYWdlcgoKYXJjODlfZGVsZXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTY2LTU2NwogICAgLy8gIyBEZWxldGUgTWV0YWRhdGEgYW5kIHJlZnVuZCBNQlIKICAgIC8vIG1icl9pID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2OAogICAgLy8gZGVsIHNlbGYuYXNzZXRfbWV0YWRhdGFbYXNzZXRfaWRdCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2OQogICAgLy8gbWJyX2RlbHRhX2Ftb3VudCA9IG1icl9pIC0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAtCiAgICBidXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTcwLTU3MwogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWFzc2V0X2lkLm1hbmFnZXIgaWYgc2VsZi5fYXNhX2V4aXN0cyhhc3NldF9pZCkgZWxzZSBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFtb3VudD1tYnJfZGVsdGFfYW1vdW50LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NQogICAgLy8gX2NyZWF0b3IsIGV4aXN0cyA9IG9wLkFzc2V0UGFyYW1zR2V0LmFzc2V0X2NyZWF0b3IoYXNhKQogICAgZGlnIDEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTcxCiAgICAvLyByZWNlaXZlcj1hc3NldF9pZC5tYW5hZ2VyIGlmIHNlbGYuX2FzYV9leGlzdHMoYXNzZXRfaWQpIGVsc2UgVHhuLnNlbmRlciwKICAgIGJ6IGFyYzg5X2RlbGV0ZV9tZXRhZGF0YV90ZXJuYXJ5X2ZhbHNlQDUKICAgIGRpZyAxCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWFuYWdlcgogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwoKYXJjODlfZGVsZXRlX21ldGFkYXRhX3Rlcm5hcnlfbWVyZ2VANjoKICAgIGRpZyA0CiAgICBkdXAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3MAogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18wIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18xIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3MC01NzMKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1hc3NldF9pZC5tYW5hZ2VyIGlmIHNlbGYuX2FzYV9leGlzdHMoYXNzZXRfaWQpIGVsc2UgVHhuLnNlbmRlciwKICAgIC8vICAgICBhbW91bnQ9bWJyX2RlbHRhX2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3OAogICAgLy8gcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIGdsb2JhbCBSb3VuZAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NzkKICAgIC8vIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3Ni01ODAKICAgIC8vIGFiaS5BcmM4OU1ldGFkYXRhRGVsZXRlZCgKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZC5pZCksCiAgICAvLyAgICAgcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIC8vICAgICB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gKQogICAgZGlnIDUKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTc1LTU4MQogICAgLy8gYXJjNC5lbWl0KAogICAgLy8gICAgIGFiaS5BcmM4OU1ldGFkYXRhRGVsZXRlZCgKICAgIC8vICAgICAgICAgYXNzZXRfaWQ9YXJjNC5VSW50NjQoYXNzZXRfaWQuaWQpLAogICAgLy8gICAgICAgICByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgICAgICB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIHB1c2hieXRlcyAweGJjM2YyMGQxIC8vIG1ldGhvZCAiQXJjODlNZXRhZGF0YURlbGV0ZWQodWludDY0LHVpbnQ2NCx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTg0CiAgICAvLyBzaWduPWFyYzQuVUludDgoZW51bXMuTUJSX0RFTFRBX05FRyksIGFtb3VudD1hcmM0LlVJbnQ2NChtYnJfZGVsdGFfYW1vdW50KQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzVmZgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X2RlbGV0ZV9tZXRhZGF0YV90ZXJuYXJ5X2ZhbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3MQogICAgLy8gcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciBpZiBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSBlbHNlIFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICBiIGFyYzg5X2RlbGV0ZV9tZXRhZGF0YV90ZXJuYXJ5X21lcmdlQDYKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZXh0cmFfcGF5bG9hZFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2V4dHJhX3BheWxvYWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU4NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGR1cAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MDAtNjAxCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSwgZXJyLkFTQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBUaGUgc3BlY2lmaWVkIEFTQSBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OQogICAgLy8gcmV0dXJuIGFzYSBpbiBzZWxmLmFzc2V0X21ldGFkYXRhCiAgICBkdXAKICAgIGl0b2IKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MDIKICAgIC8vIGFzc2VydCBzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNzZXRfaWQpLCBlcnIuQVNTRVRfTUVUQURBVEFfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gQXNzZXQgTWV0YWRhdGEgZG9lcyBub3QgZXhpc3QgZm9yIHRoZSBzcGVjaWZpZWQgQVNBCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYwMwogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FzYV9tYW5hZ2VyKGFzc2V0X2lkKSwgZXJyLlVOQVVUSE9SSVpFRAogICAgY2FsbHN1YiBfaXNfYXNhX21hbmFnZXIKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQsIG11c3QgYmUgdGhlIEFzc2V0IE1hbmFnZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfc2V0X3JldmVyc2libGVfZmxhZ1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3NldF9yZXZlcnNpYmxlX2ZsYWc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYwNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmJvb2wKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjIxLTYyMgogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDIKICAgIGNhbGxzdWIgX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjIzCiAgICAvLyBhc3NlcnQgZmxhZy5hc191aW50NjQoKSA8PSBmbGcuRkxHX1JFU0VSVkVEXzMsIGVyci5GTEFHX0lEWF9JTlZBTElECiAgICBzd2FwCiAgICBidG9pCiAgICBkdXAKICAgIHB1c2hpbnQgMwogICAgPD0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGZsYWcgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MgogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIHB1c2hpbnQgNwogICAgdW5jb3ZlciAyCiAgICAtCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTAtOTMKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MjcKICAgIC8vIGlmIHZhbHVlLm5hdGl2ZSAhPSBleGlzdGluZ192YWx1ZToKICAgIHN3YXAKICAgIGludGNfMSAvLyAwCiAgICBnZXRiaXQKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICAhPQogICAgYnogYXJjODlfc2V0X3JldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMjQtMjI2CiAgICAvLyB1cGRhdGVkX2ZsYWdzID0gb3Auc2V0Yml0X2J5dGVzKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpLCBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLCB2YWx1ZQogICAgLy8gKQogICAgZGlnIDMKICAgIGRpZyAzCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODAKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMxLTYzMgogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAoKYXJjODlfc2V0X3JldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYwNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZzoKICAgIGludGNfMSAvLyAwCiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYzNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NDgtNjQ5CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY1MQogICAgLy8gZmxnLkZMR19SRVNFUlZFRF82IDw9IGZsYWcuYXNfdWludDY0KCkgPD0gZmxnLkZMR19JTU1VVEFCTEUKICAgIGJ0b2kKICAgIGR1cAogICAgcHVzaGludCA2CiAgICA+PQogICAgYnogYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfZmFsc2VANAogICAgZHVwCiAgICBwdXNoaW50IDcKICAgIDw9CiAgICBieiBhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzAgLy8gMQoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjUwLTY1MgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBmbGcuRkxHX1JFU0VSVkVEXzYgPD0gZmxhZy5hc191aW50NjQoKSA8PSBmbGcuRkxHX0lNTVVUQUJMRQogICAgLy8gKSwgZXJyLkZMQUdfSURYX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIGZsYWcgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBkaWcgMQogICAgaXRvYgogICAgZHVwCiAgICBidXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTIKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICBwdXNoaW50IDcKICAgIGRpZyAyCiAgICAtCiAgICBkdXAKICAgIGJ1cnkgNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MC05MwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY1NgogICAgLy8gaWYgbm90IGV4aXN0aW5nX3ZhbHVlOgogICAgYm56IGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDMKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMjQtMjI2CiAgICAvLyB1cGRhdGVkX2ZsYWdzID0gb3Auc2V0Yml0X2J5dGVzKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpLCBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLCB2YWx1ZQogICAgLy8gKQogICAgZGlnIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjU3LTY1OAogICAgLy8gIyBTZXQgSXJyZXZlcnNpYmxlIEZsYWcKICAgIC8vIHNlbGYuX3NldF9mbGFnKGFzc2V0X2lkLCBmbGFnLmFzX3VpbnQ2NCgpLCB2YWx1ZT1UcnVlKQogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjI0LTIyNgogICAgLy8gdXBkYXRlZF9mbGFncyA9IG9wLnNldGJpdF9ieXRlcygKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywgdmFsdWUKICAgIC8vICkKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4MAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzktODEKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjAtNjYxCiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBIZWFkZXIKICAgIC8vIHNlbGYuX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CgphcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MzQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMSAvLyAwCiAgICBiIGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfc2V0X2ltbXV0YWJsZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3NldF9pbW11dGFibGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY2MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY3NS02NzYKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGR1cAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjI1CiAgICAvLyBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywgdmFsdWUKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY3OC02NzkKICAgIC8vICMgU2V0IEltbXV0YWJsZSBGbGFnCiAgICAvLyBzZWxmLl9zZXRfZmxhZyhhc3NldF9pZCwgVUludDY0KGZsZy5GTEdfSU1NVVRBQkxFKSwgdmFsdWU9VHJ1ZSkKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIyNC0yMjYKICAgIC8vIHVwZGF0ZWRfZmxhZ3MgPSBvcC5zZXRiaXRfYnl0ZXMoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSksIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsIHZhbHVlCiAgICAvLyApCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODAKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjgxLTY4MgogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY2MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhOgogICAgYnl0ZWNfMSAvLyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcwNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzI1CiAgICAvLyBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBjb25zdC5NQVhfTUVUQURBVEFfU0laRQogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjIDYgLy8gMzA1MDcKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyMy03MjYKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBjb25zdC5NQVhfTUVUQURBVEFfU0laRQogICAgLy8gKSwgZXJyLkVYQ0VFRFNfTUFYX01FVEFEQVRBX1NJWkUKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1ldGFkYXRhIHNpemUsIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgaXRvYgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyOAogICAgLy8gaWYgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzI5CiAgICAvLyBtZXRhZGF0YV9zaXplID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGR1cAogICAgYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczMAogICAgLy8gZmxhdF9tYnIgPSBVSW50NjQoMCkKICAgIGludGNfMSAvLyAwCiAgICBidXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMxCiAgICAvLyBpZiBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA9PSBtZXRhZGF0YV9zaXplOgogICAgZGlnIDEKICAgID09CiAgICBieiBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2Vsc2VfYm9keUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczMwogICAgLy8gZGVsdGFfc2l6ZSA9IFVJbnQ2NCgwKQogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMyCiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9OVUxMKQogICAgZHVwCgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2FmdGVyX2lmX2Vsc2VAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0OQogICAgLy8gZGVsdGFfYW1vdW50ID0gZmxhdF9tYnIgKyBjb25zdC5CWVRFX01CUiAqIGRlbHRhX3NpemUKICAgIHB1c2hpbnQgNDAwCiAgICB1bmNvdmVyIDIKICAgICoKICAgIGRpZyA1CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1MQogICAgLy8gcmV0dXJuIGFiaS5NYnJEZWx0YShzaWduPWFyYzQuVUludDgoc2lnbiksIGFtb3VudD1hcmM0LlVJbnQ2NChkZWx0YV9hbW91bnQpKQogICAgc3dhcAogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMiAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcwNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2Vsc2VfYm9keUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MzQKICAgIC8vIGVsaWYgbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkgPiBtZXRhZGF0YV9zaXplOgogICAgZHVwCiAgICBkaWcgMwogICAgPgogICAgYnogYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9lbHNlX2JvZHlANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MzUKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX1BPUykKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczNgogICAgLy8gZGVsdGFfc2l6ZSA9IG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpIC0gbWV0YWRhdGFfc2l6ZQogICAgZGlnIDEKICAgIGRpZyA0CiAgICAtCiAgICBzd2FwCiAgICBiIGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfYWZ0ZXJfaWZfZWxzZUAxMAoKYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9lbHNlX2JvZHlANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzM4CiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9ORUcpCiAgICBwdXNoaW50IDI1NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MzkKICAgIC8vIGRlbHRhX3NpemUgPSBtZXRhZGF0YV9zaXplIC0gbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIGRpZyAzCiAgICBkaWcgMgogICAgLQogICAgc3dhcAogICAgYiBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2FmdGVyX2lmX2Vsc2VAMTAKCmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0MQogICAgLy8gZmxhdF9tYnIgPSBVSW50NjQoY29uc3QuRkxBVF9NQlIpCiAgICBwdXNoaW50IDI1MDAKICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NDIKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX1BPUykKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0NC03NDUKICAgIC8vIGNvbnN0LkFTU0VUX01FVEFEQVRBX0JPWF9LRVlfU0laRQogICAgLy8gKyBjb25zdC5NRVRBREFUQV9IRUFERVJfU0laRQogICAgcHVzaGludCA1MAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NDQtNzQ2CiAgICAvLyBjb25zdC5BU1NFVF9NRVRBREFUQV9CT1hfS0VZX1NJWkUKICAgIC8vICsgY29uc3QuTUVUQURBVEFfSEVBREVSX1NJWkUKICAgIC8vICsgbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIGRpZyAyCiAgICArCiAgICBzd2FwCiAgICBiIGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfYWZ0ZXJfaWZfZWxzZUAxMAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9jaGVja19tZXRhZGF0YV9leGlzdHNbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9jaGVja19tZXRhZGF0YV9leGlzdHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1CiAgICAvLyBfY3JlYXRvciwgZXhpc3RzID0gb3AuQXNzZXRQYXJhbXNHZXQuYXNzZXRfY3JlYXRvcihhc2EpCiAgICBkdXAKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzY5CiAgICAvLyBhc2FfZXhpc3RzPWFyYzQuQm9vbChzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSksCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OQogICAgLy8gcmV0dXJuIGFzYSBpbiBzZWxmLmFzc2V0X21ldGFkYXRhCiAgICBzd2FwCiAgICBpdG9iCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzcwCiAgICAvLyBtZXRhZGF0YV9leGlzdHM9YXJjNC5Cb29sKHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc3NldF9pZCkpLAogICAgYnl0ZWNfMiAvLyAweDAwCiAgICBpbnRjXzEgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzY4LTc3MQogICAgLy8gcmV0dXJuIGFiaS5NZXRhZGF0YUV4aXN0ZW5jZSgKICAgIC8vICAgICBhc2FfZXhpc3RzPWFyYzQuQm9vbChzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSksCiAgICAvLyAgICAgbWV0YWRhdGFfZXhpc3RzPWFyYzQuQm9vbChzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIGludGNfMSAvLyAwCiAgICBnZXRiaXQKICAgIGludGNfMCAvLyAxCiAgICBzd2FwCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUzCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NzMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc4OC03ODkKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTIKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MC05MwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5MgogICAgLy8gc2VsZi5faXNfaW1tdXRhYmxlKGFzc2V0X2lkKSBvciBhc3NldF9pZC5tYW5hZ2VyID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGJueiBhcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF90cnVlQDMKICAgIGR1cAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgPT0KICAgIGJ6IGFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZV9ib29sX2ZhbHNlQDQKCmFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZV9ib29sX3RydWVAMzoKICAgIGludGNfMCAvLyAxCgphcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3OTEtNzkzCiAgICAvLyByZXR1cm4gYXJjNC5Cb29sKAogICAgLy8gICAgIHNlbGYuX2lzX2ltbXV0YWJsZShhc3NldF9pZCkgb3IgYXNzZXRfaWQubWFuYWdlciA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyApCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NzMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMSAvLyAwCiAgICBiIGFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZV9ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfaXNfbWV0YWRhdGFfc2hvcnRbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9pc19tZXRhZGF0YV9zaG9ydDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Nzk1CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODEwLTgxMQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjIKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjQKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg0LTg3CiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4MTQKICAgIC8vIGZsYWc9YXJjNC5Cb29sKHNlbGYuX2lzX3Nob3J0KGFzc2V0X2lkKSksCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTMtMTE2CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE0CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIHB1c2hpbnQgMzQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE1CiAgICAvLyBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgaW50Y18yIC8vIDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEzLTExNgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTItMTE3CiAgICAvLyByZXR1cm4gb3AuYnRvaSgKICAgIC8vICAgICBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODE1CiAgICAvLyBsYXN0X21vZGlmaWVkX3JvdW5kPWFyYzQuVUludDY0KHNlbGYuX2dldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkKSksCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgxMy04MTYKICAgIC8vIHJldHVybiBhYmkuTXV0YWJsZUZsYWcoCiAgICAvLyAgICAgZmxhZz1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNzZXRfaWQpKSwKICAgIC8vICAgICBsYXN0X21vZGlmaWVkX3JvdW5kPWFyYzQuVUludDY0KHNlbGYuX2dldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkKSksCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Nzk1CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlcltyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgxOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgzMy04MzQKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Mi02NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY0CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMi0xMDQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIGludGNfMyAvLyAyCiAgICBwdXNoaW50IDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMi0xMDQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMy0xMTYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgdW5jb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNQogICAgLy8gbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIGludGNfMiAvLyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMy0xMTYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEyLTExNwogICAgLy8gcmV0dXJuIG9wLmJ0b2koCiAgICAvLyAgICAgc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg0MAogICAgLy8gbGFzdF9tb2RpZmllZF9yb3VuZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCkpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4MzYtODQxCiAgICAvLyByZXR1cm4gYWJpLk1ldGFkYXRhSGVhZGVyKAogICAgLy8gICAgIGlkZW50aWZpZXJzPWFyYzQuQnl0ZS5mcm9tX2J5dGVzKHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc3NldF9pZCkpLAogICAgLy8gICAgIGZsYWdzPWFyYzQuQnl0ZS5mcm9tX2J5dGVzKHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc3NldF9pZCkpLAogICAgLy8gICAgIGhhc2g9YWJpLkhhc2guZnJvbV9ieXRlcyhzZWxmLl9nZXRfbWV0YWRhdGFfaGFzaChhc3NldF9pZCkpLAogICAgLy8gICAgIGxhc3RfbW9kaWZpZWRfcm91bmQ9YXJjNC5VSW50NjQoc2VsZi5fZ2V0X2xhc3RfbW9kaWZpZWRfcm91bmQoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODE4CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2luYXRpb25bcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfcGFnaW5hdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODQzCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODU3LTg1OAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYxCiAgICAvLyBtZXRhZGF0YV9zaXplPWFyYzQuVUludDE2KHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSksCiAgICBkdXAKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgcHVzaGludCAxNgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA2IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgwCiAgICAvLyBuID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKQogICAgc3dhcAogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjIxLTIyCiAgICAvLyAjIEFzc3VtZXMgZCA+PSAxCiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICBpbnRjIDUgLy8gMTAwNgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODEKICAgIC8vIHJldHVybiBjZWlsX2RpdihudW09biwgZGVuPVVJbnQ2NChjb25zdC5QQUdFX1NJWkUpKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjIxLTIyCiAgICAvLyAjIEFzc3VtZXMgZCA+PSAxCiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg2MwogICAgLy8gdG90YWxfcGFnZXM9YXJjNC5VSW50OChzZWxmLl9nZXRfdG90YWxfcGFnZXMoYXNzZXRfaWQpKSwKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYwLTg2NAogICAgLy8gcmV0dXJuIGFiaS5QYWdpbmF0aW9uKAogICAgLy8gICAgIG1ldGFkYXRhX3NpemU9YXJjNC5VSW50MTYoc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpKSwKICAgIC8vICAgICBwYWdlX3NpemU9YXJjNC5VSW50MTYoY29uc3QuUEFHRV9TSVpFKSwKICAgIC8vICAgICB0b3RhbF9wYWdlcz1hcmM0LlVJbnQ4KHNlbGYuX2dldF90b3RhbF9wYWdlcyhhc3NldF9pZCkpLAogICAgLy8gKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NjIKICAgIC8vIHBhZ2Vfc2l6ZT1hcmM0LlVJbnQxNihjb25zdC5QQUdFX1NJWkUpLAogICAgcHVzaGJ5dGVzIDB4MDNlZgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NjAtODY0CiAgICAvLyByZXR1cm4gYWJpLlBhZ2luYXRpb24oCiAgICAvLyAgICAgbWV0YWRhdGFfc2l6ZT1hcmM0LlVJbnQxNihzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc3NldF9pZCkpLAogICAgLy8gICAgIHBhZ2Vfc2l6ZT1hcmM0LlVJbnQxNihjb25zdC5QQUdFX1NJWkUpLAogICAgLy8gICAgIHRvdGFsX3BhZ2VzPWFyYzQuVUludDgoc2VsZi5fZ2V0X3RvdGFsX3BhZ2VzKGFzc2V0X2lkKSksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGE6CiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg2NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBpbnRjXzAgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4ODMtODg0CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODAKICAgIC8vIG4gPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjEtMjIKICAgIC8vICMgQXNzdW1lcyBkID49IDEKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIGludGMgNSAvLyAxMDA2CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4MQogICAgLy8gcmV0dXJuIGNlaWxfZGl2KG51bT1uLCBkZW49VUludDY0KGNvbnN0LlBBR0VfU0laRSkpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjEtMjIKICAgIC8vICMgQXNzdW1lcyBkID49IDEKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIC8KICAgIGR1cAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4ODYKICAgIC8vIGlmIHRvdGFsX3BhZ2VzID4gMDoKICAgIGJ6IGFyYzg5X2dldF9tZXRhZGF0YV9lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4ODcKICAgIC8vIGFzc2VydCBwYWdlLmFzX3VpbnQ2NCgpIDwgdG90YWxfcGFnZXMsIGVyci5QQUdFX0lEWF9JTlZBTElECiAgICBidG9pCiAgICBkdXAKICAgIGRpZyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIDwKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBhZ2UgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODg4CiAgICAvLyBoYXNfbmV4dF9wYWdlID0gcGFnZS5hc191aW50NjQoKSA8IHRvdGFsX3BhZ2VzIC0gMQogICAgaW50Y18wIC8vIDEKICAgIC0KICAgIGRpZyAxCiAgICA+CiAgICBidXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODg5CiAgICAvLyBwYWdlX2NvbnRlbnQgPSBzZWxmLl9nZXRfbWV0YWRhdGFfcGFnZShhc3NldF9pZCwgcGFnZS5hc191aW50NjQoKSkKICAgIGRpZyAyCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfcGFnZQoKYXJjODlfZ2V0X21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODk2CiAgICAvLyBoYXNfbmV4dF9wYWdlPWFyYzQuQm9vbChoYXNfbmV4dF9wYWdlKSwKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18xIC8vIDAKICAgIGRpZyA1CiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBkaWcgMwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTQKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgcHVzaGludCAzNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTUKICAgIC8vIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICBpbnRjXzIgLy8gOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTMtMTE2CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMi0xMTcKICAgIC8vIHJldHVybiBvcC5idG9pKAogICAgLy8gICAgIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgICAgIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4OTcKICAgIC8vIGxhc3RfbW9kaWZpZWRfcm91bmQ9YXJjNC5VSW50NjQoc2VsZi5fZ2V0X2xhc3RfbW9kaWZpZWRfcm91bmQoYXNzZXRfaWQpKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODk4CiAgICAvLyBwYWdlX2NvbnRlbnQ9YXJjNC5EeW5hbWljQnl0ZXMocGFnZV9jb250ZW50KSwKICAgIHVuY292ZXIgMgogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODk1LTg5OQogICAgLy8gcmV0dXJuIGFiaS5QYWdpbmF0ZWRNZXRhZGF0YSgKICAgIC8vICAgICBoYXNfbmV4dF9wYWdlPWFyYzQuQm9vbChoYXNfbmV4dF9wYWdlKSwKICAgIC8vICAgICBsYXN0X21vZGlmaWVkX3JvdW5kPWFyYzQuVUludDY0KHNlbGYuX2dldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkKSksCiAgICAvLyAgICAgcGFnZV9jb250ZW50PWFyYzQuRHluYW1pY0J5dGVzKHBhZ2VfY29udGVudCksCiAgICAvLyApCiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDAwMGIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg2NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9nZXRfbWV0YWRhdGFfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg5MQogICAgLy8gYXNzZXJ0IHBhZ2UuYXNfdWludDY0KCkgPT0gMCwgZXJyLlBBR0VfSURYX0lOVkFMSUQKICAgIGJ0b2kKICAgICEKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBhZ2UgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODkyCiAgICAvLyBoYXNfbmV4dF9wYWdlID0gRmFsc2UKICAgIGludGNfMSAvLyAwCiAgICBidXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODkzCiAgICAvLyBwYWdlX2NvbnRlbnQgPSBCeXRlcygpCiAgICBieXRlY18xIC8vIDB4CiAgICBiIGFyYzg5X2dldF9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDQKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX3NsaWNlW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX3NsaWNlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MDEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MjAtOTIxCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDIKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyMgogICAgLy8gYXNzZXJ0IHNpemUuYXNfdWludDY0KCkgPD0gY29uc3QuUEFHRV9TSVpFLCBlcnIuRVhDRUVEU19QQUdFX1NJWkUKICAgIGJ0b2kKICAgIGR1cAogICAgaW50YyA0IC8vIDEwMDcKICAgIDw9CiAgICBhc3NlcnQgLy8gUGF5bG9hZCBleGNlZWRzIHBhZ2Ugc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MjMKICAgIC8vIGFzc2VydCBvZmZzZXQuYXNfdWludDY0KCkgKyBzaXplLmFzX3VpbnQ2NCgpIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgc3dhcAogICAgYnRvaQogICAgZHVwCiAgICBkaWcgMgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MjMtOTI1CiAgICAvLyBhc3NlcnQgb2Zmc2V0LmFzX3VpbnQ2NCgpICsgc2l6ZS5hc191aW50NjQoKSA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLkVYQ0VFRFNfTUVUQURBVEFfU0laRQogICAgZGlnIDMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICA8PQogICAgYXNzZXJ0IC8vIFNsaWNlIGV4Y2VlZHMgbWV0YWRhdGEgcmFuZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTI3CiAgICAvLyBtZXRhZGF0YV9zbGljZSA9IHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzc2V0X2lkKS5leHRyYWN0KAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyOAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LmFzX3VpbnQ2NCgpLCBsZW5ndGg9c2l6ZS5hc191aW50NjQoKQogICAgcHVzaGludCA0MgogICAgdW5jb3ZlciAyCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyNy05MjkKICAgIC8vIG1ldGFkYXRhX3NsaWNlID0gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNzZXRfaWQpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LmFzX3VpbnQ2NCgpLCBsZW5ndGg9c2l6ZS5hc191aW50NjQoKQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MDEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfaGVhZGVyX2hhc2hbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfaGVhZGVyX2hhc2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkzMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk0Ny05NDgKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk1MAogICAgLy8gcmV0dXJuIGFiaS5IYXNoLmZyb21fYnl0ZXMoc2VsZi5fY29tcHV0ZV9oZWFkZXJfaGFzaChhc3NldF9pZCkpCiAgICBjYWxsc3ViIF9jb21wdXRlX2hlYWRlcl9oYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkzMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9wYWdlX2hhc2hbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfcGFnZV9oYXNoOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk2OS05NzAKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgwCiAgICAvLyBuID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyMS0yMgogICAgLy8gIyBBc3N1bWVzIGQgPj0gMQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgaW50YyA1IC8vIDEwMDYKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgxCiAgICAvLyByZXR1cm4gY2VpbF9kaXYobnVtPW4sIGRlbj1VSW50NjQoY29uc3QuUEFHRV9TSVpFKSkKICAgIGludGMgNCAvLyAxMDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyMS0yMgogICAgLy8gIyBBc3N1bWVzIGQgPj0gMQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NzIKICAgIC8vIGlmIHRvdGFsX3BhZ2VzID4gMDoKICAgIGFzc2VydCAvLyBNZXRhZGF0YSBpcyBlbXB0eQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NzMKICAgIC8vIGFzc2VydCBwYWdlLmFzX3VpbnQ2NCgpIDwgc2VsZi5fZ2V0X3RvdGFsX3BhZ2VzKAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODAKICAgIC8vIG4gPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjIxLTIyCiAgICAvLyAjIEFzc3VtZXMgZCA+PSAxCiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICBpbnRjIDUgLy8gMTAwNgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODEKICAgIC8vIHJldHVybiBjZWlsX2RpdihudW09biwgZGVuPVVJbnQ2NChjb25zdC5QQUdFX1NJWkUpKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjIxLTIyCiAgICAvLyAjIEFzc3VtZXMgZCA+PSAxCiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3My05NzUKICAgIC8vIGFzc2VydCBwYWdlLmFzX3VpbnQ2NCgpIDwgc2VsZi5fZ2V0X3RvdGFsX3BhZ2VzKAogICAgLy8gICAgIGFzc2V0X2lkCiAgICAvLyApLCBlcnIuUEFHRV9JRFhfSU5WQUxJRAogICAgZGlnIDEKICAgID4KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBhZ2UgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTc5CiAgICAvLyBwYWdlX2NvbnRlbnQgPSBzZWxmLl9nZXRfbWV0YWRhdGFfcGFnZShhc3NldF9pZCwgcGFnZS5hc191aW50NjQoKSkKICAgIGR1cDIKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9wYWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk4MAogICAgLy8gcGFnZV9oYXNoID0gc2VsZi5fY29tcHV0ZV9wYWdlX2hhc2goYXNzZXRfaWQsIHBhZ2UuYXNfdWludDY0KCksIHBhZ2VfY29udGVudCkKICAgIGNhbGxzdWIgX2NvbXB1dGVfcGFnZV9oYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk1MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9oYXNoW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX2hhc2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5OC05OTkKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAzCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0hBU0hfU0laRQogICAgaW50Y18zIC8vIDIKICAgIHB1c2hpbnQgMzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAyLTEwNAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0hBU0hfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgzCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX3N0cmluZ19ieV9rZXlbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfc3RyaW5nX2J5X2tleToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAwMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMjEtMTAyMgogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDI0CiAgICAvLyBvYmogPSBzZWxmLl9nZXRfc2hvcnRfbWV0YWRhdGEoYXNzZXRfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfc2hvcnRfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAyNQogICAgLy8gdmFsdWUgPSBvcC5Kc29uUmVmLmpzb25fc3RyaW5nKG9iaiwga2V5Lm5hdGl2ZS5ieXRlcykKICAgIHN3YXAKICAgIGV4dHJhY3QgMiAwCiAgICBqc29uX3JlZiBKU09OU3RyaW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMjctMTAyOAogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IHZhbHVlLmxlbmd0aCA8PSBjb25zdC5QQUdFX1NJWkUsIGVyci5FWENFRURTX1BBR0VfU0laRQogICAgZHVwCiAgICBsZW4KICAgIGludGMgNCAvLyAxMDA3CiAgICA8PQogICAgYXNzZXJ0IC8vIFBheWxvYWQgZXhjZWVkcyBwYWdlIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAwMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX3VpbnQ2NF9ieV9rZXk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMzIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDUwLTEwNTEKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA1MwogICAgLy8gb2JqID0gc2VsZi5fZ2V0X3Nob3J0X21ldGFkYXRhKGFzc2V0X2lkKQogICAgc3dhcAogICAgY2FsbHN1YiBfZ2V0X3Nob3J0X21ldGFkYXRhCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNTQKICAgIC8vIHZhbHVlID0gb3AuSnNvblJlZi5qc29uX3VpbnQ2NChvYmosIGtleS5uYXRpdmUuYnl0ZXMpCiAgICBzd2FwCiAgICBleHRyYWN0IDIgMAogICAganNvbl9yZWYgSlNPTlVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDU2CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQodmFsdWUpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMzIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9vYmplY3RfYnlfa2V5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDU4CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3Ni0xMDc3CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNzkKICAgIC8vIG9iaiA9IHNlbGYuX2dldF9zaG9ydF9tZXRhZGF0YShhc3NldF9pZCkKICAgIHN3YXAKICAgIGNhbGxzdWIgX2dldF9zaG9ydF9tZXRhZGF0YQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDgwCiAgICAvLyB2YWx1ZSA9IG9wLkpzb25SZWYuanNvbl9vYmplY3Qob2JqLCBrZXkubmF0aXZlLmJ5dGVzKQogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGpzb25fcmVmIEpTT05PYmplY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4Mi0xMDgzCiAgICAvLyAjIFBvc3Rjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgdmFsdWUubGVuZ3RoIDw9IGNvbnN0LlBBR0VfU0laRSwgZXJyLkVYQ0VFRFNfUEFHRV9TSVpFCiAgICBkdXAKICAgIGxlbgogICAgaW50YyA0IC8vIDEwMDcKICAgIDw9CiAgICBhc3NlcnQgLy8gUGF5bG9hZCBleGNlZWRzIHBhZ2Ugc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDU4CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2lzX2FzYV9tYW5hZ2VyKGFzYTogdWludDY0KSAtPiB1aW50NjQ6Cl9pc19hc2FfbWFuYWdlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTEKICAgIC8vIGRlZiBfaXNfYXNhX21hbmFnZXIoc2VsZiwgYXNhOiBBc3NldCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MgogICAgLy8gcmV0dXJuIFR4bi5zZW5kZXIgPT0gYXNhLm1hbmFnZXIKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgID09CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2dldF9tZXRhZGF0YV9zaXplKGFzYTogdWludDY0KSAtPiB1aW50NjQ6Cl9nZXRfbWV0YWRhdGFfc2l6ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI1CiAgICAvLyBkZWYgX2dldF9tZXRhZGF0YV9zaXplKHNlbGYsIGFzYTogQXNzZXQpIC0+IFVJbnQ2NDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmxlbmd0aCAtIGNvbnN0Lk1FVEFEQVRBX0hFQURFUl9TSVpFCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGJveF9sZW4KICAgIGFzc2VydCAvLyBjaGVjayBCb3ggZXhpc3RzCiAgICBwdXNoaW50IDQyCiAgICAtCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2FwcGVuZF9wYXlsb2FkKGFzYTogdWludDY0LCBwYXlsb2FkOiBieXRlcykgLT4gdm9pZDoKX2FwcGVuZF9wYXlsb2FkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjgKICAgIC8vIGRlZiBfYXBwZW5kX3BheWxvYWQoc2VsZiwgYXNhOiBBc3NldCwgcGF5bG9hZDogQnl0ZXMpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI5CiAgICAvLyBvbGRfYXNzZXRfbWV0YWRhdGFfYm94X3NpemUgPSBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmxlbmd0aAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGFzc2VydCAvLyBjaGVjayBCb3ggZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMQogICAgLy8gbmV3X3NpemU9b2xkX2Fzc2V0X21ldGFkYXRhX2JveF9zaXplICsgcGF5bG9hZC5sZW5ndGgKICAgIGZyYW1lX2RpZyAtMQogICAgbGVuCiAgICBkaWcgMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzAtMTMyCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlc2l6ZSgKICAgIC8vICAgICBuZXdfc2l6ZT1vbGRfYXNzZXRfbWV0YWRhdGFfYm94X3NpemUgKyBwYXlsb2FkLmxlbmd0aAogICAgLy8gKQogICAgZGlnIDIKICAgIHN3YXAKICAgIGJveF9yZXNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMzLTEzNQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PW9sZF9hc3NldF9tZXRhZGF0YV9ib3hfc2l6ZSwgdmFsdWU9cGF5bG9hZAogICAgLy8gKQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfcmVwbGFjZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9zZXRfbWV0YWRhdGFfcGF5bG9hZChhc2E6IHVpbnQ2NCwgbWV0YWRhdGFfc2l6ZTogdWludDY0LCBwYXlsb2FkOiBieXRlcykgLT4gdm9pZDoKX3NldF9tZXRhZGF0YV9wYXlsb2FkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTMtMTU1CiAgICAvLyBkZWYgX3NldF9tZXRhZGF0YV9wYXlsb2FkKAogICAgLy8gICAgIHNlbGYsIGFzYTogQXNzZXQsIG1ldGFkYXRhX3NpemU6IFVJbnQ2NCwgcGF5bG9hZDogQnl0ZXMKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDMgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTYtMTU3CiAgICAvLyAjIEVyYXNlIGV4aXN0aW5nIG1ldGFkYXRhIHBheWxvYWQKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVzaXplKG5ld19zaXplPVVJbnQ2NChjb25zdC5NRVRBREFUQV9IRUFERVJfU0laRSkpCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0b2IKICAgIGR1cAogICAgcHVzaGludCA0MgogICAgYm94X3Jlc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTktMTYwCiAgICAvLyAjIEFwcGVuZCBwcm92aWRlZCBwYXlsb2FkCiAgICAvLyBzZWxmLl9hcHBlbmRfcGF5bG9hZChhc2EsIHBheWxvYWQpCiAgICBmcmFtZV9kaWcgLTMKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfYXBwZW5kX3BheWxvYWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTYyLTE2MwogICAgLy8gIyBBcHBlbmQgc3RhZ2VkIGV4dHJhIHBheWxvYWQgKGluIHRoZSBzYW1lIEdyb3VwLCBpZiBhbnkpCiAgICAvLyBncm91cF9zaXplID0gR2xvYmFsLmdyb3VwX3NpemUKICAgIGdsb2JhbCBHcm91cFNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTY0CiAgICAvLyBncm91cF9pbmRleCA9IFR4bi5ncm91cF9pbmRleAogICAgdHhuIEdyb3VwSW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTY1CiAgICAvLyBmb3IgaWR4IGluIHVyYW5nZShncm91cF9pbmRleCArIDEsIGdyb3VwX3NpemUpOgogICAgaW50Y18wIC8vIDEKICAgICsKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9mb3JfaGVhZGVyQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2NQogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoZ3JvdXBfaW5kZXggKyAxLCBncm91cF9zaXplKToKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9kaWcgMQogICAgPAogICAgYnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2FmdGVyX2ZvckA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzOQogICAgLy8gdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgZnJhbWVfZGlnIDIKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTM5LTE0NAogICAgLy8gdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gYW5kIHR4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIC8vIGFuZCB0eG4ub25fY29tcGxldGlvbiA9PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9BUkdfTUVUSE9EX1NFTEVDVE9SKQogICAgLy8gPT0gYXJjNC5hcmM0X3NpZ25hdHVyZShBc2FNZXRhZGF0YVJlZ2lzdHJ5SW50ZXJmYWNlLmFyYzg5X2V4dHJhX3BheWxvYWQpCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX0FTU0VUX0lEKSA9PSBvcC5pdG9iKGFzYS5pZCkKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX2ZhbHNlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0MAogICAgLy8gYW5kIHR4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIGZyYW1lX2RpZyAyCiAgICBndHhucyBBcHBsaWNhdGlvbklECiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzOS0xNDQKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDEKICAgIC8vIGFuZCB0eG4ub25fY29tcGxldGlvbiA9PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIGZyYW1lX2RpZyAyCiAgICBndHhucyBPbkNvbXBsZXRpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTM5LTE0NAogICAgLy8gdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gYW5kIHR4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIC8vIGFuZCB0eG4ub25fY29tcGxldGlvbiA9PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9BUkdfTUVUSE9EX1NFTEVDVE9SKQogICAgLy8gPT0gYXJjNC5hcmM0X3NpZ25hdHVyZShBc2FNZXRhZGF0YVJlZ2lzdHJ5SW50ZXJmYWNlLmFyYzg5X2V4dHJhX3BheWxvYWQpCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX0FTU0VUX0lEKSA9PSBvcC5pdG9iKGFzYS5pZCkKICAgIGJueiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDIKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9BUkdfTUVUSE9EX1NFTEVDVE9SKQogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMSAvLyAwCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDMKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgYnl0ZWNfMyAvLyBtZXRob2QgImFyYzg5X2V4dHJhX3BheWxvYWQodWludDY0LGJ5dGVbXSl2b2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDItMTQzCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTM5LTE0NAogICAgLy8gdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gYW5kIHR4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIC8vIGFuZCB0eG4ub25fY29tcGxldGlvbiA9PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9BUkdfTUVUSE9EX1NFTEVDVE9SKQogICAgLy8gPT0gYXJjNC5hcmM0X3NpZ25hdHVyZShBc2FNZXRhZGF0YVJlZ2lzdHJ5SW50ZXJmYWNlLmFyYzg5X2V4dHJhX3BheWxvYWQpCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX0FTU0VUX0lEKSA9PSBvcC5pdG9iKGFzYS5pZCkKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX2ZhbHNlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0NAogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBmcmFtZV9kaWcgMgogICAgaW50Y18wIC8vIDEKICAgIGd0eG5zYXMgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgMAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTM5LTE0NAogICAgLy8gdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gYW5kIHR4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIC8vIGFuZCB0eG4ub25fY29tcGxldGlvbiA9PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9BUkdfTUVUSE9EX1NFTEVDVE9SKQogICAgLy8gPT0gYXJjNC5hcmM0X3NpZ25hdHVyZShBc2FNZXRhZGF0YVJlZ2lzdHJ5SW50ZXJmYWNlLmFyYzg5X2V4dHJhX3BheWxvYWQpCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX0FTU0VUX0lEKSA9PSBvcC5pdG9iKGFzYS5pZCkKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX2ZhbHNlQDE1CiAgICBpbnRjXzAgLy8gMQoKX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfbWVyZ2VAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2NwogICAgLy8gaWYgc2VsZi5faXNfZXh0cmFfcGF5bG9hZF90eG4oYXNhLCB0eG4pOgogICAgYnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDgtMTUxCiAgICAvLyAjIFRoaXMgc3Vicm91dGluZSBhc3N1bWVzIHR4biBpcyBhbHJlYWR5IHZhbGlkYXRlZCBhcyBhbiBleHRyYSBwYXlsb2FkIHR4bgogICAgLy8gcmV0dXJuIGFyYzQuRHluYW1pY0J5dGVzLmZyb21fYnl0ZXMoCiAgICAvLyAgICAgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX1BBWUxPQUQpCiAgICAvLyApLm5hdGl2ZQogICAgZnJhbWVfZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTUwCiAgICAvLyB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDODlfRVhUUkFfUEFZTE9BRF9BUkdfUEFZTE9BRCkKICAgIGludGNfMyAvLyAyCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDgtMTUxCiAgICAvLyAjIFRoaXMgc3Vicm91dGluZSBhc3N1bWVzIHR4biBpcyBhbHJlYWR5IHZhbGlkYXRlZCBhcyBhbiBleHRyYSBwYXlsb2FkIHR4bgogICAgLy8gcmV0dXJuIGFyYzQuRHluYW1pY0J5dGVzLmZyb21fYnl0ZXMoCiAgICAvLyAgICAgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX1BBWUxPQUQpCiAgICAvLyApLm5hdGl2ZQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTcwCiAgICAvLyBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpICsgZXh0cmFfcGF5bG9hZC5sZW5ndGggPD0gbWV0YWRhdGFfc2l6ZQogICAgZnJhbWVfZGlnIC0zCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgZGlnIDEKICAgIGxlbgogICAgKwogICAgZnJhbWVfZGlnIC0yCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNjktMTcxCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkgKyBleHRyYV9wYXlsb2FkLmxlbmd0aCA8PSBtZXRhZGF0YV9zaXplCiAgICAvLyApLCBlcnIuUEFZTE9BRF9PVkVSRkxPVwogICAgYXNzZXJ0IC8vIFBheWxvYWQgb3ZlcmZsb3csIGV4Y2VlZHMgbWV0YWRhdGEgc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNzIKICAgIC8vIHNlbGYuX2FwcGVuZF9wYXlsb2FkKGFzYSwgZXh0cmFfcGF5bG9hZCkKICAgIGZyYW1lX2RpZyAtMwogICAgc3dhcAogICAgY2FsbHN1YiBfYXBwZW5kX3BheWxvYWQKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2NQogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoZ3JvdXBfaW5kZXggKyAxLCBncm91cF9zaXplKToKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAyCiAgICBiIF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9mb3JfaGVhZGVyQDEKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX2ZhbHNlQDE1OgogICAgaW50Y18xIC8vIDAKICAgIGIgX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfbWVyZ2VAMTYKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9hZnRlcl9mb3JANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTczCiAgICAvLyBhc3NlcnQgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSA9PSBtZXRhZGF0YV9zaXplLCBlcnIuTUVUQURBVEFfU0laRV9NSVNNQVRDSAogICAgZnJhbWVfZGlnIC0zCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgZnJhbWVfZGlnIC0yCiAgICA9PQogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIHNpemUgbWlzbWF0Y2gsIG11c3QgYmUgZXhhY3RseSBlcXVhbCB0byBkZWNsYXJlZCBzaXplCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2dldF9tZXRhZGF0YV9wYWdlKGFzYTogdWludDY0LCBwYWdlX2luZGV4OiB1aW50NjQpIC0+IGJ5dGVzOgpfZ2V0X21ldGFkYXRhX3BhZ2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4MwogICAgLy8gZGVmIF9nZXRfbWV0YWRhdGFfcGFnZShzZWxmLCBhc2E6IEFzc2V0LCBwYWdlX2luZGV4OiBVSW50NjQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE5MQogICAgLy8gbiA9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTMKICAgIC8vIHN0YXJ0ID0gcGFnZV9pbmRleCAqIHBzCiAgICBmcmFtZV9kaWcgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTkwCiAgICAvLyBwcyA9IFVJbnQ2NChjb25zdC5QQUdFX1NJWkUpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTMKICAgIC8vIHN0YXJ0ID0gcGFnZV9pbmRleCAqIHBzCiAgICAqCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTQKICAgIC8vIGlmIHN0YXJ0ID49IG46CiAgICA+PQogICAgYnogX2dldF9tZXRhZGF0YV9wYWdlX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTUtMTk2CiAgICAvLyAjIE91dC1vZi1yYW5nZSBwYWdlIChpbmNsdWRpbmcgZW1wdHkgbWV0YWRhdGEgd2l0aCBwYWdlX2luZGV4ID4gMCkKICAgIC8vIHJldHVybiBCeXRlcyhiIiIpCiAgICBieXRlY18xIC8vIDB4CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKX2dldF9tZXRhZGF0YV9wYWdlX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTk4CiAgICAvLyByZW1haW5pbmcgPSBuIC0gc3RhcnQKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBjb3ZlciAyCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE5MAogICAgLy8gcHMgPSBVSW50NjQoY29uc3QuUEFHRV9TSVpFKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjE2CiAgICAvLyByZXR1cm4gYSBpZiBhIDwgYiBlbHNlIGIKICAgIGRpZyAxCiAgICA8CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE5MAogICAgLy8gcHMgPSBVSW50NjQoY29uc3QuUEFHRV9TSVpFKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjE2CiAgICAvLyByZXR1cm4gYSBpZiBhIDwgYiBlbHNlIGIKICAgIHN3YXAKICAgIHNlbGVjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMDEKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjAyCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBzdGFydCwgbGVuZ3RoPWxlbmd0aAogICAgcHVzaGludCA0MgogICAgdW5jb3ZlciAzCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwMS0yMDMKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgc3RhcnQsIGxlbmd0aD1sZW5ndGgKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9nZXRfc2hvcnRfbWV0YWRhdGEoYXNhOiB1aW50NjQpIC0+IGJ5dGVzOgpfZ2V0X3Nob3J0X21ldGFkYXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTAKICAgIC8vIGRlZiBfZ2V0X3Nob3J0X21ldGFkYXRhKHNlbGYsIGFzYTogQXNzZXQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjQKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg0LTg3CiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTEKICAgIC8vIGFzc2VydCBzZWxmLl9pc19zaG9ydChhc2EpLCBlcnIuTUVUQURBVEFfTk9UX1NIT1JUCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgbm90IHNob3J0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxMgogICAgLy8gcmV0dXJuIHNlbGYuX2dldF9zbGljZShhc2EsIFVJbnQ2NCgwKSwgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjA3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBvZmZzZXQsIGxlbmd0aD1zaXplCiAgICBwdXNoaW50IDQyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwNi0yMDgKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LCBsZW5ndGg9c2l6ZQogICAgLy8gKQogICAgc3dhcAogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjEyCiAgICAvLyByZXR1cm4gc2VsZi5fZ2V0X3NsaWNlKGFzYSwgVUludDY0KDApLCBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpKQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9pZGVudGlmeV9tZXRhZGF0YShhc2E6IHVpbnQ2NCkgLT4gdm9pZDoKX2lkZW50aWZ5X21ldGFkYXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTQKICAgIC8vIGRlZiBfaWRlbnRpZnlfbWV0YWRhdGEoc2VsZiwgYXNhOiBBc3NldCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTUKICAgIC8vIG1ldGFkYXRhX3NpemUgPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjQKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTgKICAgIC8vIHJldHVybiBtZXRhZGF0YV9zaXplIDw9IGNvbnN0LlNIT1JUX01FVEFEQVRBX1NJWkUKICAgIHVuY292ZXIgMgogICAgcHVzaGludCA0MDk2CiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTgKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxNi0yMjAKICAgIC8vIGlkZW50aWZpZXJzID0gb3Auc2V0Yml0X2J5dGVzKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIC8vICAgICBzZWxmLl9pc19zaG9ydF9tZXRhZGF0YV9zaXplKG1ldGFkYXRhX3NpemUpLAogICAgLy8gKQogICAgc3dhcAogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY5CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsIHZhbHVlPWlkZW50aWZpZXJzCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2OC03MAogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywgdmFsdWU9aWRlbnRpZmllcnMKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NvbXB1dGVfaGVhZGVyX2hhc2goYXNhOiB1aW50NjQpIC0+IGJ5dGVzOgpfY29tcHV0ZV9oZWFkZXJfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjI5CiAgICAvLyBkZWYgX2NvbXB1dGVfaGVhZGVyX2hhc2goc2VsZiwgYXNhOiBBc3NldCkgLT4gQnl0ZXM6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjMyCiAgICAvLyBhc3NldF9pZCA9IG9wLml0b2IoYXNhLmlkKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjQKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjM2CiAgICAvLyB1aW50PXNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSksCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToxMQogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMzAtMjMxCiAgICAvLyAjIGhoID0gU0hBIC0gNTEyIC8gMjU2KCJhcmMwMDg5L2hlYWRlciIgfHwgQXNzZXQgSUQgfHwgTWV0YWRhdGEgSWRlbnRpZmllcnMgfHwgTWV0YWRhdGEgRmxhZ3MgfHwgTWV0YWRhdGEgU2l6ZSkKICAgIC8vIGRvbWFpbiA9IEJ5dGVzKGNvbnN0LkhBU0hfRE9NQUlOX0hFQURFUikKICAgIHB1c2hieXRlcyAweDYxNzI2MzMwMzAzODM5MmY2ODY1NjE2NDY1NzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjQwCiAgICAvLyBkb21haW4gKyBhc3NldF9pZCArIG1ldGFkYXRhX2lkZW50aWZpZXJzICsgbWV0YWRhdGFfZmxhZ3MgKyBtZXRhZGF0YV9zaXplCiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjM5LTI0MQogICAgLy8gcmV0dXJuIG9wLnNoYTUxMl8yNTYoCiAgICAvLyAgICAgZG9tYWluICsgYXNzZXRfaWQgKyBtZXRhZGF0YV9pZGVudGlmaWVycyArIG1ldGFkYXRhX2ZsYWdzICsgbWV0YWRhdGFfc2l6ZQogICAgLy8gKQogICAgc2hhNTEyXzI1NgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9jb21wdXRlX3BhZ2VfaGFzaChhc2E6IHVpbnQ2NCwgcGFnZV9pbmRleDogdWludDY0LCBwYWdlX2NvbnRlbnQ6IGJ5dGVzKSAtPiBieXRlczoKX2NvbXB1dGVfcGFnZV9oYXNoOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNDMtMjQ1CiAgICAvLyBkZWYgX2NvbXB1dGVfcGFnZV9oYXNoKAogICAgLy8gICAgIHNlbGYsIGFzYTogQXNzZXQsIHBhZ2VfaW5kZXg6IFVJbnQ2NCwgcGFnZV9jb250ZW50OiBCeXRlcwogICAgLy8gKSAtPiBCeXRlczoKICAgIHByb3RvIDMgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNDgKICAgIC8vIGFzc2V0X2lkID0gb3AuaXRvYihhc2EuaWQpCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjExCiAgICAvLyByZXR1cm4gb3AuZXh0cmFjdChvcC5pdG9iKHVpbnQpLCBzdGFydCwgc2l6ZSkKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjUxCiAgICAvLyB1aW50PXBhZ2VfY29udGVudC5sZW5ndGgsIHNpemU9VUludDY0KGNvbnN0LlVJTlQxNl9TSVpFKQogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjExCiAgICAvLyByZXR1cm4gb3AuZXh0cmFjdChvcC5pdG9iKHVpbnQpLCBzdGFydCwgc2l6ZSkKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0Ni0yNDcKICAgIC8vICMgcGhbaV0gPSBTSEEtNTEyLzI1NigiYXJjMDA4OS9wYWdlIiB8fCBBc3NldCBJRCB8fCBQYWdlIEluZGV4IHx8IFBhZ2UgU2l6ZSB8fCBQYWdlIENvbnRlbnQpCiAgICAvLyBkb21haW4gPSBCeXRlcyhjb25zdC5IQVNIX0RPTUFJTl9QQUdFKQogICAgcHVzaGJ5dGVzIDB4NjE3MjYzMzAzMDM4MzkyZjcwNjE2NzY1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI1MwogICAgLy8gcmV0dXJuIG9wLnNoYTUxMl8yNTYoZG9tYWluICsgYXNzZXRfaWQgKyBwYWdlX2lkeCArIHBhZ2Vfc2l6ZSArIHBhZ2VfY29udGVudCkKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgc2hhNTEyXzI1NgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9jb21wdXRlX21ldGFkYXRhX2hhc2goYXNhOiB1aW50NjQpIC0+IGJ5dGVzOgpfY29tcHV0ZV9tZXRhZGF0YV9oYXNoOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNTUKICAgIC8vIGRlZiBfY29tcHV0ZV9tZXRhZGF0YV9oYXNoKHNlbGYsIGFzYTogQXNzZXQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMSAxCiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI1OQogICAgLy8gaGggPSBzZWxmLl9jb21wdXRlX2hlYWRlcl9oYXNoKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfY29tcHV0ZV9oZWFkZXJfaGFzaAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODAKICAgIC8vIG4gPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyMS0yMgogICAgLy8gIyBBc3N1bWVzIGQgPj0gMQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgaW50YyA1IC8vIDEwMDYKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgxCiAgICAvLyByZXR1cm4gY2VpbF9kaXYobnVtPW4sIGRlbj1VSW50NjQoY29uc3QuUEFHRV9TSVpFKSkKICAgIGludGMgNCAvLyAxMDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyMS0yMgogICAgLy8gIyBBc3N1bWVzIGQgPj0gMQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2MQogICAgLy8gY29uY2F0ZW5hdGVkX3BoID0gQnl0ZXMoKQogICAgYnl0ZWNfMSAvLyAweAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjIKICAgIC8vIGlmIHRvdGFsX3BhZ2VzID4gMDoKICAgIGJ6IF9jb21wdXRlX21ldGFkYXRhX2hhc2hfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2MwogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKDAsIHRvdGFsX3BhZ2VzKToKICAgIGludGNfMSAvLyAwCiAgICBmcmFtZV9idXJ5IDAKCl9jb21wdXRlX21ldGFkYXRhX2hhc2hfZm9yX2hlYWRlckAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjMKICAgIC8vIGZvciBwYWdlX2luZGV4IGluIHVyYW5nZSgwLCB0b3RhbF9wYWdlcyk6CiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDIKICAgIDwKICAgIGJ6IF9jb21wdXRlX21ldGFkYXRhX2hhc2hfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2NAogICAgLy8gcGFnZV9jb250ZW50ID0gc2VsZi5fZ2V0X21ldGFkYXRhX3BhZ2UoYXNhLCBwYWdlX2luZGV4KQogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfcGFnZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjUKICAgIC8vIHBoID0gc2VsZi5fY29tcHV0ZV9wYWdlX2hhc2goYXNhLCBwYWdlX2luZGV4LCBwYWdlX2NvbnRlbnQpCiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgX2NvbXB1dGVfcGFnZV9oYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2NgogICAgLy8gY29uY2F0ZW5hdGVkX3BoICs9IHBoCiAgICBmcmFtZV9kaWcgMwogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjYzCiAgICAvLyBmb3IgcGFnZV9pbmRleCBpbiB1cmFuZ2UoMCwgdG90YWxfcGFnZXMpOgogICAgaW50Y18wIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMAogICAgYiBfY29tcHV0ZV9tZXRhZGF0YV9oYXNoX2Zvcl9oZWFkZXJAMgoKX2NvbXB1dGVfbWV0YWRhdGFfaGFzaF9hZnRlcl9pZl9lbHNlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI1Ni0yNTgKICAgIC8vICMgYW0gPSBTSEEtNTEyLzI1NigiYXJjMDA4OS9hbSIgfHwgaGggfHwgcGhbMF0gfHwgcGhbMV0gfHwgLi4uIHx8IHBoW3RvdGFsX3BhZ2VzIC0gMV0pIG9yCiAgICAvLyAjIGFtID0gU0hBLTUxMi8yNTYoImFyYzAwODkvYW0iIHx8IGhoKSwgaWYgbm8gcGFnZXMKICAgIC8vIGRvbWFpbiA9IEJ5dGVzKGNvbnN0LkhBU0hfRE9NQUlOX01FVEFEQVRBKQogICAgcHVzaGJ5dGVzIDB4NjE3MjYzMzAzMDM4MzkyZjYxNmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjY3CiAgICAvLyByZXR1cm4gb3Auc2hhNTEyXzI1Nihkb21haW4gKyBoaCArIGNvbmNhdGVuYXRlZF9waCkKICAgIGZyYW1lX2RpZyAxCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAzCiAgICBjb25jYXQKICAgIHNoYTUxMl8yNTYKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnMoYXNhOiB1aW50NjQsIG1ldGFkYXRhX3NpemU6IHVpbnQ2NCkgLT4gdm9pZDoKX2NoZWNrX2Jhc2VfcHJlY29uZGl0aW9uczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjY5CiAgICAvLyBkZWYgX2NoZWNrX2Jhc2VfcHJlY29uZGl0aW9ucyhzZWxmLCBhc2E6IEFzc2V0LCBtZXRhZGF0YV9zaXplOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGZyYW1lX2RpZyAtMgogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNzAKICAgIC8vIGFzc2VydCBzZWxmLl9hc2FfZXhpc3RzKGFzYSksIGVyci5BU0FfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gVGhlIHNwZWNpZmllZCBBU0EgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjcxCiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXNhX21hbmFnZXIoYXNhKSwgZXJyLlVOQVVUSE9SSVpFRAogICAgZnJhbWVfZGlnIC0yCiAgICBjYWxsc3ViIF9pc19hc2FfbWFuYWdlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZCwgbXVzdCBiZSB0aGUgQXNzZXQgTWFuYWdlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NQogICAgLy8gcmV0dXJuIG1ldGFkYXRhX3NpemUgPD0gY29uc3QuTUFYX01FVEFEQVRBX1NJWkUKICAgIGZyYW1lX2RpZyAtMQogICAgaW50YyA2IC8vIDMwNTA3CiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNzItMjc0CiAgICAvLyBhc3NlcnQgc2VsZi5faXNfdmFsaWRfbWF4X21ldGFkYXRhX3NpemUoCiAgICAvLyAgICAgbWV0YWRhdGFfc2l6ZQogICAgLy8gKSwgZXJyLkVYQ0VFRFNfTUFYX01FVEFEQVRBX1NJWkUKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1ldGFkYXRhIHNpemUsIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHNpemUKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMoYXNhOiB1aW50NjQsIG1ldGFkYXRhX3NpemU6IHVpbnQ2NCkgLT4gdm9pZDoKX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNzYKICAgIC8vIGRlZiBfY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMoc2VsZiwgYXNhOiBBc3NldCwgbWV0YWRhdGFfc2l6ZTogVUludDY0KSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3NwogICAgLy8gc2VsZi5fY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zKGFzYSwgbWV0YWRhdGFfc2l6ZSkKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNzgKICAgIC8vIGFzc2VydCBzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNhKSwgZXJyLkFTU0VUX01FVEFEQVRBX05PVF9FWElTVAogICAgYXNzZXJ0IC8vIEFzc2V0IE1ldGFkYXRhIGRvZXMgbm90IGV4aXN0IGZvciB0aGUgc3BlY2lmaWVkIEFTQQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MgogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwLTkzCiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjc5CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuX2lzX2ltbXV0YWJsZShhc2EpLCBlcnIuSU1NVVRBQkxFCiAgICAhCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgaW1tdXRhYmxlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzYTogdWludDY0KSAtPiB2b2lkOgpfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI4MQogICAgLy8gZGVmIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhzZWxmLCBhc2E6IEFzc2V0KSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1CiAgICAvLyBfY3JlYXRvciwgZXhpc3RzID0gb3AuQXNzZXRQYXJhbXNHZXQuYXNzZXRfY3JlYXRvcihhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjgyCiAgICAvLyBhc3NlcnQgc2VsZi5fYXNhX2V4aXN0cyhhc2EpLCBlcnIuQVNBX05PVF9FWElTVAogICAgYXNzZXJ0IC8vIFRoZSBzcGVjaWZpZWQgQVNBIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ5CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI4MwogICAgLy8gYXNzZXJ0IHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc2EpLCBlcnIuQVNTRVRfTUVUQURBVEFfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gQXNzZXQgTWV0YWRhdGEgZG9lcyBub3QgZXhpc3QgZm9yIHRoZSBzcGVjaWZpZWQgQVNBCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMoYXNhOiB1aW50NjQpIC0+IHZvaWQ6Cl9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODUKICAgIC8vIGRlZiBfY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhzZWxmLCBhc2E6IEFzc2V0KSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI4NgogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MgogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwLTkzCiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjg3CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuX2lzX2ltbXV0YWJsZShhc2EpLCBlcnIuSU1NVVRBQkxFCiAgICAhCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgaW1tdXRhYmxlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI4OAogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FzYV9tYW5hZ2VyKGFzYSksIGVyci5VTkFVVEhPUklaRUQKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfaXNfYXNhX21hbmFnZXIKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQsIG11c3QgYmUgdGhlIEFzc2V0IE1hbmFnZXIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQoYXNhOiB1aW50NjQpIC0+IHZvaWQ6Cl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjkwCiAgICAvLyBkZWYgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KHNlbGYsIGFzYTogQXNzZXQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjkxCiAgICAvLyBzZWxmLl9pZGVudGlmeV9tZXRhZGF0YShhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2lkZW50aWZ5X21ldGFkYXRhCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI5Mi0yOTMKICAgIC8vICMg4pqg77iPIFRoZSBzdWJyb3V0aW5lIGFzc3VtZXMgdGhhdCBNZXRhZGF0YSBGbGFncyBoYXZlIGFscmVhZHkgYmVlbiBzZXQKICAgIC8vIG1ldGFkYXRhX2hhc2ggPSBzZWxmLl9jb21wdXRlX21ldGFkYXRhX2hhc2goYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9jb21wdXRlX21ldGFkYXRhX2hhc2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3LTEwOQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCB2YWx1ZT1tZXRhZGF0YV9oYXNoCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgdmFsdWU9bWV0YWRhdGFfaGFzaAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3LTEwOQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCB2YWx1ZT1tZXRhZGF0YV9oYXNoCiAgICAvLyApCiAgICBkaWcgMwogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjk1CiAgICAvLyBzZWxmLl9zZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc2EsIEdsb2JhbC5yb3VuZCkKICAgIGdsb2JhbCBSb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjIKICAgIC8vIHZhbHVlPW9wLml0b2IobGFzdF9tb2RpZmllZF9yb3VuZCksCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMC0xMjMKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICB2YWx1ZT1vcC5pdG9iKGxhc3RfbW9kaWZpZWRfcm91bmQpLAogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIxCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIHB1c2hpbnQgMzQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIwLTEyMwogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgIHZhbHVlPW9wLml0b2IobGFzdF9tb2RpZmllZF9yb3VuZCksCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI5OQogICAgLy8gcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIGdsb2JhbCBSb3VuZAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMDAKICAgIC8vIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMwMQogICAgLy8gZmxhZ3M9YXJjNC5CeXRlKG9wLmJ0b2koc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSkpKSwKICAgIGJ0b2kKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY0CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg2CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NC04NwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzAyCiAgICAvLyBpc19zaG9ydD1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNhKSksCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyOTctMzA0CiAgICAvLyBhYmkuQXJjODlNZXRhZGF0YVVwZGF0ZWQoCiAgICAvLyAgICAgYXNzZXRfaWQ9YXJjNC5VSW50NjQoYXNhLmlkKSwKICAgIC8vICAgICByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICAvLyAgICAgZmxhZ3M9YXJjNC5CeXRlKG9wLmJ0b2koc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSkpKSwKICAgIC8vICAgICBpc19zaG9ydD1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNhKSksCiAgICAvLyAgICAgaGFzaD1hYmkuSGFzaC5mcm9tX2J5dGVzKG1ldGFkYXRhX2hhc2gpLAogICAgLy8gKQogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyOTYtMzA1CiAgICAvLyBhcmM0LmVtaXQoCiAgICAvLyAgICAgYWJpLkFyYzg5TWV0YWRhdGFVcGRhdGVkKAogICAgLy8gICAgICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc2EuaWQpLAogICAgLy8gICAgICAgICByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgICAgICB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgICAgICBmbGFncz1hcmM0LkJ5dGUob3AuYnRvaShzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSkpLAogICAgLy8gICAgICAgICBpc19zaG9ydD1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNhKSksCiAgICAvLyAgICAgICAgIGhhc2g9YWJpLkhhc2guZnJvbV9ieXRlcyhtZXRhZGF0YV9oYXNoKSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBieXRlYyA1IC8vIG1ldGhvZCAiQXJjODlNZXRhZGF0YVVwZGF0ZWQodWludDY0LHVpbnQ2NCx1aW50NjQsYnl0ZSxib29sLGJ5dGVbMzJdKSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICByZXRzdWIK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMQogICAgcmV0dXJuCg=="}, "sourceInfo": {"approval": {"pcOffsetMethod": "cblocks", "sourceInfo": [{"pc": [330], "errorMessage": "Asset Metadata already exists for the specified ASA"}, {"pc": [1079, 1220, 2743, 2768], "errorMessage": "Asset Metadata does not exist for the specified ASA"}, {"pc": [670], "errorMessage": "Invalid ARC-89 URI"}, {"pc": [686, 953], "errorMessage": "Invalid MBR Delta amount"}, {"pc": [337, 906], "errorMessage": "Invalid MBR Delta receiver, must be the ASA Metadata Registry"}, {"pc": [1457, 2724], "errorMessage": "Invalid Metadata size, exceeds maximum allowed size"}, {"pc": [898], "errorMessage": "Invalid Metadata size, must be larger than the current size"}, {"pc": [751], "errorMessage": "Invalid Metadata size, must be smaller than or equal to the current size"}, {"pc": [1264, 1354], "errorMessage": "Invalid flag index"}, {"pc": [1845, 1901, 2046], "errorMessage": "Invalid page index"}, {"pc": [2030], "errorMessage": "Metadata is empty"}, {"pc": [1094, 2750, 2787], "errorMessage": "Metadata is immutable"}, {"pc": [2474], "errorMessage": "Metadata is not short"}, {"pc": [784, 939, 2404], "errorMessage": "Metadata size mismatch, must be exactly equal to declared size"}, {"pc": [465], "errorMessage": "Must be flagged as immutable"}, {"pc": [1944, 2126, 2219], "errorMessage": "Payload exceeds page size"}, {"pc": [2376], "errorMessage": "Payload overflow, exceeds metadata size"}, {"pc": [1026, 1957], "errorMessage": "Slice exceeds metadata range"}, {"pc": [247], "errorMessage": "The deployer address is not trusted"}, {"pc": [1214, 2712, 2761], "errorMessage": "The specified ASA does not exist"}, {"pc": [1100, 1224, 2718, 2793], "errorMessage": "Unauthorized, must be the Asset Manager"}, {"pc": [345, 675, 756, 789, 911, 944, 1105, 1114], "errorMessage": "account funded"}, {"pc": [419, 470, 652, 823, 1132, 1622, 2235], "errorMessage": "asset exists"}, {"pc": [2245, 2258], "errorMessage": "check Box exists"}, {"pc": [286, 726, 862, 985, 1202, 2098, 2147, 2191], "errorMessage": "invalid array length header"}, {"pc": [1252], "errorMessage": "invalid number of bytes for arc4.bool"}, {"pc": [293, 733, 869, 992, 1208, 2105, 2154, 2198], "errorMessage": "invalid number of bytes for arc4.dynamic_array<arc4.uint8>"}, {"pc": [280, 720, 856, 979, 1449, 1925, 1933], "errorMessage": "invalid number of bytes for arc4.uint16"}, {"pc": [260, 710, 847, 969, 1068, 1195, 1234, 1323, 1407, 1439, 1563, 1603, 1652, 1691, 1744, 1805, 1916, 1982, 2004, 2067, 2091, 2140, 2184], "errorMessage": "invalid number of bytes for arc4.uint64"}, {"pc": [272, 1244, 1333, 1817, 2013], "errorMessage": "invalid number of bytes for arc4.uint8"}, {"pc": [801, 1499, 1760, 1779, 2843], "errorMessage": "overflow"}, {"pc": [306, 879], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {"TRUSTED_DEPLOYER": {"type": "address"}}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class MbrDelta:
    """Struct for MbrDelta"""
    sign: int
    amount: int

@dataclasses.dataclass(frozen=True)
class MetadataExistence:
    """Struct for MetadataExistence"""
    asa_exists: bool
    metadata_exists: bool

@dataclasses.dataclass(frozen=True)
class MetadataHeader:
    """Struct for MetadataHeader"""
    identifiers: int
    flags: int
    hash: bytes
    last_modified_round: int

@dataclasses.dataclass(frozen=True)
class MutableFlag:
    """Struct for MutableFlag"""
    flag: bool
    last_modified_round: int

@dataclasses.dataclass(frozen=True)
class PaginatedMetadata:
    """Struct for PaginatedMetadata"""
    has_next_page: bool
    last_modified_round: int
    page_content: bytes

@dataclasses.dataclass(frozen=True)
class Pagination:
    """Struct for Pagination"""
    metadata_size: int
    page_size: int
    total_pages: int

@dataclasses.dataclass(frozen=True)
class RegistryParameters:
    """Struct for RegistryParameters"""
    header_size: int
    max_metadata_size: int
    short_metadata_size: int
    page_size: int
    first_payload_max_size: int
    extra_payload_max_size: int
    replace_payload_max_size: int
    flat_mbr: int
    byte_mbr: int


@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89CreateMetadataArgs:
    """Dataclass for arc89_create_metadata arguments"""
    asset_id: int
    flags: int
    metadata_size: int
    payload: bytes | str
    mbr_delta_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataArgs:
    """Dataclass for arc89_replace_metadata arguments"""
    asset_id: int
    metadata_size: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataLargerArgs:
    """Dataclass for arc89_replace_metadata_larger arguments"""
    asset_id: int
    metadata_size: int
    payload: bytes | str
    mbr_delta_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataSliceArgs:
    """Dataclass for arc89_replace_metadata_slice arguments"""
    asset_id: int
    offset: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata_slice(uint64,uint16,byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89DeleteMetadataArgs:
    """Dataclass for arc89_delete_metadata arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_delete_metadata(uint64)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ExtraPayloadArgs:
    """Dataclass for arc89_extra_payload arguments"""
    asset_id: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_extra_payload(uint64,byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetReversibleFlagArgs:
    """Dataclass for arc89_set_reversible_flag arguments"""
    asset_id: int
    flag: int
    value: bool

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_reversible_flag(uint64,uint8,bool)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetIrreversibleFlagArgs:
    """Dataclass for arc89_set_irreversible_flag arguments"""
    asset_id: int
    flag: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_irreversible_flag(uint64,uint8)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetImmutableArgs:
    """Dataclass for arc89_set_immutable arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_immutable(uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataMbrDeltaArgs:
    """Dataclass for arc89_get_metadata_mbr_delta arguments"""
    asset_id: int
    new_metadata_size: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89CheckMetadataExistsArgs:
    """Dataclass for arc89_check_metadata_exists arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_check_metadata_exists(uint64)(bool,bool)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89IsMetadataImmutableArgs:
    """Dataclass for arc89_is_metadata_immutable arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_is_metadata_immutable(uint64)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89IsMetadataShortArgs:
    """Dataclass for arc89_is_metadata_short arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_is_metadata_short(uint64)(bool,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHeaderArgs:
    """Dataclass for arc89_get_metadata_header arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataPaginationArgs:
    """Dataclass for arc89_get_metadata_pagination arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataArgs:
    """Dataclass for arc89_get_metadata arguments"""
    asset_id: int
    page: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataSliceArgs:
    """Dataclass for arc89_get_metadata_slice arguments"""
    asset_id: int
    offset: int
    size: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHeaderHashArgs:
    """Dataclass for arc89_get_metadata_header_hash arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_header_hash(uint64)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataPageHashArgs:
    """Dataclass for arc89_get_metadata_page_hash arguments"""
    asset_id: int
    page: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_page_hash(uint64,uint8)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHashArgs:
    """Dataclass for arc89_get_metadata_hash arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_hash(uint64)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataStringByKeyArgs:
    """Dataclass for arc89_get_metadata_string_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_string_by_key(uint64,string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataUint64ByKeyArgs:
    """Dataclass for arc89_get_metadata_uint64_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_uint64_by_key(uint64,string)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataObjectByKeyArgs:
    """Dataclass for arc89_get_metadata_object_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_object_by_key(uint64,string)string"


class AsaMetadataRegistryParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }))

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }))

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }))

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }))

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }))

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }))

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }))

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }))

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }))

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }))

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }))

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }))

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class AsaMetadataRegistryCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }))

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }))

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }))

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }))

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }))

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }))

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }))

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }))

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }))

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }))

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }))

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }))

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class AsaMetadataRegistrySend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[RegistryParameters]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(RegistryParameters, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[RegistryParameters], parsed_response)

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MetadataExistence]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MetadataExistence, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MetadataExistence], parsed_response)

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MutableFlag]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MutableFlag, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MutableFlag], parsed_response)

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MetadataHeader]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MetadataHeader, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MetadataHeader], parsed_response)

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[Pagination]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(Pagination, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[Pagination], parsed_response)

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[PaginatedMetadata]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(PaginatedMetadata, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[PaginatedMetadata], parsed_response)

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class AsaMetadataRegistryState:
    """Methods to access state for the current AsaMetadataRegistry app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def asset_metadata(self) -> "_MapState[int, bytes]":
        """Get values from the asset_metadata map in box state"""
        return _MapState(
            self.app_client.state.box,
            "asset_metadata",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class AsaMetadataRegistryClient:
    """Client for interacting with AsaMetadataRegistry smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = AsaMetadataRegistryParams(self.app_client)
        self.create_transaction = AsaMetadataRegistryCreateTransactionParams(self.app_client)
        self.send = AsaMetadataRegistrySend(self.app_client)
        self.state = AsaMetadataRegistryState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "AsaMetadataRegistryComposer":
        return AsaMetadataRegistryComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata_slice(uint64,uint16,byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_delete_metadata(uint64)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_extra_payload(uint64,byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_reversible_flag(uint64,uint8,bool)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_irreversible_flag(uint64,uint8)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_immutable(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> RegistryParameters | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_check_metadata_exists(uint64)(bool,bool)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MetadataExistence | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_is_metadata_immutable(uint64)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_is_metadata_short(uint64)(bool,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MutableFlag | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MetadataHeader | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> Pagination | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])"],
        return_value: algokit_utils.ABIReturn | None
    ) -> PaginatedMetadata | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_slice(uint64,uint16,uint16)byte[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_header_hash(uint64)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_page_hash(uint64,uint8)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_hash(uint64)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_string_by_key(uint64,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_uint64_by_key(uint64,string)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_object_by_key(uint64,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["extra_resources()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | MbrDelta | MetadataExistence | MetadataHeader | MutableFlag | None | PaginatedMetadata | Pagination | RegistryParameters | bool | bytes | int | str:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class AsaMetadataRegistryBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating AsaMetadataRegistry contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class AsaMetadataRegistryFactory(algokit_utils.TypedAppFactoryProtocol[AsaMetadataRegistryBareCallCreateParams, None, None]):
    """Factory for deploying and managing AsaMetadataRegistryClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = AsaMetadataRegistryFactoryParams(self.app_factory)
        self.create_transaction = AsaMetadataRegistryFactoryCreateTransaction(self.app_factory)
        self.send = AsaMetadataRegistryFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: AsaMetadataRegistryBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[AsaMetadataRegistryClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return AsaMetadataRegistryClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AsaMetadataRegistryClient:
        """Get an app client by creator address and name"""
        return AsaMetadataRegistryClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AsaMetadataRegistryClient:
        """Get an app client by app ID"""
        return AsaMetadataRegistryClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class AsaMetadataRegistryFactoryParams:
    """Parameters for creating transactions for AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactoryCreateParams(app_factory)
        self.update = AsaMetadataRegistryFactoryUpdateParams(app_factory)
        self.delete = AsaMetadataRegistryFactoryDeleteParams(app_factory)

class AsaMetadataRegistryFactoryCreateParams:
    """Parameters for 'create' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata_slice(uint64,uint16,byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_delete_metadata(uint64)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_extra_payload(uint64,byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_extra_payload(uint64,byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_reversible_flag(uint64,uint8,bool)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_irreversible_flag(uint64,uint8)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_irreversible_flag(uint64,uint8)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_immutable(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_immutable(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_registry_parameters(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_check_metadata_exists(uint64)(bool,bool) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_is_metadata_immutable(uint64)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_is_metadata_immutable(uint64)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_is_metadata_short(uint64)(bool,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata(uint64,uint8)(bool,uint64,byte[]) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_slice(uint64,uint16,uint16)byte[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_header_hash(uint64)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_page_hash(uint64,uint8)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_hash(uint64)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_hash(uint64)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_string_by_key(uint64,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_string_by_key(uint64,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_uint64_by_key(uint64,string)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_object_by_key(uint64,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_object_by_key(uint64,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def extra_resources(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the extra_resources()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "extra_resources()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class AsaMetadataRegistryFactoryUpdateParams:
    """Parameters for 'update' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class AsaMetadataRegistryFactoryDeleteParams:
    """Parameters for 'delete' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class AsaMetadataRegistryFactoryCreateTransaction:
    """Create transactions for AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactoryCreateTransactionCreate(app_factory)


class AsaMetadataRegistryFactoryCreateTransactionCreate:
    """Create new instances of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class AsaMetadataRegistryFactorySend:
    """Send calls to AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactorySendCreate(app_factory)


class AsaMetadataRegistryFactorySendCreate:
    """Send create calls to AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[AsaMetadataRegistryClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return AsaMetadataRegistryClient(result[0]), result[1]


class AsaMetadataRegistryComposer:
    """Composer for creating transaction groups for AsaMetadataRegistry contract calls"""

    def __init__(self, client: "AsaMetadataRegistryClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_create_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata_larger(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata_slice(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata_slice(uint64,uint16,byte[])void", v
            )
        )
        return self

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_delete_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_delete_metadata(uint64)(uint8,uint64)", v
            )
        )
        return self

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_extra_payload(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_extra_payload(uint64,byte[])void", v
            )
        )
        return self

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_reversible_flag(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_reversible_flag(uint64,uint8,bool)void", v
            )
        )
        return self

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_irreversible_flag(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_irreversible_flag(uint64,uint8)void", v
            )
        )
        return self

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_immutable(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_immutable(uint64)void", v
            )
        )
        return self

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_registry_parameters(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_mbr_delta(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)", v
            )
        )
        return self

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_check_metadata_exists(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_check_metadata_exists(uint64)(bool,bool)", v
            )
        )
        return self

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_is_metadata_immutable(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_is_metadata_immutable(uint64)bool", v
            )
        )
        return self

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_is_metadata_short(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_is_metadata_short(uint64)(bool,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_header(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)", v
            )
        )
        return self

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_pagination(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)", v
            )
        )
        return self

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])", v
            )
        )
        return self

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_slice(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]", v
            )
        )
        return self

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_header_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_header_hash(uint64)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_page_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_page_hash(uint64,uint8)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_hash(uint64)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_string_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_string_by_key(uint64,string)string", v
            )
        )
        return self

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_uint64_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_uint64_by_key(uint64,string)uint64", v
            )
        )
        return self

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_object_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_object_by_key(uint64,string)string", v
            )
        )
        return self

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.extra_resources(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "extra_resources()void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "AsaMetadataRegistryComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
