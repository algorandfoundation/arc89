# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to create the Asset Metadata for", "name": "asset_id"}, {"type": "byte", "desc": "The Metadata Flags. WARNING: if the MSB is True the Asset Metadata is IMMUTABLE", "name": "flags"}, {"type": "uint16", "desc": "The Metadata byte size to be created", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}, {"type": "pay", "desc": "Payment of the MBR Delta amount (microALGO) for the Asset Metadata Box creation", "name": "mbr_delta_payment"}], "name": "arc89_create_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Create Asset Metadata for an existing ASA, restricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Metadata byte size, must be less than or equal to the existing", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}], "name": "arc89_replace_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Replace mutable Metadata with a smaller or equal size payload for an existing ASA,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Metadata byte size, must be larger than the existing", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}, {"type": "pay", "desc": "Payment of the MBR Delta amount (microALGO) for the larger Asset Metadata Box replace", "name": "mbr_delta_payment"}], "name": "arc89_replace_metadata_larger", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Replace mutable Metadata with a larger size payload for an existing ASA,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata slice for", "name": "asset_id"}, {"type": "uint16", "desc": "The 0-based byte offset within the Metadata (body) bytes", "name": "offset"}, {"type": "byte[]", "desc": "The slice payload", "name": "payload"}], "name": "arc89_replace_metadata_slice", "returns": {"type": "void"}, "desc": "Replace a slice of the Asset Metadata for an ASA with a payload of the same size,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to delete the Asset Metadata for", "name": "asset_id"}], "name": "arc89_delete_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Delete Asset Metadata for an ASA, restricted to the ASA Manager Address (if the ASA still exists).", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataDeleted", "desc": "Event emitted when Asset Metadata is deleted"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to provide Metadata extra payload for", "name": "asset_id"}, {"type": "byte[]", "desc": "The Metadata extra payload to concatenate", "name": "payload"}], "name": "arc89_extra_payload", "returns": {"type": "void"}, "desc": "Concatenate extra payload to Asset Metadata head call methods (creation or replacement).", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set the Metadata Flag for", "name": "asset_id"}, {"type": "uint8", "desc": "The reversible flag index to set. WARNING: must be 0 ... 3", "name": "flag"}, {"type": "bool", "desc": "The flag value to set", "name": "value"}], "name": "arc89_set_reversible_flag", "returns": {"type": "void"}, "desc": "Set a reversible Asset Metadata Flag, restricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set the Metadata Flag for", "name": "asset_id"}, {"type": "uint8", "desc": "The irreversible flag index to set. WARNING: must be 6, 7", "name": "flag"}], "name": "arc89_set_irreversible_flag", "returns": {"type": "void"}, "desc": "Set an irreversible Asset Metadata Flag, restricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set immutable Asset Metadata for", "name": "asset_id"}], "name": "arc89_set_immutable", "returns": {"type": "void"}, "desc": "Set Asset Metadata as immutable, restricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "arc89_get_metadata_registry_parameters", "returns": {"type": "(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", "desc": "Tuple of (HEADER_SIZE, MAX_METADATA_SIZE, SHORT_METADATA_SIZE, PAGE_SIZE, FIRST_PAYLOAD_MAX_SIZE, EXTRA_PAYLOAD_MAX_SIZE, REPLACE_PAYLOAD_MAX_SIZE, FLAT_MBR, BYTE_MBR)", "struct": "RegistryParameters"}, "desc": "Return the ASA Metadata Registry parameters.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to calculate the Asset Metadata MBR Delta for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Asset Metadata byte size", "name": "new_metadata_size"}], "name": "arc89_get_metadata_mbr_delta", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Return the Asset Metadata Box MBR Delta for an ASA, given a new Asset Metadata byte size.\nIf the Asset Metadata Box does not exist, the creation MBR Delta is returned.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the ASA and Asset Metadata existence for", "name": "asset_id"}], "name": "arc89_check_metadata_exists", "returns": {"type": "(bool,bool)", "desc": "Tuple of (ASA exists, Asset Metadata exists)", "struct": "MetadataExistence"}, "desc": "Checks whether the specified ASA exists and whether its associated Asset Metadata is available.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the Asset Metadata immutability for", "name": "asset_id"}], "name": "arc89_is_metadata_immutable", "returns": {"type": "bool", "desc": "Asset Metadata for the ASA is immutable"}, "desc": "Return True if the Asset Metadata for an ASA is immutable, False otherwise.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the Asset Metadata size classification for", "name": "asset_id"}], "name": "arc89_is_metadata_short", "returns": {"type": "(bool,uint64)", "desc": "Tuple of (is short metadata, Metadata Last Modified Round)", "struct": "MutableFlag"}, "desc": "Return True if Asset Metadata for an ASA is short (up to 4096 bytes), False otherwise.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata Header for", "name": "asset_id"}], "name": "arc89_get_metadata_header", "returns": {"type": "(byte,byte,byte[32],uint64)", "desc": "Asset Metadata Header: (Identifiers, Flags, Hash, Last Modified Round)", "struct": "MetadataHeader"}, "desc": "Return the Asset Metadata Header for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata pagination for", "name": "asset_id"}], "name": "arc89_get_metadata_pagination", "returns": {"type": "(uint16,uint16,uint8)", "desc": "Tuple of (total metadata byte size, PAGE_SIZE, total number of pages)", "struct": "Pagination"}, "desc": "Return the Asset Metadata pagination for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata for", "name": "asset_id"}, {"type": "uint8", "desc": "The 0-based Metadata page number", "name": "page"}], "name": "arc89_get_metadata", "returns": {"type": "(bool,uint64,byte[])", "desc": "Tuple of (has next page, Metadata Last Modified Round, page content)", "struct": "PaginatedMetadata"}, "desc": "Return paginated Asset Metadata (without Header) for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata slice for", "name": "asset_id"}, {"type": "uint16", "desc": "The 0-based byte offset within the Metadata (body) bytes", "name": "offset"}, {"type": "uint16", "desc": "The slice bytes size to return", "name": "size"}], "name": "arc89_get_metadata_slice", "returns": {"type": "byte[]", "desc": "Asset Metadata slice (size limited to PAGE_SIZE)"}, "desc": "Return a slice of the Asset Metadata for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Metadata Header Hash for", "name": "asset_id"}], "name": "arc89_get_metadata_header_hash", "returns": {"type": "byte[32]", "desc": "Asset Metadata Header Hash"}, "desc": "Return the Metadata Header Hash for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata page hash for", "name": "asset_id"}, {"type": "uint8", "desc": "The 0-based Metadata page number", "name": "page"}], "name": "arc89_get_metadata_page_hash", "returns": {"type": "byte[32]", "desc": "The SHA512-256 of the Metadata page"}, "desc": "Return the SHA512-256 of a Metadata page for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Metadata Hash for", "name": "asset_id"}], "name": "arc89_get_metadata_hash", "returns": {"type": "byte[32]", "desc": "Asset Metadata Hash"}, "desc": "Return the Metadata Hash for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose string value to fetch", "name": "key"}], "name": "arc89_get_metadata_string_by_key", "returns": {"type": "string", "desc": "The string value from valid UTF 8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the UTF 8 string value for a top level JSON key from short Metadata for an ASA;\nerrors if the key is not a string or does not exist", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose uint64 value to fetch", "name": "key"}], "name": "arc89_get_metadata_uint64_by_key", "returns": {"type": "uint64", "desc": "The uint64 value from valid UTF 8 JSON Metadata"}, "desc": "Return the uint64 value for a top level JSON key from short Metadata for an ASA;\nerrors if the key is not an uint64 or does not exist", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose object value to fetch", "name": "key"}], "name": "arc89_get_metadata_object_by_key", "returns": {"type": "string", "desc": "The object value from valid UTF 8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the UTF 8 object value for a top level JSON key from short Metadata for an ASA;\nerrors if the key is not an object or does not exist", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "extra_resources", "returns": {"type": "void"}, "desc": "Placeholder method to acquire AVM extra resources.", "events": [], "readonly": false, "recommendations": {}}], "name": "AsaMetadataRegistry", "state": {"keys": {"box": {}, "global": {}, "local": {}}, "maps": {"box": {"asset_metadata": {"keyType": "uint64", "valueType": "AVMBytes", "prefix": ""}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 0}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"MbrDelta": [{"name": "sign", "type": "uint8"}, {"name": "amount", "type": "uint64"}], "MetadataExistence": [{"name": "asa_exists", "type": "bool"}, {"name": "metadata_exists", "type": "bool"}], "MetadataHeader": [{"name": "identifiers", "type": "byte"}, {"name": "flags", "type": "byte"}, {"name": "hash", "type": "byte[32]"}, {"name": "last_modified_round", "type": "uint64"}], "MutableFlag": [{"name": "flag", "type": "bool"}, {"name": "last_modified_round", "type": "uint64"}], "PaginatedMetadata": [{"name": "has_next_page", "type": "bool"}, {"name": "last_modified_round", "type": "uint64"}, {"name": "page_content", "type": "byte[]"}], "Pagination": [{"name": "metadata_size", "type": "uint16"}, {"name": "page_size", "type": "uint16"}, {"name": "total_pages", "type": "uint8"}], "RegistryParameters": [{"name": "header_size", "type": "uint16"}, {"name": "max_metadata_size", "type": "uint16"}, {"name": "short_metadata_size", "type": "uint16"}, {"name": "page_size", "type": "uint16"}, {"name": "first_payload_max_size", "type": "uint16"}, {"name": "extra_payload_max_size", "type": "uint16"}, {"name": "replace_payload_max_size", "type": "uint16"}, {"name": "flat_mbr", "type": "uint64"}, {"name": "byte_mbr", "type": "uint64"}]}, "byteCode": {"approval": "CyAHAQAIAu8H7ger7gEmCAQVH3x1AAEABDesdV0DBoEBBPV3wB8FFR98dQEAMRtBAOUxGRREMRhEggUEK+quVgS4LqfvBBJF+vsEBF8ubgQVsnWyK4ITBLUSHYoESfuukQQLU4zjBJqpryUEjl4QJAQkTEfEBC1Z9uAE7oW0cwQ88vNeBI8l73IEEcOEdgSwq/ZbBM6dvtcEylL7HgQiY5G5BHoT1TIEU8IiAwTTdyrTBABW2cE2GgCOGQA6Af8CiAMCA2MD5AQLBGIEuAADBNYFVAV8Ba0F1AYJBkUGtQb3Bw0HRAdcB40HuQABACJDgCIVH3x1ACp3KxAAA+8H7wfyB/AAAAAAAAAJxAAAAAAAAAGQsCJDMRkUMRgUEEQxACcHEkQiQyMpNhoBRwIVJBJEF0k2GgJJTgIVIhJENhoDSRUlEkQ2GgRJI1klCEsBFRJEMRYiCUlOBEk4ECISRE8CF0lOBEsDTIgJSE8CFklOA0m9RQEUREw4BzIKEkQyCnMBTE4DRCO5SFcCAEkVQQAhgcYFMgwNQQAYsYEGshCBBbIZJwSyHicEsh8jsgGzQv/fSwZJSwVLA4gHSUmICBlLBhcWVwcBSwQiTwK7cQZEgCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNBAO1LAiJJuiNTREsGcQZESwNJJUsDuzIGFjIHFksCIyK6I1MqI08CVEsMTwNQTwJQSwlQTFBPAlAnBUxQsDIGFksBgSJPArsiSbolU0EAiDIIRQkpRQpLCEEAQEsISYEKGEmBCg9LAYEKTwJNTCIISYEKD4EKTE1JSwIMSwJMTYAKMDEyMzQ1Njc4OU4CUksLUEULgQoKRQlC/7tLCUkVgAEwTgJNgA9hbGdvcmFuZDovL2FwcC9MUIAFP2JveD1QSwdxBURJFUsCFUlLAg9MTgJNI0xSEkQyCnMBREsCCUsFOAhLAQ9EFicGTFCwIkNLBogHcEL/GDYaAUkVJBJEF0k2GgJJFSUSRDYaA0kjWSUISwEVEkRMF0sCSwGIB7dLAogFyksBD0QyCnMBRE8CVwIASwNLA08CiAXWSwKIB9tPAogFqU8CEkQyCnMBRAlJQAAUIxZJkyQORFcHAUsBFlAoTFCwIkOB/wGxSwJxB0RLArIIsgcishAjsgGzQv/UNhoBSRUkEkQXNhoCSRUlEkQ2GgNJI1klCEsBFRJEMRYiCUk4ECISRE8CF0sDSwGIByRLA4gFN0sBDERLATgHMgoSRDIKcwFETwNXAgBLBEsDTwKIBTtLA4gHQE8DiAUOTwISRDIKcwFETAlMOAhLAQ9EFicGTFCwIkM2GgFJFSQSRBdJNhoCSRUlEkQ2GgNJI1klCEsBFRJESwKIBNBLA0yIBrJMF0xXAgBJTgNJFUsCSwEISwSIBLUORE8DFklOBIEqTwQISU4ETwK6E0EACUpLBLtLA4gGwiJDKTYaAUcCFSQSRBdHAhZJTgK9RQFEcQtFAUEADkkiSbojUxRESwGIBF5EMgpzAURLAbxIMgpzAUQJRQSxSwFxC0UBQQA3SwFxB0RLBEmyCEyyByKyECOyAbMyBhYyBxZLBU8CUExQgAS8PyDRTFCwFoAFFR98df9MULAiQzEAQv/JNhoBSRUkEkQXNhoCSSNZJQhMFRJESXELRQFESRa9RQFEiAPiRCJDNhoBSRUkEkQXSTYaAkkVIhJENhoDSRUiEkRLAogF4EwXSYEDDkRPAhZJTgMiSbqBB08CCUlOA1NMI1NJTwITQQATSwJJIkm6SwNLA1QiTLtLA4gFwyJDIyk2GgFJFSQSRBdJNhoCSRUiEkRMiAWQF0mBBg9BADJJgQcOQQArIkRLARZJRQUiSbqBB0sCCUlFBVNAABJLA0kiSbpLBCJUIky7SwGIBXEiQyNC/9I2GgFJFSQSRBdJiAVFSRZJIkm6IyJUIky7iAVPIkMpSTYaAUkVJBJEF0k2GgJJFSUSRBdJTgIhBg5EFr1FAUEATEsBiAL4SUUEI0UFSwESQQAeI0mBkANPAgtLBQhMFkmTJA5EVwcBTBZQKExQsCJDSUsDDUEACiJLAUsECUxC/9OB/wFLA0sCCUxC/8eBxBNFBCKBMksCCExC/7g2GgFJFSQSRBdJcQtFASojTwJUTBa9RQEqI08CVCNTIkxUKExQsCJDNhoBSRUkEkQXRwKIBG4WIkm6I1NAAApJcQdEMgMSQQAMIiojTwJUKExQsCJDI0L/8TYaAUkVJBJEF0mIBD4WSSMiuiNTKiNPAlRMgSIkuhcWUChMULAiQzYaAUkVJBJEF0mIBBcWSSMiuksBIkm6SwIlgSC6TwOBIiS6FxZPA08DUE8CUExQKExQsCJDNhoBSRUkEkQXSYgD4kmIAdwWSZOBEA5EVwYCTIgBziEFCCEEChZJkyQORFcHAUyAAgPvUExQKExQsCJDKTYaAUkVJBJEF0k2GgJJTgIVIhJESYgDmogBlSEFCCEECklOAkEAPhdJSwJJTgIMRCIJSwENRQRLAkyIAhsqI0sFVEsDFoEiJLoXFk8CSRUWVwYCTFBOAlCAAgALUExQKExQsCJDFxREI0UDKUL/zjYaAUkVJBJEFzYaAkkVJRJENhoDSRUlEkRLAogDJRdJIQQOREwXSUsCCEsDiAESDkRPAhaBKk8CCE8CuihMULAiQzYaAUkVJBJEF0mIAvSIAgIoTFCwIkM2GgFJFSQSRBc2GgJJFSISREsBiALVSwGIAM4hBQghBApJREwXSU8CDERKiAFjiAIAKExQsCJDNhoBSRUkEkQXSYgCpxYlgSC6KExQsCJDNhoBSRUkEkQXNhoCSSNZJQhLARUSREsBiAKBTIgBW0xXAgBfAEkVIQQORChMULAiQzYaAUkVJBJEFzYaAkkjWSUISwEVEkRLAYgCUEyIASpMVwIAXwEWKExQsCJDNhoBSRUkEkQXNhoCSSNZJQhLARUSREsBiAIkTIgA/kxXAgBfAkkVIQQORChMULAiQ4oBATEAi/9xB0QSiYoBAYv/Fr1EgSoJiYoCAIv+Fkm9RIv/FUsBCEsCTNOL/7uJigMAi/0WSYEq04v9i/+I/9gyBDEWIgiLAosBDEEAXIsCOBCBBhJBAE6LAjgYMggSQQBEiwI4GUAAPYsCI8IaKxJBADOLAiLCGosAEkEAKCJBABuLAiXCGlcCAIv9iP99SwEVCIv+DkSL/UyI/3uLAiIIjAJC/6AjQv/Vi/2I/12L/hJEiYoCAYv+iP9QSYv/IQQLSU8CD0EABCmMAImLAIsBSU4CCSEESwEMIQRMTYv+FoEqTwMITwK6jACJigEBi/8WSSMiuiNTRIv/iP8OgSpMuomKAQCL/4j/AYv/FkkjIrpPAoGAIA4jTFQjTLuJigEBi/8WSSMiuksBIkm6i/+I/tkWVwYCgA5hcmMwMDg5L2hlYWRlck8EUE8DUE8CUExQA4mKAwGL/RaL/hZXBwGL/xUWVwYCgAxhcmMwMDg5L3BhZ2VPA1BPAlBMUIv/UAOJigEBKYv/iP+Ui/+I/nwhBQghBApJKUxBACsjjACLAIsCDEEAIIv/iwBJTgKI/wOL/0sCTwKI/5qLA0xQjAMiCIwAQv/YgAphcmMwMDg5L2FtiwFQiwNQA4wAiYoCAIv+cQtFAUSL/oj+FESL/yEGDkSJigIAi/6L/4j/34v+Fkm9RQFEIkm6I1MURImKAQCL/3ELRQFEi/8WvUUBRImKAQCL/4j/5ov/FiJJuiNTFESL/4j9yUSJigEAi/+I/sKL/4j/PIv/FkklSwO7MgYWSwGBIk8CuzIGFjIHFksCIkm6FxZJkyQORFcHAUsDIyK6I1MqI08CVE8ETwRQTwNQTwJQTFBMUCcFTFCwiQ==", "clear": "C4EBQw=="}, "desc": "\n    Singleton Application providing ASA metadata via Algod API and AVM\n    ", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}, {"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataDeleted", "desc": "Event emitted when Asset Metadata is deleted"}], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAxIDAgOCAyIDEwMDcgMTAwNiAzMDUwNwogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1IDB4IDB4MDAgMHgzN2FjNzU1ZCAweDA2ODEwMSAweGY1NzdjMDFmIDB4MTUxZjdjNzUwMSBUTVBMX1RSVVNURURfREVQTE9ZRVIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzYKICAgIC8vIGNsYXNzIEFzYU1ldGFkYXRhUmVnaXN0cnkoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZSk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9kZXBsb3lAMzQKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydAogICAgcHVzaGJ5dGVzcyAweDJiZWFhZTU2IDB4YjgyZWE3ZWYgMHgxMjQ1ZmFmYiAweDA0NWYyZTZlIDB4MTViMjc1YjIgLy8gbWV0aG9kICJhcmM4OV9jcmVhdGVfbWV0YWRhdGEodWludDY0LGJ5dGUsdWludDE2LGJ5dGVbXSxwYXkpKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X3JlcGxhY2VfbWV0YWRhdGEodWludDY0LHVpbnQxNixieXRlW10pKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfbGFyZ2VyKHVpbnQ2NCx1aW50MTYsYnl0ZVtdLHBheSkodWludDgsdWludDY0KSIsIG1ldGhvZCAiYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZSh1aW50NjQsdWludDE2LGJ5dGVbXSl2b2lkIiwgbWV0aG9kICJhcmM4OV9kZWxldGVfbWV0YWRhdGEodWludDY0KSh1aW50OCx1aW50NjQpIgogICAgYnl0ZWNfMyAvLyBtZXRob2QgImFyYzg5X2V4dHJhX3BheWxvYWQodWludDY0LGJ5dGVbXSl2b2lkIgogICAgcHVzaGJ5dGVzcyAweGI1MTIxZDhhIDB4NDlmYmFlOTEgMHgwYjUzOGNlMyAweDlhYTlhZjI1IDB4OGU1ZTEwMjQgMHgyNDRjNDdjNCAweDJkNTlmNmUwIDB4ZWU4NWI0NzMgMHgzY2YyZjM1ZSAweDhmMjVlZjcyIDB4MTFjMzg0NzYgMHhiMGFiZjY1YiAweGNlOWRiZWQ3IDB4Y2E1MmZiMWUgMHgyMjYzOTFiOSAweDdhMTNkNTMyIDB4NTNjMjIyMDMgMHhkMzc3MmFkMyAweDAwNTZkOWMxIC8vIG1ldGhvZCAiYXJjODlfc2V0X3JldmVyc2libGVfZmxhZyh1aW50NjQsdWludDgsYm9vbCl2b2lkIiwgbWV0aG9kICJhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWcodWludDY0LHVpbnQ4KXZvaWQiLCBtZXRob2QgImFyYzg5X3NldF9pbW11dGFibGUodWludDY0KXZvaWQiLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9yZWdpc3RyeV9wYXJhbWV0ZXJzKCkodWludDE2LHVpbnQxNix1aW50MTYsdWludDE2LHVpbnQxNix1aW50MTYsdWludDE2LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhKHVpbnQ2NCx1aW50MTYpKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2NoZWNrX21ldGFkYXRhX2V4aXN0cyh1aW50NjQpKGJvb2wsYm9vbCkiLCBtZXRob2QgImFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZSh1aW50NjQpYm9vbCIsIG1ldGhvZCAiYXJjODlfaXNfbWV0YWRhdGFfc2hvcnQodWludDY0KShib29sLHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXIodWludDY0KShieXRlLGJ5dGUsYnl0ZVszMl0sdWludDY0KSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2luYXRpb24odWludDY0KSh1aW50MTYsdWludDE2LHVpbnQ4KSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhKHVpbnQ2NCx1aW50OCkoYm9vbCx1aW50NjQsYnl0ZVtdKSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3NsaWNlKHVpbnQ2NCx1aW50MTYsdWludDE2KWJ5dGVbXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlcl9oYXNoKHVpbnQ2NClieXRlWzMyXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaCh1aW50NjQsdWludDgpYnl0ZVszMl0iLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9oYXNoKHVpbnQ2NClieXRlWzMyXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3N0cmluZ19ieV9rZXkodWludDY0LHN0cmluZylzdHJpbmciLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5KHVpbnQ2NCxzdHJpbmcpdWludDY0IiwgbWV0aG9kICJhcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleSh1aW50NjQsc3RyaW5nKXN0cmluZyIsIG1ldGhvZCAiZXh0cmFfcmVzb3VyY2VzKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggYXJjODlfY3JlYXRlX21ldGFkYXRhIGFyYzg5X3JlcGxhY2VfbWV0YWRhdGEgYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9sYXJnZXIgYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZSBhcmM4OV9kZWxldGVfbWV0YWRhdGEgYXJjODlfZXh0cmFfcGF5bG9hZCBhcmM4OV9zZXRfcmV2ZXJzaWJsZV9mbGFnIGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZyBhcmM4OV9zZXRfaW1tdXRhYmxlIG1haW5fYXJjODlfZ2V0X21ldGFkYXRhX3JlZ2lzdHJ5X3BhcmFtZXRlcnNfcm91dGVAMTUgYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YSBhcmM4OV9jaGVja19tZXRhZGF0YV9leGlzdHMgYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlIGFyYzg5X2lzX21ldGFkYXRhX3Nob3J0IGFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXIgYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2luYXRpb24gYXJjODlfZ2V0X21ldGFkYXRhIGFyYzg5X2dldF9tZXRhZGF0YV9zbGljZSBhcmM4OV9nZXRfbWV0YWRhdGFfaGVhZGVyX2hhc2ggYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaCBhcmM4OV9nZXRfbWV0YWRhdGFfaGFzaCBhcmM4OV9nZXRfbWV0YWRhdGFfc3RyaW5nX2J5X2tleSBhcmM4OV9nZXRfbWV0YWRhdGFfdWludDY0X2J5X2tleSBhcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleSBtYWluX2V4dHJhX3Jlc291cmNlc19yb3V0ZUAzMAogICAgZXJyCgptYWluX2V4dHJhX3Jlc291cmNlc19yb3V0ZUAzMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2FyYzg5X2dldF9tZXRhZGF0YV9yZWdpc3RyeV9wYXJhbWV0ZXJzX3JvdXRlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2ODQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzUwMDJhNzcyYjEwMDAwM2VmMDdlZjA3ZjIwN2YwMDAwMDAwMDAwMDAwMDljNDAwMDAwMDAwMDAwMDAxOTAKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl9kZXBsb3lAMzQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMwNwogICAgLy8gQGFyYzQuYmFyZW1ldGhvZChjcmVhdGU9InJlcXVpcmUiKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgICYmCiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzEyLTMxMwogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBUZW1wbGF0ZVZhcltBY2NvdW50XSgKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzEyLTMxNQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBUZW1wbGF0ZVZhcltBY2NvdW50XSgKICAgIC8vICAgICBUUlVTVEVEX0RFUExPWUVSCiAgICAvLyApLCBlcnIuVU5UUlVTVEVEX0RFUExPWUVSCiAgICBieXRlYyA3IC8vIFRNUExfVFJVU1RFRF9ERVBMT1lFUgogICAgPT0KICAgIGFzc2VydCAvLyBUaGUgZGVwbG95ZXIgYWRkcmVzcyBpcyBub3QgdHJ1c3RlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMDcKICAgIC8vIEBhcmM0LmJhcmVtZXRob2QoY3JlYXRlPSJyZXF1aXJlIikKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfY3JlYXRlX21ldGFkYXRhW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfY3JlYXRlX21ldGFkYXRhOgogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzEgLy8gIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzE3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cG4gMgogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18wIC8vIDEKICAgIC0KICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18wIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDEtMzQyCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2Jhc2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSkKICAgIHVuY292ZXIgMgogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkaWcgMwogICAgc3dhcAogICAgY2FsbHN1YiBfY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ5CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDMKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzc2V0X2lkKSwgZXJyLkFTU0VUX01FVEFEQVRBX0VYSVNUCiAgICAhCiAgICBhc3NlcnQgLy8gQXNzZXQgTWV0YWRhdGEgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgQVNBCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM0NQogICAgLy8gbWJyX2RlbHRhX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgc3dhcAogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDQtMzQ2CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG1icl9kZWx0YV9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksIGVyci5NQlJfREVMVEFfUkVDRUlWRVJfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIHJlY2VpdmVyLCBtdXN0IGJlIHRoZSBBU0EgTWV0YWRhdGEgUmVnaXN0cnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzQ4LTM0OQogICAgLy8gIyBJbml0aWFsaXplIGVtcHR5IEFzc2V0IE1ldGFkYXRhIEJveAogICAgLy8gbWJyX2kgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBzd2FwCiAgICBjb3ZlciAzCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzUwCiAgICAvLyBfZXhpc3RzID0gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNzZXRfaWQpLmNyZWF0ZShzaXplPVVJbnQ2NCgwKSkKICAgIGludGNfMSAvLyAwCiAgICBib3hfY3JlYXRlCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzUyLTM1MwogICAgLy8gIyBTZXQgTWV0YWRhdGEgQm9keQogICAgLy8gaWYgcGF5bG9hZC5uYXRpdmUubGVuZ3RoID4gMDoKICAgIGV4dHJhY3QgMiAwCiAgICBkdXAKICAgIGxlbgogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMwoKYXJjODlfY3JlYXRlX21ldGFkYXRhX3doaWxlX3RvcEAxNzoKICAgIHB1c2hpbnQgNzEwCiAgICBnbG9iYWwgT3Bjb2RlQnVkZ2V0CiAgICA+CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAzCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgYnl0ZWMgNCAvLyAweDA2ODEwMQogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KICAgIGJ5dGVjIDQgLy8gMHgwNjgxMDEKICAgIGl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGIgYXJjODlfY3JlYXRlX21ldGFkYXRhX3doaWxlX3RvcEAxNwoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzU1CiAgICAvLyBzZWxmLl9zZXRfbWV0YWRhdGFfcGF5bG9hZChhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSwgcGF5bG9hZC5uYXRpdmUpCiAgICBkaWcgNgogICAgZHVwCiAgICBkaWcgNQogICAgZGlnIDMKICAgIGNhbGxzdWIgX3NldF9tZXRhZGF0YV9wYXlsb2FkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM1Ny0zNTgKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEhlYWRlcgogICAgLy8gc2VsZi5faWRlbnRpZnlfbWV0YWRhdGEoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2lkZW50aWZ5X21ldGFkYXRhCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2MQogICAgLy8gdHJpbW1lZF9pdG9iKHVpbnQ9ZmxhZ3MuYXNfdWludDY0KCksIHNpemU9VUludDY0KGNvbnN0LkJZVEVfU0laRSkpLAogICAgZGlnIDYKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjExCiAgICAvLyByZXR1cm4gb3AuZXh0cmFjdChvcC5pdG9iKHVpbnQpLCBzdGFydCwgc2l6ZSkKICAgIGl0b2IKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgZGlnIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODAKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNjMKICAgIC8vIGlmIGFzc2V0X2lkLm1ldGFkYXRhX2hhc2ggIT0gQnl0ZXMoCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWV0YWRhdGFIYXNoCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2My0zNjUKICAgIC8vIGlmIGFzc2V0X2lkLm1ldGFkYXRhX2hhc2ggIT0gQnl0ZXMoCiAgICAvLyAgICAgY29uc3QuQllURVMzMl9TSVpFICogYiJceDAwIgogICAgLy8gKTogICMgTm90IGVtcHR5IG1ldGFkYXRhIGhhc2gKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgICE9CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfZWxzZV9ib2R5QDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTIKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MC05MwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2NgogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2ltbXV0YWJsZShhc3NldF9pZCksIGVyci5SRVFVSVJFU19JTU1VVEFCTEUKICAgIGFzc2VydCAvLyBNdXN0IGJlIGZsYWdnZWQgYXMgaW1tdXRhYmxlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2NwogICAgLy8gbWV0YWRhdGFfaGFzaCA9IGFzc2V0X2lkLm1ldGFkYXRhX2hhc2gKICAgIGRpZyA2CiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWV0YWRhdGFIYXNoCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDctMTA5CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIC8vICkKICAgIGRpZyAzCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgdmFsdWU9bWV0YWRhdGFfaGFzaAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3LTEwOQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCB2YWx1ZT1tZXRhZGF0YV9oYXNoCiAgICAvLyApCiAgICBkaWcgMwogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mzc0CiAgICAvLyByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgZ2xvYmFsIFJvdW5kCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3NQogICAgLy8gdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY0CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg2CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NC04NwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mzc3CiAgICAvLyBpc19zaG9ydD1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNzZXRfaWQpKSwKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3Mi0zNzkKICAgIC8vIGFiaS5BcmM4OU1ldGFkYXRhVXBkYXRlZCgKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZC5pZCksCiAgICAvLyAgICAgcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIC8vICAgICB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgIGZsYWdzPWZsYWdzLAogICAgLy8gICAgIGlzX3Nob3J0PWFyYzQuQm9vbChzZWxmLl9pc19zaG9ydChhc3NldF9pZCkpLAogICAgLy8gICAgIGhhc2g9YWJpLkhhc2guZnJvbV9ieXRlcyhtZXRhZGF0YV9oYXNoKSwKICAgIC8vICkKICAgIGRpZyAxMgogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBkaWcgOQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3MS0zODAKICAgIC8vIGFyYzQuZW1pdCgKICAgIC8vICAgICBhYmkuQXJjODlNZXRhZGF0YVVwZGF0ZWQoCiAgICAvLyAgICAgICAgIGFzc2V0X2lkPWFyYzQuVUludDY0KGFzc2V0X2lkLmlkKSwKICAgIC8vICAgICAgICAgcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIC8vICAgICAgICAgdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIC8vICAgICAgICAgZmxhZ3M9ZmxhZ3MsCiAgICAvLyAgICAgICAgIGlzX3Nob3J0PWFyYzQuQm9vbChzZWxmLl9pc19zaG9ydChhc3NldF9pZCkpLAogICAgLy8gICAgICAgICBoYXNoPWFiaS5IYXNoLmZyb21fYnl0ZXMobWV0YWRhdGFfaGFzaCksCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgYnl0ZWMgNSAvLyBtZXRob2QgIkFyYzg5TWV0YWRhdGFVcGRhdGVkKHVpbnQ2NCx1aW50NjQsdWludDY0LGJ5dGUsYm9vbCxieXRlWzMyXSkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODEKICAgIC8vIHNlbGYuX3NldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkLCBHbG9iYWwucm91bmQpCiAgICBnbG9iYWwgUm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIyCiAgICAvLyB2YWx1ZT1vcC5pdG9iKGxhc3RfbW9kaWZpZWRfcm91bmQpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjAtMTIzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMC0xMjMKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICB2YWx1ZT1vcC5pdG9iKGxhc3RfbW9kaWZpZWRfcm91bmQpLAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MgogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwLTkzCiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzgzLTM4NAogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gaWYgc2VsZi5faXNfYXJjODkoYXNzZXRfaWQpOgogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODcKICAgIC8vICsgaXRvYShHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZC5pZCkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgYnVyeSA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyOQogICAgLy8gYWNjID0gQnl0ZXMoYiIiKQogICAgYnl0ZWNfMSAvLyAweAogICAgYnVyeSAxMAoKYXJjODlfY3JlYXRlX21ldGFkYXRhX3doaWxlX3RvcEAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjMxCiAgICAvLyB3aGlsZSBpID4gMDoKICAgIGRpZyA4CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfd2hpbGVAMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjMyCiAgICAvLyBkID0gaSAlIFVJbnQ2NCgxMCkKICAgIGRpZyA4CiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjMzCiAgICAvLyBhY2MgPSBkaWdpdHNbZCA6IGQgKyBVSW50NjQoMSldICsgYWNjCiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgID49CiAgICBkaWcgMQogICAgcHVzaGludCAxMAogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIHN3YXAKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgID49CiAgICBwdXNoaW50IDEwCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIGR1cAogICAgZGlnIDIKICAgIDwKICAgIGRpZyAyCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjI3LTI4CiAgICAvLyAjIEFTQ0lJIGRpZ2l0cyAodmFsaWQgVVRGLTgpCiAgICAvLyBkaWdpdHMgPSBCeXRlcyhiIjAxMjM0NTY3ODkiKQogICAgcHVzaGJ5dGVzIDB4MzAzMTMyMzMzNDM1MzYzNzM4MzkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjMzCiAgICAvLyBhY2MgPSBkaWdpdHNbZCA6IGQgKyBVSW50NjQoMSldICsgYWNjCiAgICBjb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBkaWcgMTEKICAgIGNvbmNhdAogICAgYnVyeSAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MzQKICAgIC8vIGkgLy89IFVJbnQ2NCgxMCkKICAgIHB1c2hpbnQgMTAKICAgIC8KICAgIGJ1cnkgOQogICAgYiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfd2hpbGVfdG9wQDEwCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfd2hpbGVAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weTozNgogICAgLy8gcmV0dXJuIGFjYyBvciBCeXRlcyhiIjAiKQogICAgZGlnIDkKICAgIGR1cAogICAgbGVuCiAgICBwdXNoYnl0ZXMgMHgzMAogICAgY292ZXIgMgogICAgc2VsZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM4NgogICAgLy8gY29uc3QuVVJJX0FSQ184OV9QUkVGSVgKICAgIHB1c2hieXRlcyAweDYxNmM2NzZmNzI2MTZlNjQzYTJmMmY2MTcwNzAyZgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODYtMzg3CiAgICAvLyBjb25zdC5VUklfQVJDXzg5X1BSRUZJWAogICAgLy8gKyBpdG9hKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkKQogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM4OAogICAgLy8gKyBjb25zdC5VUklfQVJDXzg5X1NVRkZJWAogICAgcHVzaGJ5dGVzIDB4M2Y2MjZmNzgzZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODYtMzg4CiAgICAvLyBjb25zdC5VUklfQVJDXzg5X1BSRUZJWAogICAgLy8gKyBpdG9hKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkKQogICAgLy8gKyBjb25zdC5VUklfQVJDXzg5X1NVRkZJWAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM5MAogICAgLy8gYXNhX3VybCA9IGFzc2V0X2lkLnVybAogICAgZGlnIDcKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRVUkwKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzkyCiAgICAvLyBhc2FfdXJsWzogYXJjXzg5X3VyaS5sZW5ndGhdID09IGFyY184OV91cmkKICAgIGR1cAogICAgbGVuCiAgICBkaWcgMgogICAgbGVuCiAgICBkdXAKICAgIGRpZyAyCiAgICA+PQogICAgc3dhcAogICAgY292ZXIgMgogICAgc2VsZWN0CiAgICBpbnRjXzEgLy8gMAogICAgc3dhcAogICAgc3Vic3RyaW5nMwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzkxLTM5MwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBhc2FfdXJsWzogYXJjXzg5X3VyaS5sZW5ndGhdID09IGFyY184OV91cmkKICAgIC8vICksIGVyci5BU0FfVVJMX0lOVkFMSURfQVJDODlfVVJJCiAgICBhc3NlcnQgLy8gSW52YWxpZCBBUkMtODkgVVJJCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozOTUKICAgIC8vIG1icl9kZWx0YV9hbW91bnQgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlIC0gbWJyX2kKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgZGlnIDIKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mzk3CiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgZGlnIDUKICAgIGd0eG5zIEFtb3VudAogICAgZGlnIDEKICAgID49CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM5Ni0zOTgKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyX2RlbHRhX3BheW1lbnQuYW1vdW50ID49IG1icl9kZWx0YV9hbW91bnQKICAgIC8vICksIGVyci5NQlJfREVMVEFfQU1PVU5UX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1CUiBEZWx0YSBhbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDAxCiAgICAvLyBzaWduPWFyYzQuVUludDgoZW51bXMuTUJSX0RFTFRBX1BPUyksIGFtb3VudD1hcmM0LlVJbnQ2NChtYnJfZGVsdGFfYW1vdW50KQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMTcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgYnl0ZWMgNiAvLyAweDE1MWY3Yzc1MDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfZWxzZV9ib2R5QDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2OQogICAgLy8gbWV0YWRhdGFfaGFzaCA9IHNlbGYuX2NvbXB1dGVfbWV0YWRhdGFfaGFzaChhc3NldF9pZCkKICAgIGRpZyA2CiAgICBjYWxsc3ViIF9jb21wdXRlX21ldGFkYXRhX2hhc2gKICAgIGIgYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9yZXBsYWNlX21ldGFkYXRhW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDA0CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MjUtNDI2CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkLCBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpKQogICAgc3dhcAogICAgYnRvaQogICAgZGlnIDIKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MjctNDI5CiAgICAvLyBhc3NlcnQgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLkxBUkdFUl9NRVRBREFUQV9TSVpFCiAgICBkaWcgMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGRpZyAxCiAgICA+PQogICAgYXNzZXJ0IC8vIEludmFsaWQgTWV0YWRhdGEgc2l6ZSwgbXVzdCBiZSBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGN1cnJlbnQgc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MzEtNDMyCiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBCb2R5CiAgICAvLyBtYnJfaSA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MzMKICAgIC8vIHNlbGYuX3NldF9tZXRhZGF0YV9wYXlsb2FkKGFzc2V0X2lkLCBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpLCBwYXlsb2FkLm5hdGl2ZSkKICAgIHVuY292ZXIgMgogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAzCiAgICBkaWcgMwogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIF9zZXRfbWV0YWRhdGFfcGF5bG9hZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MzUtNDM2CiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBIZWFkZXIKICAgIC8vIHNlbGYuX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KGFzc2V0X2lkKQogICAgZGlnIDIKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0MAogICAgLy8gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpID09IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIHVuY292ZXIgMgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDM4LTQ0MQogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc3NldF9pZCkgPT0gbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKQogICAgLy8gKSwgZXJyLk1FVEFEQVRBX1NJWkVfTUlTTUFUQ0gKICAgIGFzc2VydCAvLyBNZXRhZGF0YSBzaXplIG1pc21hdGNoLCBtdXN0IGJlIGV4YWN0bHkgZXF1YWwgdG8gZGVjbGFyZWQgc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDMKICAgIC8vIG1icl9kZWx0YV9hbW91bnQgPSBtYnJfaSAtIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0NAogICAgLy8gaWYgbWJyX2RlbHRhX2Ftb3VudCA9PSAwOgogICAgYm56IGFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDQ1CiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9OVUxMKQogICAgaW50Y18xIC8vIDAKCmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NTMKICAgIC8vIHJldHVybiBhYmkuTWJyRGVsdGEoc2lnbj1hcmM0LlVJbnQ4KHNpZ24pLCBhbW91bnQ9YXJjNC5VSW50NjQobWJyX2RlbHRhX2Ftb3VudCkpCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICBkaWcgMQogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQwNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9yZXBsYWNlX21ldGFkYXRhX2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDcKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX05FRykKICAgIHB1c2hpbnQgMjU1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0OC00NTEKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1hc3NldF9pZC5tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD1tYnJfZGVsdGFfYW1vdW50LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDkKICAgIC8vIHJlY2VpdmVyPWFzc2V0X2lkLm1hbmFnZXIsCiAgICBkaWcgMgogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDgKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMCAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDgtNDUxCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciwKICAgIC8vICAgICBhbW91bnQ9bWJyX2RlbHRhX2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIGFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA1CgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfbGFyZ2VyW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9sYXJnZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18wIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMCAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDc4LTQ3OQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucyhhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSkKICAgIHVuY292ZXIgMgogICAgYnRvaQogICAgZGlnIDMKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0ODAtNDgyCiAgICAvLyBhc3NlcnQgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA+IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgLy8gICAgIGFzc2V0X2lkCiAgICAvLyApLCBlcnIuU01BTExFUl9NRVRBREFUQV9TSVpFCiAgICBkaWcgMwogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGRpZyAxCiAgICA8CiAgICBhc3NlcnQgLy8gSW52YWxpZCBNZXRhZGF0YSBzaXplLCBtdXN0IGJlIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDg0CiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBkaWcgMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0ODMtNDg1CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG1icl9kZWx0YV9wYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksIGVyci5NQlJfREVMVEFfUkVDRUlWRVJfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIHJlY2VpdmVyLCBtdXN0IGJlIHRoZSBBU0EgTWV0YWRhdGEgUmVnaXN0cnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDg3LTQ4OAogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgQm9keQogICAgLy8gbWJyX2kgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDg5CiAgICAvLyBzZWxmLl9zZXRfbWV0YWRhdGFfcGF5bG9hZChhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSwgcGF5bG9hZC5uYXRpdmUpCiAgICB1bmNvdmVyIDMKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgNAogICAgZGlnIDMKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfc2V0X21ldGFkYXRhX3BheWxvYWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkxLTQ5MgogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OTYKICAgIC8vIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSA9PSBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICB1bmNvdmVyIDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ5NC00OTcKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpID09IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIC8vICksIGVyci5NRVRBREFUQV9TSVpFX01JU01BVENICiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgc2l6ZSBtaXNtYXRjaCwgbXVzdCBiZSBleGFjdGx5IGVxdWFsIHRvIGRlY2xhcmVkIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDk5CiAgICAvLyBtYnJfZGVsdGFfYW1vdW50ID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZSAtIG1icl9pCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTAxCiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgc3dhcAogICAgZ3R4bnMgQW1vdW50CiAgICBkaWcgMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTAwLTUwMgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgLy8gKSwgZXJyLk1CUl9ERUxUQV9BTU9VTlRfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MDUKICAgIC8vIHNpZ249YXJjNC5VSW50OChlbnVtcy5NQlJfREVMVEFfUE9TKSwgYW1vdW50PWFyYzQuVUludDY0KG1icl9kZWx0YV9hbW91bnQpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBieXRlYyA2IC8vIDB4MTUxZjdjNzUwMQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfc2xpY2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUwOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTI1LTUyNgogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucyhhc3NldF9pZCwgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpKQogICAgZGlnIDIKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBkaWcgMwogICAgc3dhcAogICAgY2FsbHN1YiBfY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTI3CiAgICAvLyBhc3NlcnQgb2Zmc2V0LmFzX3VpbnQ2NCgpICsgcGF5bG9hZC5uYXRpdmUubGVuZ3RoIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgc3dhcAogICAgYnRvaQogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgY292ZXIgMwogICAgZHVwCiAgICBsZW4KICAgIGRpZyAyCiAgICBkaWcgMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MjctNTI5CiAgICAvLyBhc3NlcnQgb2Zmc2V0LmFzX3VpbnQ2NCgpICsgcGF5bG9hZC5uYXRpdmUubGVuZ3RoIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgLy8gICAgIGFzc2V0X2lkCiAgICAvLyApLCBlcnIuRVhDRUVEU19NRVRBREFUQV9TSVpFCiAgICBkaWcgNAogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIDw9CiAgICBhc3NlcnQgLy8gU2xpY2UgZXhjZWVkcyBtZXRhZGF0YSByYW5nZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMDYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICB1bmNvdmVyIDMKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMDcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldCwgbGVuZ3RoPXNpemUKICAgIHB1c2hpbnQgNDIKICAgIHVuY292ZXIgNAogICAgKwogICAgZHVwCiAgICBjb3ZlciA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwNi0yMDgKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LCBsZW5ndGg9c2l6ZQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MzUKICAgIC8vIGlmIHBheWxvYWQubmF0aXZlICE9IGV4aXN0aW5nX3NsaWNlOgogICAgIT0KICAgIGJ6IGFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfc2xpY2VfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUzNi01NDAKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEJvZHkKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzc2V0X2lkKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldC5hc191aW50NjQoKSwKICAgIC8vICAgICB2YWx1ZT1wYXlsb2FkLm5hdGl2ZSwKICAgIC8vICkKICAgIGR1cDIKICAgIGRpZyA0CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NDItNTQzCiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBIZWFkZXIKICAgIC8vIHNlbGYuX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KGFzc2V0X2lkKQogICAgZGlnIDMKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CgphcmM4OV9yZXBsYWNlX21ldGFkYXRhX3NsaWNlX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTA4CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZGVsZXRlX21ldGFkYXRhW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZGVsZXRlX21ldGFkYXRhOgogICAgYnl0ZWNfMSAvLyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwbiAyCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ5CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2MC01NjEKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc3NldF9pZCksIGVyci5BU1NFVF9NRVRBREFUQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYyCiAgICAvLyBpZiBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2RlbGV0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTAtOTMKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NjMKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5faXNfaW1tdXRhYmxlKGFzc2V0X2lkKSwgZXJyLklNTVVUQUJMRQogICAgIQogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIGlzIGltbXV0YWJsZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NjQKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hc2FfbWFuYWdlcihhc3NldF9pZCksIGVyci5VTkFVVEhPUklaRUQKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9pc19hc2FfbWFuYWdlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZCwgbXVzdCBiZSB0aGUgQXNzZXQgTWFuYWdlcgoKYXJjODlfZGVsZXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTY2LTU2NwogICAgLy8gIyBEZWxldGUgTWV0YWRhdGEgYW5kIHJlZnVuZCBNQlIKICAgIC8vIG1icl9pID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2OAogICAgLy8gZGVsIHNlbGYuYXNzZXRfbWV0YWRhdGFbYXNzZXRfaWRdCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2OQogICAgLy8gbWJyX2RlbHRhX2Ftb3VudCA9IG1icl9pIC0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAtCiAgICBidXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTcwLTU3MwogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWFzc2V0X2lkLm1hbmFnZXIgaWYgc2VsZi5fYXNhX2V4aXN0cyhhc3NldF9pZCkgZWxzZSBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFtb3VudD1tYnJfZGVsdGFfYW1vdW50LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NQogICAgLy8gX2NyZWF0b3IsIGV4aXN0cyA9IG9wLkFzc2V0UGFyYW1zR2V0LmFzc2V0X2NyZWF0b3IoYXNhKQogICAgZGlnIDEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTcxCiAgICAvLyByZWNlaXZlcj1hc3NldF9pZC5tYW5hZ2VyIGlmIHNlbGYuX2FzYV9leGlzdHMoYXNzZXRfaWQpIGVsc2UgVHhuLnNlbmRlciwKICAgIGJ6IGFyYzg5X2RlbGV0ZV9tZXRhZGF0YV90ZXJuYXJ5X2ZhbHNlQDUKICAgIGRpZyAxCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWFuYWdlcgogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwoKYXJjODlfZGVsZXRlX21ldGFkYXRhX3Rlcm5hcnlfbWVyZ2VANjoKICAgIGRpZyA0CiAgICBkdXAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3MAogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18wIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18xIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3MC01NzMKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1hc3NldF9pZC5tYW5hZ2VyIGlmIHNlbGYuX2FzYV9leGlzdHMoYXNzZXRfaWQpIGVsc2UgVHhuLnNlbmRlciwKICAgIC8vICAgICBhbW91bnQ9bWJyX2RlbHRhX2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3OAogICAgLy8gcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIGdsb2JhbCBSb3VuZAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NzkKICAgIC8vIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3Ni01ODAKICAgIC8vIGFiaS5BcmM4OU1ldGFkYXRhRGVsZXRlZCgKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZC5pZCksCiAgICAvLyAgICAgcm91bmQ9YXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKSwKICAgIC8vICAgICB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gKQogICAgZGlnIDUKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTc1LTU4MQogICAgLy8gYXJjNC5lbWl0KAogICAgLy8gICAgIGFiaS5BcmM4OU1ldGFkYXRhRGVsZXRlZCgKICAgIC8vICAgICAgICAgYXNzZXRfaWQ9YXJjNC5VSW50NjQoYXNzZXRfaWQuaWQpLAogICAgLy8gICAgICAgICByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgICAgICB0aW1lc3RhbXA9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIHB1c2hieXRlcyAweGJjM2YyMGQxIC8vIG1ldGhvZCAiQXJjODlNZXRhZGF0YURlbGV0ZWQodWludDY0LHVpbnQ2NCx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTg0CiAgICAvLyBzaWduPWFyYzQuVUludDgoZW51bXMuTUJSX0RFTFRBX05FRyksIGFtb3VudD1hcmM0LlVJbnQ2NChtYnJfZGVsdGFfYW1vdW50KQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzVmZgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X2RlbGV0ZV9tZXRhZGF0YV90ZXJuYXJ5X2ZhbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3MQogICAgLy8gcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciBpZiBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSBlbHNlIFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICBiIGFyYzg5X2RlbGV0ZV9tZXRhZGF0YV90ZXJuYXJ5X21lcmdlQDYKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZXh0cmFfcGF5bG9hZFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2V4dHJhX3BheWxvYWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU4NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGR1cAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MDAtNjAxCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSwgZXJyLkFTQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBUaGUgc3BlY2lmaWVkIEFTQSBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OQogICAgLy8gcmV0dXJuIGFzYSBpbiBzZWxmLmFzc2V0X21ldGFkYXRhCiAgICBkdXAKICAgIGl0b2IKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MDIKICAgIC8vIGFzc2VydCBzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNzZXRfaWQpLCBlcnIuQVNTRVRfTUVUQURBVEFfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gQXNzZXQgTWV0YWRhdGEgZG9lcyBub3QgZXhpc3QgZm9yIHRoZSBzcGVjaWZpZWQgQVNBCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYwMwogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FzYV9tYW5hZ2VyKGFzc2V0X2lkKSwgZXJyLlVOQVVUSE9SSVpFRAogICAgY2FsbHN1YiBfaXNfYXNhX21hbmFnZXIKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQsIG11c3QgYmUgdGhlIEFzc2V0IE1hbmFnZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfc2V0X3JldmVyc2libGVfZmxhZ1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3NldF9yZXZlcnNpYmxlX2ZsYWc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYwNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmJvb2wKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjIxLTYyMgogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDIKICAgIGNhbGxzdWIgX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjIzCiAgICAvLyBhc3NlcnQgZmxhZy5hc191aW50NjQoKSA8PSBmbGcuRkxHX1JFU0VSVkVEXzMsIGVyci5GTEFHX0lEWF9JTlZBTElECiAgICBzd2FwCiAgICBidG9pCiAgICBkdXAKICAgIHB1c2hpbnQgMwogICAgPD0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGZsYWcgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MgogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIHB1c2hpbnQgNwogICAgdW5jb3ZlciAyCiAgICAtCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTAtOTMKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MjcKICAgIC8vIGlmIHZhbHVlLm5hdGl2ZSAhPSBleGlzdGluZ192YWx1ZToKICAgIHN3YXAKICAgIGludGNfMSAvLyAwCiAgICBnZXRiaXQKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICAhPQogICAgYnogYXJjODlfc2V0X3JldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMjQtMjI2CiAgICAvLyB1cGRhdGVkX2ZsYWdzID0gb3Auc2V0Yml0X2J5dGVzKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpLCBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLCB2YWx1ZQogICAgLy8gKQogICAgZGlnIDMKICAgIGRpZyAzCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODAKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMxLTYzMgogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAoKYXJjODlfc2V0X3JldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYwNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZzoKICAgIGludGNfMSAvLyAwCiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYzNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NDgtNjQ5CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY1MQogICAgLy8gZmxnLkZMR19SRVNFUlZFRF82IDw9IGZsYWcuYXNfdWludDY0KCkgPD0gZmxnLkZMR19JTU1VVEFCTEUKICAgIGJ0b2kKICAgIGR1cAogICAgcHVzaGludCA2CiAgICA+PQogICAgYnogYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfZmFsc2VANAogICAgZHVwCiAgICBwdXNoaW50IDcKICAgIDw9CiAgICBieiBhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzAgLy8gMQoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjUwLTY1MgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBmbGcuRkxHX1JFU0VSVkVEXzYgPD0gZmxhZy5hc191aW50NjQoKSA8PSBmbGcuRkxHX0lNTVVUQUJMRQogICAgLy8gKSwgZXJyLkZMQUdfSURYX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIGZsYWcgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBkaWcgMQogICAgaXRvYgogICAgZHVwCiAgICBidXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTIKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICBwdXNoaW50IDcKICAgIGRpZyAyCiAgICAtCiAgICBkdXAKICAgIGJ1cnkgNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MC05MwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY1NgogICAgLy8gaWYgbm90IGV4aXN0aW5nX3ZhbHVlOgogICAgYm56IGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDMKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMjQtMjI2CiAgICAvLyB1cGRhdGVkX2ZsYWdzID0gb3Auc2V0Yml0X2J5dGVzKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpLCBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLCB2YWx1ZQogICAgLy8gKQogICAgZGlnIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjU3LTY1OAogICAgLy8gIyBTZXQgSXJyZXZlcnNpYmxlIEZsYWcKICAgIC8vIHNlbGYuX3NldF9mbGFnKGFzc2V0X2lkLCBmbGFnLmFzX3VpbnQ2NCgpLCB2YWx1ZT1UcnVlKQogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjI0LTIyNgogICAgLy8gdXBkYXRlZF9mbGFncyA9IG9wLnNldGJpdF9ieXRlcygKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywgdmFsdWUKICAgIC8vICkKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4MAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzktODEKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjAtNjYxCiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBIZWFkZXIKICAgIC8vIHNlbGYuX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CgphcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MzQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMSAvLyAwCiAgICBiIGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfc2V0X2ltbXV0YWJsZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3NldF9pbW11dGFibGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY2MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY3NS02NzYKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGR1cAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjI1CiAgICAvLyBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywgdmFsdWUKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY3OC02NzkKICAgIC8vICMgU2V0IEltbXV0YWJsZSBGbGFnCiAgICAvLyBzZWxmLl9zZXRfZmxhZyhhc3NldF9pZCwgVUludDY0KGZsZy5GTEdfSU1NVVRBQkxFKSwgdmFsdWU9VHJ1ZSkKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIyNC0yMjYKICAgIC8vIHVwZGF0ZWRfZmxhZ3MgPSBvcC5zZXRiaXRfYnl0ZXMoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSksIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsIHZhbHVlCiAgICAvLyApCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODAKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjgxLTY4MgogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY2MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhOgogICAgYnl0ZWNfMSAvLyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcwNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzI1CiAgICAvLyBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBjb25zdC5NQVhfTUVUQURBVEFfU0laRQogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjIDYgLy8gMzA1MDcKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyMy03MjYKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBjb25zdC5NQVhfTUVUQURBVEFfU0laRQogICAgLy8gKSwgZXJyLkVYQ0VFRFNfTUFYX01FVEFEQVRBX1NJWkUKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1ldGFkYXRhIHNpemUsIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgaXRvYgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyOAogICAgLy8gaWYgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzI5CiAgICAvLyBtZXRhZGF0YV9zaXplID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGR1cAogICAgYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczMAogICAgLy8gZmxhdF9tYnIgPSBVSW50NjQoMCkKICAgIGludGNfMSAvLyAwCiAgICBidXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMxCiAgICAvLyBpZiBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA9PSBtZXRhZGF0YV9zaXplOgogICAgZGlnIDEKICAgID09CiAgICBieiBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2Vsc2VfYm9keUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczMwogICAgLy8gZGVsdGFfc2l6ZSA9IFVJbnQ2NCgwKQogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMyCiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9OVUxMKQogICAgZHVwCgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2FmdGVyX2lmX2Vsc2VAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0OQogICAgLy8gZGVsdGFfYW1vdW50ID0gZmxhdF9tYnIgKyBjb25zdC5CWVRFX01CUiAqIGRlbHRhX3NpemUKICAgIHB1c2hpbnQgNDAwCiAgICB1bmNvdmVyIDIKICAgICoKICAgIGRpZyA1CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1MQogICAgLy8gcmV0dXJuIGFiaS5NYnJEZWx0YShzaWduPWFyYzQuVUludDgoc2lnbiksIGFtb3VudD1hcmM0LlVJbnQ2NChkZWx0YV9hbW91bnQpKQogICAgc3dhcAogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMiAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcwNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2Vsc2VfYm9keUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MzQKICAgIC8vIGVsaWYgbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkgPiBtZXRhZGF0YV9zaXplOgogICAgZHVwCiAgICBkaWcgMwogICAgPgogICAgYnogYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9lbHNlX2JvZHlANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MzUKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX1BPUykKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczNgogICAgLy8gZGVsdGFfc2l6ZSA9IG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpIC0gbWV0YWRhdGFfc2l6ZQogICAgZGlnIDEKICAgIGRpZyA0CiAgICAtCiAgICBzd2FwCiAgICBiIGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfYWZ0ZXJfaWZfZWxzZUAxMAoKYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9lbHNlX2JvZHlANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzM4CiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9ORUcpCiAgICBwdXNoaW50IDI1NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MzkKICAgIC8vIGRlbHRhX3NpemUgPSBtZXRhZGF0YV9zaXplIC0gbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIGRpZyAzCiAgICBkaWcgMgogICAgLQogICAgc3dhcAogICAgYiBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2FmdGVyX2lmX2Vsc2VAMTAKCmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0MQogICAgLy8gZmxhdF9tYnIgPSBVSW50NjQoY29uc3QuRkxBVF9NQlIpCiAgICBwdXNoaW50IDI1MDAKICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NDIKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX1BPUykKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0NC03NDUKICAgIC8vIGNvbnN0LkFTU0VUX01FVEFEQVRBX0JPWF9LRVlfU0laRQogICAgLy8gKyBjb25zdC5NRVRBREFUQV9IRUFERVJfU0laRQogICAgcHVzaGludCA1MAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NDQtNzQ2CiAgICAvLyBjb25zdC5BU1NFVF9NRVRBREFUQV9CT1hfS0VZX1NJWkUKICAgIC8vICsgY29uc3QuTUVUQURBVEFfSEVBREVSX1NJWkUKICAgIC8vICsgbmV3X21ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIGRpZyAyCiAgICArCiAgICBzd2FwCiAgICBiIGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfYWZ0ZXJfaWZfZWxzZUAxMAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9jaGVja19tZXRhZGF0YV9leGlzdHNbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9jaGVja19tZXRhZGF0YV9leGlzdHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1CiAgICAvLyBfY3JlYXRvciwgZXhpc3RzID0gb3AuQXNzZXRQYXJhbXNHZXQuYXNzZXRfY3JlYXRvcihhc2EpCiAgICBkdXAKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzY5CiAgICAvLyBhc2FfZXhpc3RzPWFyYzQuQm9vbChzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSksCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OQogICAgLy8gcmV0dXJuIGFzYSBpbiBzZWxmLmFzc2V0X21ldGFkYXRhCiAgICBzd2FwCiAgICBpdG9iCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzcwCiAgICAvLyBtZXRhZGF0YV9leGlzdHM9YXJjNC5Cb29sKHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc3NldF9pZCkpLAogICAgYnl0ZWNfMiAvLyAweDAwCiAgICBpbnRjXzEgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzY4LTc3MQogICAgLy8gcmV0dXJuIGFiaS5NZXRhZGF0YUV4aXN0ZW5jZSgKICAgIC8vICAgICBhc2FfZXhpc3RzPWFyYzQuQm9vbChzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSksCiAgICAvLyAgICAgbWV0YWRhdGFfZXhpc3RzPWFyYzQuQm9vbChzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIGludGNfMSAvLyAwCiAgICBnZXRiaXQKICAgIGludGNfMCAvLyAxCiAgICBzd2FwCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUzCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NzMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc4OC03ODkKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTIKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfRkxBRyAtIGZsYWcsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MC05MwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc5MgogICAgLy8gc2VsZi5faXNfaW1tdXRhYmxlKGFzc2V0X2lkKSBvciBhc3NldF9pZC5tYW5hZ2VyID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGJueiBhcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF90cnVlQDMKICAgIGR1cAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgPT0KICAgIGJ6IGFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZV9ib29sX2ZhbHNlQDQKCmFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZV9ib29sX3RydWVAMzoKICAgIGludGNfMCAvLyAxCgphcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3OTEtNzkzCiAgICAvLyByZXR1cm4gYXJjNC5Cb29sKAogICAgLy8gICAgIHNlbGYuX2lzX2ltbXV0YWJsZShhc3NldF9pZCkgb3IgYXNzZXRfaWQubWFuYWdlciA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyApCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NzMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMSAvLyAwCiAgICBiIGFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZV9ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfaXNfbWV0YWRhdGFfc2hvcnRbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9pc19tZXRhZGF0YV9zaG9ydDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Nzk1CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODEwLTgxMQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjIKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjQKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg0LTg3CiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4MTQKICAgIC8vIGZsYWc9YXJjNC5Cb29sKHNlbGYuX2lzX3Nob3J0KGFzc2V0X2lkKSksCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTMtMTE2CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE0CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIHB1c2hpbnQgMzQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE1CiAgICAvLyBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgaW50Y18yIC8vIDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEzLTExNgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTItMTE3CiAgICAvLyByZXR1cm4gb3AuYnRvaSgKICAgIC8vICAgICBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODE1CiAgICAvLyBsYXN0X21vZGlmaWVkX3JvdW5kPWFyYzQuVUludDY0KHNlbGYuX2dldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkKSksCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgxMy04MTYKICAgIC8vIHJldHVybiBhYmkuTXV0YWJsZUZsYWcoCiAgICAvLyAgICAgZmxhZz1hcmM0LkJvb2woc2VsZi5faXNfc2hvcnQoYXNzZXRfaWQpKSwKICAgIC8vICAgICBsYXN0X21vZGlmaWVkX3JvdW5kPWFyYzQuVUludDY0KHNlbGYuX2dldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkKSksCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Nzk1CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlcltyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgxOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgzMy04MzQKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Mi02NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY0CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMi0xMDQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIGludGNfMyAvLyAyCiAgICBwdXNoaW50IDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMi0xMDQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMy0xMTYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgdW5jb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNQogICAgLy8gbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIGludGNfMiAvLyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMy0xMTYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEyLTExNwogICAgLy8gcmV0dXJuIG9wLmJ0b2koCiAgICAvLyAgICAgc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg0MAogICAgLy8gbGFzdF9tb2RpZmllZF9yb3VuZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCkpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4MzYtODQxCiAgICAvLyByZXR1cm4gYWJpLk1ldGFkYXRhSGVhZGVyKAogICAgLy8gICAgIGlkZW50aWZpZXJzPWFyYzQuQnl0ZS5mcm9tX2J5dGVzKHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc3NldF9pZCkpLAogICAgLy8gICAgIGZsYWdzPWFyYzQuQnl0ZS5mcm9tX2J5dGVzKHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc3NldF9pZCkpLAogICAgLy8gICAgIGhhc2g9YWJpLkhhc2guZnJvbV9ieXRlcyhzZWxmLl9nZXRfbWV0YWRhdGFfaGFzaChhc3NldF9pZCkpLAogICAgLy8gICAgIGxhc3RfbW9kaWZpZWRfcm91bmQ9YXJjNC5VSW50NjQoc2VsZi5fZ2V0X2xhc3RfbW9kaWZpZWRfcm91bmQoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODE4CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2luYXRpb25bcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfcGFnaW5hdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODQzCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODU3LTg1OAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYxCiAgICAvLyBtZXRhZGF0YV9zaXplPWFyYzQuVUludDE2KHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSksCiAgICBkdXAKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgcHVzaGludCAxNgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA2IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgwCiAgICAvLyBuID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKQogICAgc3dhcAogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjIxLTIyCiAgICAvLyAjIEFzc3VtZXMgZGVuID49IDEKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIGludGMgNSAvLyAxMDA2CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4MQogICAgLy8gcmV0dXJuIGNlaWxfZGl2KG51bT1uLCBkZW49VUludDY0KGNvbnN0LlBBR0VfU0laRSkpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjEtMjIKICAgIC8vICMgQXNzdW1lcyBkZW4gPj0gMQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NjMKICAgIC8vIHRvdGFsX3BhZ2VzPWFyYzQuVUludDgoc2VsZi5fZ2V0X3RvdGFsX3BhZ2VzKGFzc2V0X2lkKSksCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg2MC04NjQKICAgIC8vIHJldHVybiBhYmkuUGFnaW5hdGlvbigKICAgIC8vICAgICBtZXRhZGF0YV9zaXplPWFyYzQuVUludDE2KHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSksCiAgICAvLyAgICAgcGFnZV9zaXplPWFyYzQuVUludDE2KGNvbnN0LlBBR0VfU0laRSksCiAgICAvLyAgICAgdG90YWxfcGFnZXM9YXJjNC5VSW50OChzZWxmLl9nZXRfdG90YWxfcGFnZXMoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYyCiAgICAvLyBwYWdlX3NpemU9YXJjNC5VSW50MTYoY29uc3QuUEFHRV9TSVpFKSwKICAgIHB1c2hieXRlcyAweDAzZWYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYwLTg2NAogICAgLy8gcmV0dXJuIGFiaS5QYWdpbmF0aW9uKAogICAgLy8gICAgIG1ldGFkYXRhX3NpemU9YXJjNC5VSW50MTYoc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpKSwKICAgIC8vICAgICBwYWdlX3NpemU9YXJjNC5VSW50MTYoY29uc3QuUEFHRV9TSVpFKSwKICAgIC8vICAgICB0b3RhbF9wYWdlcz1hcmM0LlVJbnQ4KHNlbGYuX2dldF90b3RhbF9wYWdlcyhhc3NldF9pZCkpLAogICAgLy8gKQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODQzCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhOgogICAgYnl0ZWNfMSAvLyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NjYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODgzLTg4NAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgwCiAgICAvLyBuID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjIxLTIyCiAgICAvLyAjIEFzc3VtZXMgZGVuID49IDEKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIGludGMgNSAvLyAxMDA2CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4MQogICAgLy8gcmV0dXJuIGNlaWxfZGl2KG51bT1uLCBkZW49VUludDY0KGNvbnN0LlBBR0VfU0laRSkpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjEtMjIKICAgIC8vICMgQXNzdW1lcyBkZW4gPj0gMQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgZHVwCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg4NgogICAgLy8gaWYgdG90YWxfcGFnZXMgPiAwOgogICAgYnogYXJjODlfZ2V0X21ldGFkYXRhX2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg4NwogICAgLy8gYXNzZXJ0IHBhZ2UuYXNfdWludDY0KCkgPCB0b3RhbF9wYWdlcywgZXJyLlBBR0VfSURYX0lOVkFMSUQKICAgIGJ0b2kKICAgIGR1cAogICAgZGlnIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgPAogICAgYXNzZXJ0IC8vIEludmFsaWQgcGFnZSBpbmRleAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4ODgKICAgIC8vIGhhc19uZXh0X3BhZ2UgPSBwYWdlLmFzX3VpbnQ2NCgpIDwgdG90YWxfcGFnZXMgLSAxCiAgICBpbnRjXzAgLy8gMQogICAgLQogICAgZGlnIDEKICAgID4KICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4ODkKICAgIC8vIHBhZ2VfY29udGVudCA9IHNlbGYuX2dldF9tZXRhZGF0YV9wYWdlKGFzc2V0X2lkLCBwYWdlLmFzX3VpbnQ2NCgpKQogICAgZGlnIDIKICAgIHN3YXAKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9wYWdlCgphcmM4OV9nZXRfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4OTYKICAgIC8vIGhhc19uZXh0X3BhZ2U9YXJjNC5Cb29sKGhhc19uZXh0X3BhZ2UpLAogICAgYnl0ZWNfMiAvLyAweDAwCiAgICBpbnRjXzEgLy8gMAogICAgZGlnIDUKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTMKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGRpZyAzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNQogICAgLy8gbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIGludGNfMiAvLyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMy0xMTYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEyLTExNwogICAgLy8gcmV0dXJuIG9wLmJ0b2koCiAgICAvLyAgICAgc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg5NwogICAgLy8gbGFzdF9tb2RpZmllZF9yb3VuZD1hcmM0LlVJbnQ2NChzZWxmLl9nZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCkpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4OTgKICAgIC8vIHBhZ2VfY29udGVudD1hcmM0LkR5bmFtaWNCeXRlcyhwYWdlX2NvbnRlbnQpLAogICAgdW5jb3ZlciAyCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4OTUtODk5CiAgICAvLyByZXR1cm4gYWJpLlBhZ2luYXRlZE1ldGFkYXRhKAogICAgLy8gICAgIGhhc19uZXh0X3BhZ2U9YXJjNC5Cb29sKGhhc19uZXh0X3BhZ2UpLAogICAgLy8gICAgIGxhc3RfbW9kaWZpZWRfcm91bmQ9YXJjNC5VSW50NjQoc2VsZi5fZ2V0X2xhc3RfbW9kaWZpZWRfcm91bmQoYXNzZXRfaWQpKSwKICAgIC8vICAgICBwYWdlX2NvbnRlbnQ9YXJjNC5EeW5hbWljQnl0ZXMocGFnZV9jb250ZW50KSwKICAgIC8vICkKICAgIGNvdmVyIDIKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MDAwYgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODY2CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X2dldF9tZXRhZGF0YV9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODkxCiAgICAvLyBhc3NlcnQgcGFnZS5hc191aW50NjQoKSA9PSAwLCBlcnIuUEFHRV9JRFhfSU5WQUxJRAogICAgYnRvaQogICAgIQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGFnZSBpbmRleAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4OTIKICAgIC8vIGhhc19uZXh0X3BhZ2UgPSBGYWxzZQogICAgaW50Y18xIC8vIDAKICAgIGJ1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4OTMKICAgIC8vIHBhZ2VfY29udGVudCA9IEJ5dGVzKCkKICAgIGJ5dGVjXzEgLy8gMHgKICAgIGIgYXJjODlfZ2V0X21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfc2xpY2Vbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfc2xpY2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyMC05MjEKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMgogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTIyCiAgICAvLyBhc3NlcnQgc2l6ZS5hc191aW50NjQoKSA8PSBjb25zdC5QQUdFX1NJWkUsIGVyci5FWENFRURTX1BBR0VfU0laRQogICAgYnRvaQogICAgZHVwCiAgICBpbnRjIDQgLy8gMTAwNwogICAgPD0KICAgIGFzc2VydCAvLyBQYXlsb2FkIGV4Y2VlZHMgcGFnZSBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyMwogICAgLy8gYXNzZXJ0IG9mZnNldC5hc191aW50NjQoKSArIHNpemUuYXNfdWludDY0KCkgPD0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoCiAgICBzd2FwCiAgICBidG9pCiAgICBkdXAKICAgIGRpZyAyCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyMy05MjUKICAgIC8vIGFzc2VydCBvZmZzZXQuYXNfdWludDY0KCkgKyBzaXplLmFzX3VpbnQ2NCgpIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgLy8gICAgIGFzc2V0X2lkCiAgICAvLyApLCBlcnIuRVhDRUVEU19NRVRBREFUQV9TSVpFCiAgICBkaWcgMwogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIDw9CiAgICBhc3NlcnQgLy8gU2xpY2UgZXhjZWVkcyBtZXRhZGF0YSByYW5nZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MjcKICAgIC8vIG1ldGFkYXRhX3NsaWNlID0gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNzZXRfaWQpLmV4dHJhY3QoCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTI4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBvZmZzZXQuYXNfdWludDY0KCksIGxlbmd0aD1zaXplLmFzX3VpbnQ2NCgpCiAgICBwdXNoaW50IDQyCiAgICB1bmNvdmVyIDIKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTI3LTkyOQogICAgLy8gbWV0YWRhdGFfc2xpY2UgPSBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc3NldF9pZCkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEEgKyBvZmZzZXQuYXNfdWludDY0KCksIGxlbmd0aD1zaXplLmFzX3VpbnQ2NCgpCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJfaGFzaFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTMyCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTQ3LTk0OAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTUwCiAgICAvLyByZXR1cm4gYWJpLkhhc2guZnJvbV9ieXRlcyhzZWxmLl9jb21wdXRlX2hlYWRlcl9oYXNoKGFzc2V0X2lkKSkKICAgIGNhbGxzdWIgX2NvbXB1dGVfaGVhZGVyX2hhc2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTMyCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9wYWdlX2hhc2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk1MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTY5LTk3MAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODAKICAgIC8vIG4gPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fY29tbW9uLnB5OjIxLTIyCiAgICAvLyAjIEFzc3VtZXMgZGVuID49IDEKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIGludGMgNSAvLyAxMDA2CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4MQogICAgLy8gcmV0dXJuIGNlaWxfZGl2KG51bT1uLCBkZW49VUludDY0KGNvbnN0LlBBR0VfU0laRSkpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjEtMjIKICAgIC8vICMgQXNzdW1lcyBkZW4gPj0gMQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NzIKICAgIC8vIGlmIHRvdGFsX3BhZ2VzID4gMDoKICAgIGR1cAogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIGlzIGVtcHR5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3MwogICAgLy8gYXNzZXJ0IHBhZ2UuYXNfdWludDY0KCkgPCB0b3RhbF9wYWdlcywgZXJyLlBBR0VfSURYX0lOVkFMSUQKICAgIHN3YXAKICAgIGJ0b2kKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICA8CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYWdlIGluZGV4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3NwogICAgLy8gcGFnZV9jb250ZW50ID0gc2VsZi5fZ2V0X21ldGFkYXRhX3BhZ2UoYXNzZXRfaWQsIHBhZ2UuYXNfdWludDY0KCkpCiAgICBkdXAyCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfcGFnZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NzgKICAgIC8vIHBhZ2VfaGFzaCA9IHNlbGYuX2NvbXB1dGVfcGFnZV9oYXNoKGFzc2V0X2lkLCBwYWdlLmFzX3VpbnQ2NCgpLCBwYWdlX2NvbnRlbnQpCiAgICBjYWxsc3ViIF9jb21wdXRlX3BhZ2VfaGFzaAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfaGFzaFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9oYXNoOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5ODEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OTYtOTk3CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDIKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIGludGNfMyAvLyAyCiAgICBwdXNoaW50IDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMi0xMDQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk4MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9zdHJpbmdfYnlfa2V5W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX3N0cmluZ19ieV9rZXk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMDEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDE5LTEwMjAKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAyMgogICAgLy8gb2JqID0gc2VsZi5fZ2V0X3Nob3J0X21ldGFkYXRhKGFzc2V0X2lkKQogICAgc3dhcAogICAgY2FsbHN1YiBfZ2V0X3Nob3J0X21ldGFkYXRhCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMjMKICAgIC8vIHZhbHVlID0gb3AuSnNvblJlZi5qc29uX3N0cmluZyhvYmosIGtleS5uYXRpdmUuYnl0ZXMpCiAgICBzd2FwCiAgICBleHRyYWN0IDIgMAogICAganNvbl9yZWYgSlNPTlN0cmluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDI1LTEwMjYKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCB2YWx1ZS5sZW5ndGggPD0gY29uc3QuUEFHRV9TSVpFLCBlcnIuRVhDRUVEU19QQUdFX1NJWkUKICAgIGR1cAogICAgbGVuCiAgICBpbnRjIDQgLy8gMTAwNwogICAgPD0KICAgIGFzc2VydCAvLyBQYXlsb2FkIGV4Y2VlZHMgcGFnZSBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMDEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfdWludDY0X2J5X2tleVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDMwCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA0OC0xMDQ5CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNTEKICAgIC8vIG9iaiA9IHNlbGYuX2dldF9zaG9ydF9tZXRhZGF0YShhc3NldF9pZCkKICAgIHN3YXAKICAgIGNhbGxzdWIgX2dldF9zaG9ydF9tZXRhZGF0YQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDUyCiAgICAvLyB2YWx1ZSA9IG9wLkpzb25SZWYuanNvbl91aW50NjQob2JqLCBrZXkubmF0aXZlLmJ5dGVzKQogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGpzb25fcmVmIEpTT05VaW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA1NAogICAgLy8gcmV0dXJuIGFyYzQuVUludDY0KHZhbHVlKQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDMwCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX29iamVjdF9ieV9rZXlbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA1NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNzQtMTA3NQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDc3CiAgICAvLyBvYmogPSBzZWxmLl9nZXRfc2hvcnRfbWV0YWRhdGEoYXNzZXRfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfc2hvcnRfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3OAogICAgLy8gdmFsdWUgPSBvcC5Kc29uUmVmLmpzb25fb2JqZWN0KG9iaiwga2V5Lm5hdGl2ZS5ieXRlcykKICAgIHN3YXAKICAgIGV4dHJhY3QgMiAwCiAgICBqc29uX3JlZiBKU09OT2JqZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwODAtMTA4MQogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IHZhbHVlLmxlbmd0aCA8PSBjb25zdC5QQUdFX1NJWkUsIGVyci5FWENFRURTX1BBR0VfU0laRQogICAgZHVwCiAgICBsZW4KICAgIGludGMgNCAvLyAxMDA3CiAgICA8PQogICAgYXNzZXJ0IC8vIFBheWxvYWQgZXhjZWVkcyBwYWdlIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA1NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9pc19hc2FfbWFuYWdlcihhc2E6IHVpbnQ2NCkgLT4gdWludDY0OgpfaXNfYXNhX21hbmFnZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUxCiAgICAvLyBkZWYgX2lzX2FzYV9tYW5hZ2VyKHNlbGYsIGFzYTogQXNzZXQpIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTIKICAgIC8vIHJldHVybiBUeG4uc2VuZGVyID09IGFzYS5tYW5hZ2VyCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICA9PQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9nZXRfbWV0YWRhdGFfc2l6ZShhc2E6IHVpbnQ2NCkgLT4gdWludDY0OgpfZ2V0X21ldGFkYXRhX3NpemU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNQogICAgLy8gZGVmIF9nZXRfbWV0YWRhdGFfc2l6ZShzZWxmLCBhc2E6IEFzc2V0KSAtPiBVSW50NjQ6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5sZW5ndGggLSBjb25zdC5NRVRBREFUQV9IRUFERVJfU0laRQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gY2hlY2sgQm94IGV4aXN0cwogICAgcHVzaGludCA0MgogICAgLQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9hcHBlbmRfcGF5bG9hZChhc2E6IHVpbnQ2NCwgcGF5bG9hZDogYnl0ZXMpIC0+IHZvaWQ6Cl9hcHBlbmRfcGF5bG9hZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI4CiAgICAvLyBkZWYgX2FwcGVuZF9wYXlsb2FkKHNlbGYsIGFzYTogQXNzZXQsIHBheWxvYWQ6IEJ5dGVzKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyOQogICAgLy8gb2xkX2Fzc2V0X21ldGFkYXRhX2JveF9zaXplID0gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5sZW5ndGgKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgZHVwCiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gY2hlY2sgQm94IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzEKICAgIC8vIG5ld19zaXplPW9sZF9hc3NldF9tZXRhZGF0YV9ib3hfc2l6ZSArIHBheWxvYWQubGVuZ3RoCiAgICBmcmFtZV9kaWcgLTEKICAgIGxlbgogICAgZGlnIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMwLTEzMgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXNpemUoCiAgICAvLyAgICAgbmV3X3NpemU9b2xkX2Fzc2V0X21ldGFkYXRhX2JveF9zaXplICsgcGF5bG9hZC5sZW5ndGgKICAgIC8vICkKICAgIGRpZyAyCiAgICBzd2FwCiAgICBib3hfcmVzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMy0xMzUKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1vbGRfYXNzZXRfbWV0YWRhdGFfYm94X3NpemUsIHZhbHVlPXBheWxvYWQKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgYm94X3JlcGxhY2UKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fc2V0X21ldGFkYXRhX3BheWxvYWQoYXNhOiB1aW50NjQsIG1ldGFkYXRhX3NpemU6IHVpbnQ2NCwgcGF5bG9hZDogYnl0ZXMpIC0+IHZvaWQ6Cl9zZXRfbWV0YWRhdGFfcGF5bG9hZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTUzLTE1NQogICAgLy8gZGVmIF9zZXRfbWV0YWRhdGFfcGF5bG9hZCgKICAgIC8vICAgICBzZWxmLCBhc2E6IEFzc2V0LCBtZXRhZGF0YV9zaXplOiBVSW50NjQsIHBheWxvYWQ6IEJ5dGVzCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAzIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTU2LTE1NwogICAgLy8gIyBFcmFzZSBleGlzdGluZyBtZXRhZGF0YSBwYXlsb2FkCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlc2l6ZShuZXdfc2l6ZT1VSW50NjQoY29uc3QuTUVUQURBVEFfSEVBREVSX1NJWkUpKQogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICBkdXAKICAgIHB1c2hpbnQgNDIKICAgIGJveF9yZXNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTU5LTE2MAogICAgLy8gIyBBcHBlbmQgcHJvdmlkZWQgcGF5bG9hZAogICAgLy8gc2VsZi5fYXBwZW5kX3BheWxvYWQoYXNhLCBwYXlsb2FkKQogICAgZnJhbWVfZGlnIC0zCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2FwcGVuZF9wYXlsb2FkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2Mi0xNjMKICAgIC8vICMgQXBwZW5kIHN0YWdlZCBleHRyYSBwYXlsb2FkIChpbiB0aGUgc2FtZSBHcm91cCwgaWYgYW55KQogICAgLy8gZ3JvdXBfc2l6ZSA9IEdsb2JhbC5ncm91cF9zaXplCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2NAogICAgLy8gZ3JvdXBfaW5kZXggPSBUeG4uZ3JvdXBfaW5kZXgKICAgIHR4biBHcm91cEluZGV4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2NQogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoZ3JvdXBfaW5kZXggKyAxLCBncm91cF9zaXplKToKICAgIGludGNfMCAvLyAxCiAgICArCgpfc2V0X21ldGFkYXRhX3BheWxvYWRfZm9yX2hlYWRlckAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNjUKICAgIC8vIGZvciBpZHggaW4gdXJhbmdlKGdyb3VwX2luZGV4ICsgMSwgZ3JvdXBfc2l6ZSk6CiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDEKICAgIDwKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9hZnRlcl9mb3JANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzkKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIGZyYW1lX2RpZyAyCiAgICBndHhucyBUeXBlRW51bQogICAgcHVzaGludCA2IC8vIGFwcGwKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzOS0xNDQKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDAKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICBmcmFtZV9kaWcgMgogICAgZ3R4bnMgQXBwbGljYXRpb25JRAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzktMTQ0CiAgICAvLyB0eG4udHlwZSA9PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyBhbmQgdHhuLmFwcF9pZCA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZAogICAgLy8gYW5kIHR4bi5vbl9jb21wbGV0aW9uID09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM0X0FSR19NRVRIT0RfU0VMRUNUT1IpCiAgICAvLyA9PSBhcmM0LmFyYzRfc2lnbmF0dXJlKEFzYU1ldGFkYXRhUmVnaXN0cnlJbnRlcmZhY2UuYXJjODlfZXh0cmFfcGF5bG9hZCkKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDODlfRVhUUkFfUEFZTE9BRF9BUkdfQVNTRVRfSUQpID09IG9wLml0b2IoYXNhLmlkKQogICAgYnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfZmFsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQxCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICBmcmFtZV9kaWcgMgogICAgZ3R4bnMgT25Db21wbGV0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzOS0xNDQKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBibnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfZmFsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQyCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzEgLy8gMAogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQzCiAgICAvLyA9PSBhcmM0LmFyYzRfc2lnbmF0dXJlKEFzYU1ldGFkYXRhUmVnaXN0cnlJbnRlcmZhY2UuYXJjODlfZXh0cmFfcGF5bG9hZCkKICAgIGJ5dGVjXzMgLy8gbWV0aG9kICJhcmM4OV9leHRyYV9wYXlsb2FkKHVpbnQ2NCxieXRlW10pdm9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQyLTE0MwogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM0X0FSR19NRVRIT0RfU0VMRUNUT1IpCiAgICAvLyA9PSBhcmM0LmFyYzRfc2lnbmF0dXJlKEFzYU1ldGFkYXRhUmVnaXN0cnlJbnRlcmZhY2UuYXJjODlfZXh0cmFfcGF5bG9hZCkKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzOS0xNDQKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDQKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDODlfRVhUUkFfUEFZTE9BRF9BUkdfQVNTRVRfSUQpID09IG9wLml0b2IoYXNhLmlkKQogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMCAvLyAxCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDAKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzOS0xNDQKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzRfQVJHX01FVEhPRF9TRUxFQ1RPUikKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXNhTWV0YWRhdGFSZWdpc3RyeUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxNQogICAgaW50Y18wIC8vIDEKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX21lcmdlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNjcKICAgIC8vIGlmIHNlbGYuX2lzX2V4dHJhX3BheWxvYWRfdHhuKGFzYSwgdHhuKToKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQ4LTE1MQogICAgLy8gIyBUaGlzIHN1YnJvdXRpbmUgYXNzdW1lcyB0eG4gaXMgYWxyZWFkeSB2YWxpZGF0ZWQgYXMgYW4gZXh0cmEgcGF5bG9hZCB0eG4KICAgIC8vIHJldHVybiBhcmM0LkR5bmFtaWNCeXRlcy5mcm9tX2J5dGVzKAogICAgLy8gICAgIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19QQVlMT0FEKQogICAgLy8gKS5uYXRpdmUKICAgIGZyYW1lX2RpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1MAogICAgLy8gdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX1BBWUxPQUQpCiAgICBpbnRjXzMgLy8gMgogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQ4LTE1MQogICAgLy8gIyBUaGlzIHN1YnJvdXRpbmUgYXNzdW1lcyB0eG4gaXMgYWxyZWFkeSB2YWxpZGF0ZWQgYXMgYW4gZXh0cmEgcGF5bG9hZCB0eG4KICAgIC8vIHJldHVybiBhcmM0LkR5bmFtaWNCeXRlcy5mcm9tX2J5dGVzKAogICAgLy8gICAgIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19QQVlMT0FEKQogICAgLy8gKS5uYXRpdmUKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE3MAogICAgLy8gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSArIGV4dHJhX3BheWxvYWQubGVuZ3RoIDw9IG1ldGFkYXRhX3NpemUKICAgIGZyYW1lX2RpZyAtMwogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGRpZyAxCiAgICBsZW4KICAgICsKICAgIGZyYW1lX2RpZyAtMgogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTY5LTE3MQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpICsgZXh0cmFfcGF5bG9hZC5sZW5ndGggPD0gbWV0YWRhdGFfc2l6ZQogICAgLy8gKSwgZXJyLlBBWUxPQURfT1ZFUkZMT1cKICAgIGFzc2VydCAvLyBQYXlsb2FkIG92ZXJmbG93LCBleGNlZWRzIG1ldGFkYXRhIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTcyCiAgICAvLyBzZWxmLl9hcHBlbmRfcGF5bG9hZChhc2EsIGV4dHJhX3BheWxvYWQpCiAgICBmcmFtZV9kaWcgLTMKICAgIHN3YXAKICAgIGNhbGxzdWIgX2FwcGVuZF9wYXlsb2FkCgpfc2V0X21ldGFkYXRhX3BheWxvYWRfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNjUKICAgIC8vIGZvciBpZHggaW4gdXJhbmdlKGdyb3VwX2luZGV4ICsgMSwgZ3JvdXBfc2l6ZSk6CiAgICBmcmFtZV9kaWcgMgogICAgaW50Y18wIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMgogICAgYiBfc2V0X21ldGFkYXRhX3BheWxvYWRfZm9yX2hlYWRlckAxCgpfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxNToKICAgIGludGNfMSAvLyAwCiAgICBiIF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX21lcmdlQDE2Cgpfc2V0X21ldGFkYXRhX3BheWxvYWRfYWZ0ZXJfZm9yQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE3MwogICAgLy8gYXNzZXJ0IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkgPT0gbWV0YWRhdGFfc2l6ZSwgZXJyLk1FVEFEQVRBX1NJWkVfTUlTTUFUQ0gKICAgIGZyYW1lX2RpZyAtMwogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGZyYW1lX2RpZyAtMgogICAgPT0KICAgIGFzc2VydCAvLyBNZXRhZGF0YSBzaXplIG1pc21hdGNoLCBtdXN0IGJlIGV4YWN0bHkgZXF1YWwgdG8gZGVjbGFyZWQgc2l6ZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9nZXRfbWV0YWRhdGFfcGFnZShhc2E6IHVpbnQ2NCwgcGFnZV9pbmRleDogdWludDY0KSAtPiBieXRlczoKX2dldF9tZXRhZGF0YV9wYWdlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODMKICAgIC8vIGRlZiBfZ2V0X21ldGFkYXRhX3BhZ2Uoc2VsZiwgYXNhOiBBc3NldCwgcGFnZV9pbmRleDogVUludDY0KSAtPiBCeXRlczoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTEKICAgIC8vIG4gPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBmcmFtZV9kaWcgLTIKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTkzCiAgICAvLyBzdGFydCA9IHBhZ2VfaW5kZXggKiBwcwogICAgZnJhbWVfZGlnIC0xCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE5MAogICAgLy8gcHMgPSBVSW50NjQoY29uc3QuUEFHRV9TSVpFKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTkzCiAgICAvLyBzdGFydCA9IHBhZ2VfaW5kZXggKiBwcwogICAgKgogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTk0CiAgICAvLyBpZiBzdGFydCA+PSBuOgogICAgPj0KICAgIGJ6IF9nZXRfbWV0YWRhdGFfcGFnZV9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTk1LTE5NgogICAgLy8gIyBPdXQtb2YtcmFuZ2UgcGFnZSAoaW5jbHVkaW5nIGVtcHR5IG1ldGFkYXRhIHdpdGggcGFnZV9pbmRleCA+IDApCiAgICAvLyByZXR1cm4gQnl0ZXMoYiIiKQogICAgYnl0ZWNfMSAvLyAweAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCl9nZXRfbWV0YWRhdGFfcGFnZV9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE5OAogICAgLy8gcmVtYWluaW5nID0gbiAtIHN0YXJ0CiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDEKICAgIGR1cAogICAgY292ZXIgMgogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTAKICAgIC8vIHBzID0gVUludDY0KGNvbnN0LlBBR0VfU0laRSkKICAgIGludGMgNCAvLyAxMDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToxNgogICAgLy8gcmV0dXJuIGEgaWYgYSA8IGIgZWxzZSBiCiAgICBkaWcgMQogICAgPAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTAKICAgIC8vIHBzID0gVUludDY0KGNvbnN0LlBBR0VfU0laRSkKICAgIGludGMgNCAvLyAxMDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToxNgogICAgLy8gcmV0dXJuIGEgaWYgYSA8IGIgZWxzZSBiCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjAxCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwMgogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgc3RhcnQsIGxlbmd0aD1sZW5ndGgKICAgIHB1c2hpbnQgNDIKICAgIHVuY292ZXIgMwogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMDEtMjAzCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIHN0YXJ0LCBsZW5ndGg9bGVuZ3RoCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIGJveF9leHRyYWN0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fZ2V0X3Nob3J0X21ldGFkYXRhKGFzYTogdWludDY0KSAtPiBieXRlczoKX2dldF9zaG9ydF9tZXRhZGF0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjEwCiAgICAvLyBkZWYgX2dldF9zaG9ydF9tZXRhZGF0YShzZWxmLCBhc2E6IEFzc2V0KSAtPiBCeXRlczoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Mi02NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY0CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg2CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NC04NwogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjExCiAgICAvLyBhc3NlcnQgc2VsZi5faXNfc2hvcnQoYXNhKSwgZXJyLk1FVEFEQVRBX05PVF9TSE9SVAogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIGlzIG5vdCBzaG9ydAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTIKICAgIC8vIHJldHVybiBzZWxmLl9nZXRfc2xpY2UoYXNhLCBVSW50NjQoMCksIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwNwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LCBsZW5ndGg9c2l6ZQogICAgcHVzaGludCA0MgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMDYtMjA4CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldCwgbGVuZ3RoPXNpemUKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxMgogICAgLy8gcmV0dXJuIHNlbGYuX2dldF9zbGljZShhc2EsIFVJbnQ2NCgwKSwgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5faWRlbnRpZnlfbWV0YWRhdGEoYXNhOiB1aW50NjQpIC0+IHZvaWQ6Cl9pZGVudGlmeV9tZXRhZGF0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjE0CiAgICAvLyBkZWYgX2lkZW50aWZ5X21ldGFkYXRhKHNlbGYsIGFzYTogQXNzZXQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjE1CiAgICAvLyBtZXRhZGF0YV9zaXplID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Mi02NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY0CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU4CiAgICAvLyByZXR1cm4gbWV0YWRhdGFfc2l6ZSA8PSBjb25zdC5TSE9SVF9NRVRBREFUQV9TSVpFCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgNDA5NgogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjE4CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMTYtMjIwCiAgICAvLyBpZGVudGlmaWVycyA9IG9wLnNldGJpdF9ieXRlcygKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyAgICAgc2VsZi5faXNfc2hvcnRfbWV0YWRhdGFfc2l6ZShtZXRhZGF0YV9zaXplKSwKICAgIC8vICkKICAgIHN3YXAKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2OQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLCB2YWx1ZT1pZGVudGlmaWVycwogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjgtNzAKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsIHZhbHVlPWlkZW50aWZpZXJzCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9jb21wdXRlX2hlYWRlcl9oYXNoKGFzYTogdWludDY0KSAtPiBieXRlczoKX2NvbXB1dGVfaGVhZGVyX2hhc2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIyOQogICAgLy8gZGVmIF9jb21wdXRlX2hlYWRlcl9oYXNoKHNlbGYsIGFzYTogQXNzZXQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzMgogICAgLy8gYXNzZXRfaWQgPSBvcC5pdG9iKGFzYS5pZCkKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Mi02NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY0CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyLTY1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzNgogICAgLy8gdWludD1zZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpLAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MTEKICAgIC8vIHJldHVybiBvcC5leHRyYWN0KG9wLml0b2IodWludCksIHN0YXJ0LCBzaXplKQogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjMwLTIzMQogICAgLy8gIyBoaCA9IFNIQSAtIDUxMiAvIDI1NigiYXJjMDA4OS9oZWFkZXIiIHx8IEFzc2V0IElEIHx8IE1ldGFkYXRhIElkZW50aWZpZXJzIHx8IE1ldGFkYXRhIEZsYWdzIHx8IE1ldGFkYXRhIFNpemUpCiAgICAvLyBkb21haW4gPSBCeXRlcyhjb25zdC5IQVNIX0RPTUFJTl9IRUFERVIpCiAgICBwdXNoYnl0ZXMgMHg2MTcyNjMzMDMwMzgzOTJmNjg2NTYxNjQ2NTcyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0MAogICAgLy8gZG9tYWluICsgYXNzZXRfaWQgKyBtZXRhZGF0YV9pZGVudGlmaWVycyArIG1ldGFkYXRhX2ZsYWdzICsgbWV0YWRhdGFfc2l6ZQogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzOS0yNDEKICAgIC8vIHJldHVybiBvcC5zaGE1MTJfMjU2KAogICAgLy8gICAgIGRvbWFpbiArIGFzc2V0X2lkICsgbWV0YWRhdGFfaWRlbnRpZmllcnMgKyBtZXRhZGF0YV9mbGFncyArIG1ldGFkYXRhX3NpemUKICAgIC8vICkKICAgIHNoYTUxMl8yNTYKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY29tcHV0ZV9wYWdlX2hhc2goYXNhOiB1aW50NjQsIHBhZ2VfaW5kZXg6IHVpbnQ2NCwgcGFnZV9jb250ZW50OiBieXRlcykgLT4gYnl0ZXM6Cl9jb21wdXRlX3BhZ2VfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjQzLTI0NQogICAgLy8gZGVmIF9jb21wdXRlX3BhZ2VfaGFzaCgKICAgIC8vICAgICBzZWxmLCBhc2E6IEFzc2V0LCBwYWdlX2luZGV4OiBVSW50NjQsIHBhZ2VfY29udGVudDogQnl0ZXMKICAgIC8vICkgLT4gQnl0ZXM6CiAgICBwcm90byAzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjQ4CiAgICAvLyBhc3NldF9pZCA9IG9wLml0b2IoYXNhLmlkKQogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToxMQogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI1MQogICAgLy8gdWludD1wYWdlX2NvbnRlbnQubGVuZ3RoLCBzaXplPVVJbnQ2NChjb25zdC5VSU5UMTZfU0laRSkKICAgIGZyYW1lX2RpZyAtMQogICAgbGVuCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToxMQogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNDYtMjQ3CiAgICAvLyAjIHBoW2ldID0gU0hBLTUxMi8yNTYoImFyYzAwODkvcGFnZSIgfHwgQXNzZXQgSUQgfHwgUGFnZSBJbmRleCB8fCBQYWdlIFNpemUgfHwgUGFnZSBDb250ZW50KQogICAgLy8gZG9tYWluID0gQnl0ZXMoY29uc3QuSEFTSF9ET01BSU5fUEFHRSkKICAgIHB1c2hieXRlcyAweDYxNzI2MzMwMzAzODM5MmY3MDYxNjc2NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNTMKICAgIC8vIHJldHVybiBvcC5zaGE1MTJfMjU2KGRvbWFpbiArIGFzc2V0X2lkICsgcGFnZV9pZHggKyBwYWdlX3NpemUgKyBwYWdlX2NvbnRlbnQpCiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIHNoYTUxMl8yNTYKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY29tcHV0ZV9tZXRhZGF0YV9oYXNoKGFzYTogdWludDY0KSAtPiBieXRlczoKX2NvbXB1dGVfbWV0YWRhdGFfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjU1CiAgICAvLyBkZWYgX2NvbXB1dGVfbWV0YWRhdGFfaGFzaChzZWxmLCBhc2E6IEFzc2V0KSAtPiBCeXRlczoKICAgIHByb3RvIDEgMQogICAgYnl0ZWNfMSAvLyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNTkKICAgIC8vIGhoID0gc2VsZi5fY29tcHV0ZV9oZWFkZXJfaGFzaChhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2NvbXB1dGVfaGVhZGVyX2hhc2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgwCiAgICAvLyBuID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9jb21tb24ucHk6MjEtMjIKICAgIC8vICMgQXNzdW1lcyBkZW4gPj0gMQogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgaW50YyA1IC8vIDEwMDYKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTgxCiAgICAvLyByZXR1cm4gY2VpbF9kaXYobnVtPW4sIGRlbj1VSW50NjQoY29uc3QuUEFHRV9TSVpFKSkKICAgIGludGMgNCAvLyAxMDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2NvbW1vbi5weToyMS0yMgogICAgLy8gIyBBc3N1bWVzIGRlbiA+PSAxCiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICAvCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjYxCiAgICAvLyBjb25jYXRlbmF0ZWRfcGggPSBCeXRlcygpCiAgICBieXRlY18xIC8vIDB4CiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2MgogICAgLy8gaWYgdG90YWxfcGFnZXMgPiAwOgogICAgYnogX2NvbXB1dGVfbWV0YWRhdGFfaGFzaF9hZnRlcl9pZl9lbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjYzCiAgICAvLyBmb3IgcGFnZV9pbmRleCBpbiB1cmFuZ2UoMCwgdG90YWxfcGFnZXMpOgogICAgaW50Y18xIC8vIDAKICAgIGZyYW1lX2J1cnkgMAoKX2NvbXB1dGVfbWV0YWRhdGFfaGFzaF9mb3JfaGVhZGVyQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2MwogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKDAsIHRvdGFsX3BhZ2VzKToKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMgogICAgPAogICAgYnogX2NvbXB1dGVfbWV0YWRhdGFfaGFzaF9hZnRlcl9pZl9lbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjY0CiAgICAvLyBwYWdlX2NvbnRlbnQgPSBzZWxmLl9nZXRfbWV0YWRhdGFfcGFnZShhc2EsIHBhZ2VfaW5kZXgpCiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9wYWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2NQogICAgLy8gcGggPSBzZWxmLl9jb21wdXRlX3BhZ2VfaGFzaChhc2EsIHBhZ2VfaW5kZXgsIHBhZ2VfY29udGVudCkKICAgIGZyYW1lX2RpZyAtMQogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfY29tcHV0ZV9wYWdlX2hhc2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjY2CiAgICAvLyBjb25jYXRlbmF0ZWRfcGggKz0gcGgKICAgIGZyYW1lX2RpZyAzCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjMKICAgIC8vIGZvciBwYWdlX2luZGV4IGluIHVyYW5nZSgwLCB0b3RhbF9wYWdlcyk6CiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAwCiAgICBiIF9jb21wdXRlX21ldGFkYXRhX2hhc2hfZm9yX2hlYWRlckAyCgpfY29tcHV0ZV9tZXRhZGF0YV9oYXNoX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjU2LTI1OAogICAgLy8gIyBhbSA9IFNIQS01MTIvMjU2KCJhcmMwMDg5L2FtIiB8fCBoaCB8fCBwaFswXSB8fCBwaFsxXSB8fCAuLi4gfHwgcGhbdG90YWxfcGFnZXMgLSAxXSkgb3IKICAgIC8vICMgYW0gPSBTSEEtNTEyLzI1NigiYXJjMDA4OS9hbSIgfHwgaGgpLCBpZiBubyBwYWdlcwogICAgLy8gZG9tYWluID0gQnl0ZXMoY29uc3QuSEFTSF9ET01BSU5fTUVUQURBVEEpCiAgICBwdXNoYnl0ZXMgMHg2MTcyNjMzMDMwMzgzOTJmNjE2ZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjcKICAgIC8vIHJldHVybiBvcC5zaGE1MTJfMjU2KGRvbWFpbiArIGhoICsgY29uY2F0ZW5hdGVkX3BoKQogICAgZnJhbWVfZGlnIDEKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDMKICAgIGNvbmNhdAogICAgc2hhNTEyXzI1NgogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NoZWNrX2Jhc2VfcHJlY29uZGl0aW9ucyhhc2E6IHVpbnQ2NCwgbWV0YWRhdGFfc2l6ZTogdWludDY0KSAtPiB2b2lkOgpfY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjkKICAgIC8vIGRlZiBfY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zKHNlbGYsIGFzYTogQXNzZXQsIG1ldGFkYXRhX3NpemU6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NQogICAgLy8gX2NyZWF0b3IsIGV4aXN0cyA9IG9wLkFzc2V0UGFyYW1zR2V0LmFzc2V0X2NyZWF0b3IoYXNhKQogICAgZnJhbWVfZGlnIC0yCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0Q3JlYXRvcgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3MAogICAgLy8gYXNzZXJ0IHNlbGYuX2FzYV9leGlzdHMoYXNhKSwgZXJyLkFTQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBUaGUgc3BlY2lmaWVkIEFTQSBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNzEKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hc2FfbWFuYWdlcihhc2EpLCBlcnIuVU5BVVRIT1JJWkVECiAgICBmcmFtZV9kaWcgLTIKICAgIGNhbGxzdWIgX2lzX2FzYV9tYW5hZ2VyCiAgICBhc3NlcnQgLy8gVW5hdXRob3JpemVkLCBtdXN0IGJlIHRoZSBBc3NldCBNYW5hZ2VyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1CiAgICAvLyByZXR1cm4gbWV0YWRhdGFfc2l6ZSA8PSBjb25zdC5NQVhfTUVUQURBVEFfU0laRQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnRjIDYgLy8gMzA1MDcKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3Mi0yNzQKICAgIC8vIGFzc2VydCBzZWxmLl9pc192YWxpZF9tYXhfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBtZXRhZGF0YV9zaXplCiAgICAvLyApLCBlcnIuRVhDRUVEU19NQVhfTUVUQURBVEFfU0laRQogICAgYXNzZXJ0IC8vIEludmFsaWQgTWV0YWRhdGEgc2l6ZSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucyhhc2E6IHVpbnQ2NCwgbWV0YWRhdGFfc2l6ZTogdWludDY0KSAtPiB2b2lkOgpfY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3NgogICAgLy8gZGVmIF9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucyhzZWxmLCBhc2E6IEFzc2V0LCBtZXRhZGF0YV9zaXplOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjc3CiAgICAvLyBzZWxmLl9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnMoYXNhLCBtZXRhZGF0YV9zaXplKQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2NoZWNrX2Jhc2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OQogICAgLy8gcmV0dXJuIGFzYSBpbiBzZWxmLmFzc2V0X21ldGFkYXRhCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3OAogICAgLy8gYXNzZXJ0IHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc2EpLCBlcnIuQVNTRVRfTUVUQURBVEFfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gQXNzZXQgTWV0YWRhdGEgZG9lcyBub3QgZXhpc3QgZm9yIHRoZSBzcGVjaWZpZWQgQVNBCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTAtOTMKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNzkKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5faXNfaW1tdXRhYmxlKGFzYSksIGVyci5JTU1VVEFCTEUKICAgICEKICAgIGFzc2VydCAvLyBNZXRhZGF0YSBpcyBpbW11dGFibGUKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNhOiB1aW50NjQpIC0+IHZvaWQ6Cl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9uczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjgxCiAgICAvLyBkZWYgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKHNlbGYsIGFzYTogQXNzZXQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODIKICAgIC8vIGFzc2VydCBzZWxmLl9hc2FfZXhpc3RzKGFzYSksIGVyci5BU0FfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gVGhlIHNwZWNpZmllZCBBU0EgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDkKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjgzCiAgICAvLyBhc3NlcnQgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzYSksIGVyci5BU1NFVF9NRVRBREFUQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhhc2E6IHVpbnQ2NCkgLT4gdm9pZDoKX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI4NQogICAgLy8gZGVmIF9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zKHNlbGYsIGFzYTogQXNzZXQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjg2CiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfRkxBR1MsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkyCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0ZMQUcgLSBmbGFnLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTAtOTMKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODcKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5faXNfaW1tdXRhYmxlKGFzYSksIGVyci5JTU1VVEFCTEUKICAgICEKICAgIGFzc2VydCAvLyBNZXRhZGF0YSBpcyBpbW11dGFibGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjg4CiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXNhX21hbmFnZXIoYXNhKSwgZXJyLlVOQVVUSE9SSVpFRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9pc19hc2FfbWFuYWdlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZCwgbXVzdCBiZSB0aGUgQXNzZXQgTWFuYWdlcgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc2E6IHVpbnQ2NCkgLT4gdm9pZDoKX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyOTAKICAgIC8vIGRlZiBfdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQoc2VsZiwgYXNhOiBBc3NldCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyOTEKICAgIC8vIHNlbGYuX2lkZW50aWZ5X21ldGFkYXRhKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfaWRlbnRpZnlfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjkyLTI5MwogICAgLy8gIyDimqDvuI8gVGhlIHN1YnJvdXRpbmUgYXNzdW1lcyB0aGF0IE1ldGFkYXRhIEZsYWdzIGhhdmUgYWxyZWFkeSBiZWVuIHNldAogICAgLy8gbWV0YWRhdGFfaGFzaCA9IHNlbGYuX2NvbXB1dGVfbWV0YWRhdGFfaGFzaChhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2NvbXB1dGVfbWV0YWRhdGFfaGFzaAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDcKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDctMTA5CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDgKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCB2YWx1ZT1tZXRhZGF0YV9oYXNoCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDctMTA5CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIC8vICkKICAgIGRpZyAzCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyOTUKICAgIC8vIHNlbGYuX3NldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzYSwgR2xvYmFsLnJvdW5kKQogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMgogICAgLy8gdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIwLTEyMwogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgIHZhbHVlPW9wLml0b2IobGFzdF9tb2RpZmllZF9yb3VuZCksCiAgICAvLyApCiAgICBkaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjEKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgcHVzaGludCAzNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjAtMTIzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Mjk5CiAgICAvLyByb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgZ2xvYmFsIFJvdW5kCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMwMAogICAgLy8gdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzUKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9GTEFHUywgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQtNzYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0ZMQUdTLCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzAxCiAgICAvLyBmbGFncz1hcmM0LkJ5dGUob3AuYnRvaShzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSkpLAogICAgYnRvaQogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMiAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Mi02NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjQKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg0LTg3CiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9pZGVudGlmaWVycyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSURFTlRJRklFUiAtIGZsZy5JRF9TSE9SVCwKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMDIKICAgIC8vIGlzX3Nob3J0PWFyYzQuQm9vbChzZWxmLl9pc19zaG9ydChhc2EpKSwKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI5Ny0zMDQKICAgIC8vIGFiaS5BcmM4OU1ldGFkYXRhVXBkYXRlZCgKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc2EuaWQpLAogICAgLy8gICAgIHJvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICAvLyAgICAgdGltZXN0YW1wPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIC8vICAgICBmbGFncz1hcmM0LkJ5dGUob3AuYnRvaShzZWxmLl9nZXRfbWV0YWRhdGFfZmxhZ3MoYXNhKSkpLAogICAgLy8gICAgIGlzX3Nob3J0PWFyYzQuQm9vbChzZWxmLl9pc19zaG9ydChhc2EpKSwKICAgIC8vICAgICBoYXNoPWFiaS5IYXNoLmZyb21fYnl0ZXMobWV0YWRhdGFfaGFzaCksCiAgICAvLyApCiAgICB1bmNvdmVyIDQKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI5Ni0zMDUKICAgIC8vIGFyYzQuZW1pdCgKICAgIC8vICAgICBhYmkuQXJjODlNZXRhZGF0YVVwZGF0ZWQoCiAgICAvLyAgICAgICAgIGFzc2V0X2lkPWFyYzQuVUludDY0KGFzYS5pZCksCiAgICAvLyAgICAgICAgIHJvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICAvLyAgICAgICAgIHRpbWVzdGFtcD1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICAvLyAgICAgICAgIGZsYWdzPWFyYzQuQnl0ZShvcC5idG9pKHNlbGYuX2dldF9tZXRhZGF0YV9mbGFncyhhc2EpKSksCiAgICAvLyAgICAgICAgIGlzX3Nob3J0PWFyYzQuQm9vbChzZWxmLl9pc19zaG9ydChhc2EpKSwKICAgIC8vICAgICAgICAgaGFzaD1hYmkuSGFzaC5mcm9tX2J5dGVzKG1ldGFkYXRhX2hhc2gpLAogICAgLy8gICAgICkKICAgIC8vICkKICAgIGJ5dGVjIDUgLy8gbWV0aG9kICJBcmM4OU1ldGFkYXRhVXBkYXRlZCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlLGJvb2wsYnl0ZVszMl0pIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIHJldHN1Ygo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMQogICAgcmV0dXJuCg=="}, "sourceInfo": {"approval": {"pcOffsetMethod": "cblocks", "sourceInfo": [{"pc": [330], "errorMessage": "Asset Metadata already exists for the specified ASA"}, {"pc": [1079, 1220, 2735, 2760], "errorMessage": "Asset Metadata does not exist for the specified ASA"}, {"pc": [670], "errorMessage": "Invalid ARC-89 URI"}, {"pc": [686, 953], "errorMessage": "Invalid MBR Delta amount"}, {"pc": [337, 906], "errorMessage": "Invalid MBR Delta receiver, must be the ASA Metadata Registry"}, {"pc": [1457, 2716], "errorMessage": "Invalid Metadata size, exceeds maximum allowed size"}, {"pc": [898], "errorMessage": "Invalid Metadata size, must be larger than the current size"}, {"pc": [751], "errorMessage": "Invalid Metadata size, must be smaller than or equal to the current size"}, {"pc": [1264, 1354], "errorMessage": "Invalid flag index"}, {"pc": [1845, 1901, 2038], "errorMessage": "Invalid page index"}, {"pc": [2031], "errorMessage": "Metadata is empty"}, {"pc": [1094, 2742, 2779], "errorMessage": "Metadata is immutable"}, {"pc": [2466], "errorMessage": "Metadata is not short"}, {"pc": [784, 939, 2396], "errorMessage": "Metadata size mismatch, must be exactly equal to declared size"}, {"pc": [465], "errorMessage": "Must be flagged as immutable"}, {"pc": [1944, 2118, 2211], "errorMessage": "Payload exceeds page size"}, {"pc": [2368], "errorMessage": "Payload overflow, exceeds metadata size"}, {"pc": [1026, 1957], "errorMessage": "Slice exceeds metadata range"}, {"pc": [247], "errorMessage": "The deployer address is not trusted"}, {"pc": [1214, 2704, 2753], "errorMessage": "The specified ASA does not exist"}, {"pc": [1100, 1224, 2710, 2785], "errorMessage": "Unauthorized, must be the Asset Manager"}, {"pc": [345, 675, 756, 789, 911, 944, 1105, 1114], "errorMessage": "account funded"}, {"pc": [419, 470, 652, 823, 1132, 1622, 2227], "errorMessage": "asset exists"}, {"pc": [2237, 2250], "errorMessage": "check Box exists"}, {"pc": [286, 726, 862, 985, 1202, 2090, 2139, 2183], "errorMessage": "invalid array length header"}, {"pc": [1252], "errorMessage": "invalid number of bytes for arc4.bool"}, {"pc": [293, 733, 869, 992, 1208, 2097, 2146, 2190], "errorMessage": "invalid number of bytes for arc4.dynamic_array<arc4.uint8>"}, {"pc": [280, 720, 856, 979, 1449, 1925, 1933], "errorMessage": "invalid number of bytes for arc4.uint16"}, {"pc": [260, 710, 847, 969, 1068, 1195, 1234, 1323, 1407, 1439, 1563, 1603, 1652, 1691, 1744, 1805, 1916, 1982, 2004, 2059, 2083, 2132, 2176], "errorMessage": "invalid number of bytes for arc4.uint64"}, {"pc": [272, 1244, 1333, 1817, 2013], "errorMessage": "invalid number of bytes for arc4.uint8"}, {"pc": [801, 1499, 1760, 1779, 2835], "errorMessage": "overflow"}, {"pc": [306, 879], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {"TRUSTED_DEPLOYER": {"type": "address"}}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class MbrDelta:
    """Struct for MbrDelta"""
    sign: int
    amount: int

@dataclasses.dataclass(frozen=True)
class MetadataExistence:
    """Struct for MetadataExistence"""
    asa_exists: bool
    metadata_exists: bool

@dataclasses.dataclass(frozen=True)
class MetadataHeader:
    """Struct for MetadataHeader"""
    identifiers: int
    flags: int
    hash: bytes
    last_modified_round: int

@dataclasses.dataclass(frozen=True)
class MutableFlag:
    """Struct for MutableFlag"""
    flag: bool
    last_modified_round: int

@dataclasses.dataclass(frozen=True)
class PaginatedMetadata:
    """Struct for PaginatedMetadata"""
    has_next_page: bool
    last_modified_round: int
    page_content: bytes

@dataclasses.dataclass(frozen=True)
class Pagination:
    """Struct for Pagination"""
    metadata_size: int
    page_size: int
    total_pages: int

@dataclasses.dataclass(frozen=True)
class RegistryParameters:
    """Struct for RegistryParameters"""
    header_size: int
    max_metadata_size: int
    short_metadata_size: int
    page_size: int
    first_payload_max_size: int
    extra_payload_max_size: int
    replace_payload_max_size: int
    flat_mbr: int
    byte_mbr: int


@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89CreateMetadataArgs:
    """Dataclass for arc89_create_metadata arguments"""
    asset_id: int
    flags: int
    metadata_size: int
    payload: bytes | str
    mbr_delta_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataArgs:
    """Dataclass for arc89_replace_metadata arguments"""
    asset_id: int
    metadata_size: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataLargerArgs:
    """Dataclass for arc89_replace_metadata_larger arguments"""
    asset_id: int
    metadata_size: int
    payload: bytes | str
    mbr_delta_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataSliceArgs:
    """Dataclass for arc89_replace_metadata_slice arguments"""
    asset_id: int
    offset: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata_slice(uint64,uint16,byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89DeleteMetadataArgs:
    """Dataclass for arc89_delete_metadata arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_delete_metadata(uint64)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ExtraPayloadArgs:
    """Dataclass for arc89_extra_payload arguments"""
    asset_id: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_extra_payload(uint64,byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetReversibleFlagArgs:
    """Dataclass for arc89_set_reversible_flag arguments"""
    asset_id: int
    flag: int
    value: bool

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_reversible_flag(uint64,uint8,bool)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetIrreversibleFlagArgs:
    """Dataclass for arc89_set_irreversible_flag arguments"""
    asset_id: int
    flag: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_irreversible_flag(uint64,uint8)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetImmutableArgs:
    """Dataclass for arc89_set_immutable arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_immutable(uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataMbrDeltaArgs:
    """Dataclass for arc89_get_metadata_mbr_delta arguments"""
    asset_id: int
    new_metadata_size: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89CheckMetadataExistsArgs:
    """Dataclass for arc89_check_metadata_exists arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_check_metadata_exists(uint64)(bool,bool)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89IsMetadataImmutableArgs:
    """Dataclass for arc89_is_metadata_immutable arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_is_metadata_immutable(uint64)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89IsMetadataShortArgs:
    """Dataclass for arc89_is_metadata_short arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_is_metadata_short(uint64)(bool,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHeaderArgs:
    """Dataclass for arc89_get_metadata_header arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataPaginationArgs:
    """Dataclass for arc89_get_metadata_pagination arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataArgs:
    """Dataclass for arc89_get_metadata arguments"""
    asset_id: int
    page: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataSliceArgs:
    """Dataclass for arc89_get_metadata_slice arguments"""
    asset_id: int
    offset: int
    size: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHeaderHashArgs:
    """Dataclass for arc89_get_metadata_header_hash arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_header_hash(uint64)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataPageHashArgs:
    """Dataclass for arc89_get_metadata_page_hash arguments"""
    asset_id: int
    page: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_page_hash(uint64,uint8)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHashArgs:
    """Dataclass for arc89_get_metadata_hash arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_hash(uint64)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataStringByKeyArgs:
    """Dataclass for arc89_get_metadata_string_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_string_by_key(uint64,string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataUint64ByKeyArgs:
    """Dataclass for arc89_get_metadata_uint64_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_uint64_by_key(uint64,string)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataObjectByKeyArgs:
    """Dataclass for arc89_get_metadata_object_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_object_by_key(uint64,string)string"


class AsaMetadataRegistryParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }))

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }))

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }))

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }))

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }))

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }))

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }))

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }))

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }))

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }))

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }))

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }))

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class AsaMetadataRegistryCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }))

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }))

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }))

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }))

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }))

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }))

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }))

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }))

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }))

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }))

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }))

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }))

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class AsaMetadataRegistrySend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[RegistryParameters]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(RegistryParameters, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[RegistryParameters], parsed_response)

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MetadataExistence]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MetadataExistence, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MetadataExistence], parsed_response)

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MutableFlag]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MutableFlag, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MutableFlag], parsed_response)

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MetadataHeader]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MetadataHeader, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MetadataHeader], parsed_response)

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[Pagination]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(Pagination, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[Pagination], parsed_response)

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[PaginatedMetadata]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(PaginatedMetadata, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[PaginatedMetadata], parsed_response)

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class AsaMetadataRegistryState:
    """Methods to access state for the current AsaMetadataRegistry app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def asset_metadata(self) -> "_MapState[int, bytes]":
        """Get values from the asset_metadata map in box state"""
        return _MapState(
            self.app_client.state.box,
            "asset_metadata",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class AsaMetadataRegistryClient:
    """Client for interacting with AsaMetadataRegistry smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = AsaMetadataRegistryParams(self.app_client)
        self.create_transaction = AsaMetadataRegistryCreateTransactionParams(self.app_client)
        self.send = AsaMetadataRegistrySend(self.app_client)
        self.state = AsaMetadataRegistryState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "AsaMetadataRegistryComposer":
        return AsaMetadataRegistryComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata_slice(uint64,uint16,byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_delete_metadata(uint64)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_extra_payload(uint64,byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_reversible_flag(uint64,uint8,bool)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_irreversible_flag(uint64,uint8)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_immutable(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> RegistryParameters | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_check_metadata_exists(uint64)(bool,bool)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MetadataExistence | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_is_metadata_immutable(uint64)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_is_metadata_short(uint64)(bool,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MutableFlag | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MetadataHeader | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> Pagination | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])"],
        return_value: algokit_utils.ABIReturn | None
    ) -> PaginatedMetadata | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_slice(uint64,uint16,uint16)byte[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_header_hash(uint64)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_page_hash(uint64,uint8)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_hash(uint64)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_string_by_key(uint64,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_uint64_by_key(uint64,string)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_object_by_key(uint64,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["extra_resources()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | MbrDelta | MetadataExistence | MetadataHeader | MutableFlag | None | PaginatedMetadata | Pagination | RegistryParameters | bool | bytes | int | str:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class AsaMetadataRegistryBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating AsaMetadataRegistry contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class AsaMetadataRegistryFactory(algokit_utils.TypedAppFactoryProtocol[AsaMetadataRegistryBareCallCreateParams, None, None]):
    """Factory for deploying and managing AsaMetadataRegistryClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = AsaMetadataRegistryFactoryParams(self.app_factory)
        self.create_transaction = AsaMetadataRegistryFactoryCreateTransaction(self.app_factory)
        self.send = AsaMetadataRegistryFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: AsaMetadataRegistryBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[AsaMetadataRegistryClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return AsaMetadataRegistryClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AsaMetadataRegistryClient:
        """Get an app client by creator address and name"""
        return AsaMetadataRegistryClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AsaMetadataRegistryClient:
        """Get an app client by app ID"""
        return AsaMetadataRegistryClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class AsaMetadataRegistryFactoryParams:
    """Parameters for creating transactions for AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactoryCreateParams(app_factory)
        self.update = AsaMetadataRegistryFactoryUpdateParams(app_factory)
        self.delete = AsaMetadataRegistryFactoryDeleteParams(app_factory)

class AsaMetadataRegistryFactoryCreateParams:
    """Parameters for 'create' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata_slice(uint64,uint16,byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_delete_metadata(uint64)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_extra_payload(uint64,byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_extra_payload(uint64,byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_reversible_flag(uint64,uint8,bool)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_irreversible_flag(uint64,uint8)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_irreversible_flag(uint64,uint8)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_immutable(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_immutable(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_registry_parameters(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_check_metadata_exists(uint64)(bool,bool) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_is_metadata_immutable(uint64)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_is_metadata_immutable(uint64)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_is_metadata_short(uint64)(bool,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata(uint64,uint8)(bool,uint64,byte[]) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_slice(uint64,uint16,uint16)byte[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_header_hash(uint64)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_page_hash(uint64,uint8)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_hash(uint64)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_hash(uint64)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_string_by_key(uint64,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_string_by_key(uint64,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_uint64_by_key(uint64,string)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_object_by_key(uint64,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_object_by_key(uint64,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def extra_resources(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the extra_resources()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "extra_resources()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class AsaMetadataRegistryFactoryUpdateParams:
    """Parameters for 'update' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class AsaMetadataRegistryFactoryDeleteParams:
    """Parameters for 'delete' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class AsaMetadataRegistryFactoryCreateTransaction:
    """Create transactions for AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactoryCreateTransactionCreate(app_factory)


class AsaMetadataRegistryFactoryCreateTransactionCreate:
    """Create new instances of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class AsaMetadataRegistryFactorySend:
    """Send calls to AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactorySendCreate(app_factory)


class AsaMetadataRegistryFactorySendCreate:
    """Send create calls to AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[AsaMetadataRegistryClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return AsaMetadataRegistryClient(result[0]), result[1]


class AsaMetadataRegistryComposer:
    """Composer for creating transaction groups for AsaMetadataRegistry contract calls"""

    def __init__(self, client: "AsaMetadataRegistryClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_create_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_create_metadata(uint64,byte,uint16,byte[],pay)(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata_larger(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata_slice(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata_slice(uint64,uint16,byte[])void", v
            )
        )
        return self

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_delete_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_delete_metadata(uint64)(uint8,uint64)", v
            )
        )
        return self

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_extra_payload(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_extra_payload(uint64,byte[])void", v
            )
        )
        return self

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_reversible_flag(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_reversible_flag(uint64,uint8,bool)void", v
            )
        )
        return self

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_irreversible_flag(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_irreversible_flag(uint64,uint8)void", v
            )
        )
        return self

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_immutable(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_immutable(uint64)void", v
            )
        )
        return self

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_registry_parameters(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_mbr_delta(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)", v
            )
        )
        return self

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_check_metadata_exists(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_check_metadata_exists(uint64)(bool,bool)", v
            )
        )
        return self

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_is_metadata_immutable(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_is_metadata_immutable(uint64)bool", v
            )
        )
        return self

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_is_metadata_short(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_is_metadata_short(uint64)(bool,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_header(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_header(uint64)(byte,byte,byte[32],uint64)", v
            )
        )
        return self

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_pagination(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)", v
            )
        )
        return self

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])", v
            )
        )
        return self

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_slice(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]", v
            )
        )
        return self

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_header_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_header_hash(uint64)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_page_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_page_hash(uint64,uint8)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_hash(uint64)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_string_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_string_by_key(uint64,string)string", v
            )
        )
        return self

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_uint64_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_uint64_by_key(uint64,string)uint64", v
            )
        )
        return self

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_object_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_object_by_key(uint64,string)string", v
            )
        )
        return self

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.extra_resources(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "extra_resources()void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "AsaMetadataRegistryComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
