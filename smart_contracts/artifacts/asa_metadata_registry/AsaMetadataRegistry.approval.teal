#pragma version 12
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8 2 1007 1006 30506
    bytecblock 0x151f7c75 0x 0x00 0x37ac755d 0x068101 0x151f7c7501 TMPL_TRUSTED_DEPLOYER TMPL_ARC90_NETAUTH
    // smart_contracts/asa_metadata_registry/contract.py:38
    // class AsaMetadataRegistry(Arc89Interface, AsaValidation):
    txn NumAppArgs
    bz main_deploy@38
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x78407831 0xb82ea7ef 0x1245fafb 0x045f2e6e 0xddffcb92 0x15b275b2 // method "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)", method "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)", method "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)", method "arc89_replace_metadata_slice(uint64,uint16,byte[])void", method "arc89_migrate_metadata(uint64,uint64)void", method "arc89_delete_metadata(uint64)(uint8,uint64)"
    bytec_3 // method "arc89_extra_payload(uint64,byte[])void"
    pushbytess 0xb5121d8a 0x49fbae91 0x0b538ce3 0x9aa9af25 0x089faea1 0x8e5e1024 0x244c47c4 0x2d59f6e0 0xee85b473 0xb75931bc 0x8f25ef72 0x11c38476 0xb0abf65b 0xce9dbed7 0xca52fb1e 0x226391b9 0x7a13d532 0x53c22203 0xd3772ad3 0x7da2af40 0x0056d9c1 0xb92e267a // method "arc89_set_reversible_flag(uint64,uint8,bool)void", method "arc89_set_irreversible_flag(uint64,uint8)void", method "arc89_set_immutable(uint64)void", method "arc89_get_metadata_registry_parameters()(uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", method "arc89_get_metadata_partial_uri()string", method "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)", method "arc89_check_metadata_exists(uint64)(bool,bool)", method "arc89_is_metadata_immutable(uint64)bool", method "arc89_is_metadata_short(uint64)(bool,uint64)", method "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)", method "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)", method "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])", method "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]", method "arc89_get_metadata_header_hash(uint64)byte[32]", method "arc89_get_metadata_page_hash(uint64,uint8)byte[32]", method "arc89_get_metadata_hash(uint64)byte[32]", method "arc89_get_metadata_string_by_key(uint64,string)string", method "arc89_get_metadata_uint64_by_key(uint64,string)uint64", method "arc89_get_metadata_object_by_key(uint64,string)string", method "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]", method "extra_resources()void", method "withdraw_balance_excess()void"
    txna ApplicationArgs 0
    match arc89_create_metadata arc89_replace_metadata arc89_replace_metadata_larger arc89_replace_metadata_slice arc89_migrate_metadata arc89_delete_metadata arc89_extra_payload arc89_set_reversible_flag arc89_set_irreversible_flag arc89_set_immutable main_arc89_get_metadata_registry_parameters_route@16 arc89_get_metadata_partial_uri arc89_get_metadata_mbr_delta arc89_check_metadata_exists arc89_is_metadata_immutable arc89_is_metadata_short arc89_get_metadata_header arc89_get_metadata_pagination arc89_get_metadata arc89_get_metadata_slice arc89_get_metadata_header_hash arc89_get_metadata_page_hash arc89_get_metadata_hash arc89_get_metadata_string_by_key arc89_get_metadata_uint64_by_key arc89_get_metadata_object_by_key arc89_get_metadata_b64_bytes_by_key main_extra_resources_route@33 withdraw_balance_excess
    err

main_extra_resources_route@33:
    // smart_contracts/asa_metadata_registry/contract.py:1254
    // @arc4.abimethod
    intc_0 // 1
    return

main_arc89_get_metadata_registry_parameters_route@16:
    // smart_contracts/asa_metadata_registry/contract.py:775
    // @arc4.abimethod(readonly=True)
    pushbytes 0x151f7c750033772a100003ef07ee07f207f000000000000009c40000000000000190
    log
    intc_0 // 1
    return

main_deploy@38:
    // smart_contracts/asa_metadata_registry/contract.py:368
    // @arc4.baremethod(create="require")
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert
    // smart_contracts/asa_metadata_registry/contract.py:373-374
    // # Preconditions
    // assert Txn.sender == TemplateVar[Account](
    txn Sender
    // smart_contracts/asa_metadata_registry/contract.py:373-376
    // # Preconditions
    // assert Txn.sender == TemplateVar[Account](
    //     TRUSTED_DEPLOYER
    // ), err.UNTRUSTED_DEPLOYER
    bytec 6 // TMPL_TRUSTED_DEPLOYER
    ==
    assert // The deployer address is not trusted
    // smart_contracts/asa_metadata_registry/contract.py:368
    // @arc4.baremethod(create="require")
    intc_0 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@6
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 4 // 0x068101
    itxn_field ApprovalProgram
    bytec 4 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@5:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_switch_case_0@3:
    intc_1 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_after_while@6:
    retsub


// smart_contracts.avm_common.endswith(s: bytes, suffix: bytes) -> uint64:
endswith:
    // smart_contracts/avm_common.py:54-55
    // @subroutine
    // def endswith(s: Bytes, suffix: Bytes) -> bool:
    proto 2 1
    // smart_contracts/avm_common.py:56
    // assert suffix.length <= s.length
    frame_dig -1
    len
    frame_dig -2
    len
    dup2
    <=
    assert
    // smart_contracts/avm_common.py:57
    // return s[s.length - suffix.length :] == suffix
    dup
    uncover 2
    -
    dup
    dig 2
    >=
    dig 2
    swap
    select
    frame_dig -2
    swap
    uncover 2
    substring3
    frame_dig -1
    ==
    retsub


// smart_contracts.avm_common.arc90_box_query(app: uint64, box_name: bytes) -> bytes:
arc90_box_query:
    // smart_contracts/avm_common.py:60-61
    // @subroutine
    // def arc90_box_query(app: Application, box_name: Bytes) -> Bytes:
    proto 2 1
    intc_1 // 0
    dup
    bytec_1 // ""
    // smart_contracts/avm_common.py:62
    // if Global.genesis_hash == Bytes.from_base64(MAINNET_GH_B64):
    global GenesisHash
    pushbytes base64(wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=)
    ==
    bz arc90_box_query_else_body@2
    // smart_contracts/avm_common.py:63
    // arc90_netauth = Bytes()
    bytec_1 // 0x

arc90_box_query_after_if_else@3:
    // smart_contracts/avm_common.py:71
    // ARC90_URI_SCHEME
    pushbytes 0x616c676f72616e643a2f2f
    // smart_contracts/avm_common.py:71-72
    // ARC90_URI_SCHEME
    // + arc90_netauth
    swap
    concat
    // smart_contracts/avm_common.py:73
    // + ARC90_URI_APP_PATH
    pushbytes 0x6170702f
    // smart_contracts/avm_common.py:71-73
    // ARC90_URI_SCHEME
    // + arc90_netauth
    // + ARC90_URI_APP_PATH
    concat
    frame_bury 1
    // smart_contracts/avm_common.py:38
    // acc = Bytes(b"")
    bytec_1 // 0x
    frame_bury 0
    frame_dig -2
    frame_bury 2

arc90_box_query_while_top@5:
    // smart_contracts/avm_common.py:40
    // while i > 0:
    frame_dig 2
    bz arc90_box_query_after_while@7
    // smart_contracts/avm_common.py:41
    // d = i % UInt64(10)
    frame_dig 2
    dup
    pushint 10
    %
    // smart_contracts/avm_common.py:42
    // acc = digits[d : d + UInt64(1)] + acc
    dup
    pushint 10
    >=
    dig 1
    pushint 10
    uncover 2
    select
    swap
    intc_0 // 1
    +
    dup
    pushint 10
    >=
    pushint 10
    swap
    select
    dup
    dig 2
    <
    dig 2
    swap
    select
    // smart_contracts/avm_common.py:36-37
    // # ASCII digits (valid UTF-8)
    // digits = Bytes(b"0123456789")
    pushbytes 0x30313233343536373839
    // smart_contracts/avm_common.py:42
    // acc = digits[d : d + UInt64(1)] + acc
    cover 2
    substring3
    frame_dig 0
    concat
    frame_bury 0
    // smart_contracts/avm_common.py:43
    // i //= UInt64(10)
    pushint 10
    /
    frame_bury 2
    b arc90_box_query_while_top@5

arc90_box_query_after_while@7:
    // smart_contracts/avm_common.py:45
    // return acc or Bytes(b"0")
    frame_dig 0
    dup
    len
    pushbytes 0x30
    cover 2
    select
    // smart_contracts/avm_common.py:71-74
    // ARC90_URI_SCHEME
    // + arc90_netauth
    // + ARC90_URI_APP_PATH
    // + itoa(app.id)
    frame_dig 1
    swap
    concat
    // smart_contracts/avm_common.py:75
    // + ARC90_URI_BOX_QUERY
    pushbytes 0x3f626f783d
    // smart_contracts/avm_common.py:71-75
    // ARC90_URI_SCHEME
    // + arc90_netauth
    // + ARC90_URI_APP_PATH
    // + itoa(app.id)
    // + ARC90_URI_BOX_QUERY
    concat
    // smart_contracts/avm_common.py:71-76
    // ARC90_URI_SCHEME
    // + arc90_netauth
    // + ARC90_URI_APP_PATH
    // + itoa(app.id)
    // + ARC90_URI_BOX_QUERY
    // + box_name
    frame_dig -1
    concat
    // smart_contracts/avm_common.py:70-77
    // return (
    //     ARC90_URI_SCHEME
    //     + arc90_netauth
    //     + ARC90_URI_APP_PATH
    //     + itoa(app.id)
    //     + ARC90_URI_BOX_QUERY
    //     + box_name
    // )
    frame_bury 0
    retsub

arc90_box_query_else_body@2:
    // smart_contracts/avm_common.py:66
    // ARC90_URI_NETAUTH_PREFIX
    pushbytes 0x6e65743a
    // smart_contracts/avm_common.py:67
    // + TemplateVar[Bytes](ARC90_NETAUTH)
    bytec 7 // TMPL_ARC90_NETAUTH
    // smart_contracts/avm_common.py:66-67
    // ARC90_URI_NETAUTH_PREFIX
    // + TemplateVar[Bytes](ARC90_NETAUTH)
    concat
    // smart_contracts/avm_common.py:68
    // + ARC90_URI_PATH_SEP
    pushbytes 0x2f
    // smart_contracts/avm_common.py:66-68
    // ARC90_URI_NETAUTH_PREFIX
    // + TemplateVar[Bytes](ARC90_NETAUTH)
    // + ARC90_URI_PATH_SEP
    concat
    b arc90_box_query_after_if_else@3


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_create_metadata[routing]() -> void:
arc89_create_metadata:
    intc_1 // 0
    dupn 3
    bytec_1 // ""
    dup
    // smart_contracts/asa_metadata_registry/contract.py:378
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 5
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    dup
    cover 2
    cover 3
    txn GroupIndex
    intc_0 // 1
    -
    dup
    cover 4
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/asa_metadata_registry/contract.py:404-405
    // # Preconditions
    // self._check_base_preconditions(asset_id, metadata_size.as_uint64())
    swap
    btoi
    dup
    cover 4
    dig 3
    swap
    callsub _check_base_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:47
    // return asa in self.asset_metadata
    uncover 2
    itob
    dup
    cover 3
    dup
    box_len
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:406
    // assert not self._metadata_exists(asset_id), err.ASSET_METADATA_EXIST
    !
    assert // Asset Metadata already exists for the specified ASA
    // smart_contracts/asa_metadata_registry/contract.py:408
    // mbr_delta_payment.receiver == Global.current_application_address
    swap
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/asa_metadata_registry/contract.py:407-409
    // assert (
    //     mbr_delta_payment.receiver == Global.current_application_address
    // ), err.MBR_DELTA_RECEIVER_INVALID
    assert // Invalid MBR Delta receiver, must be the ASA Metadata Registry
    // smart_contracts/asa_metadata_registry/contract.py:411-412
    // # Initialize empty Asset Metadata Box
    // mbr_i = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    swap
    cover 3
    assert // account funded
    // smart_contracts/asa_metadata_registry/contract.py:413
    // _exists = self.asset_metadata.box(asset_id).create(size=UInt64(0))
    intc_1 // 0
    box_create
    pop
    // smart_contracts/asa_metadata_registry/contract.py:415-416
    // # Set Metadata Body
    // if payload.length > 0:
    len
    bz arc89_create_metadata_after_if_else@3
    // smart_contracts/asa_metadata_registry/contract.py:417
    // ensure_budget(required_budget=const.APP_CALL_OP_BUDGET)
    pushint 700
    intc_1 // 0
    callsub ensure_budget

arc89_create_metadata_after_if_else@3:
    // smart_contracts/asa_metadata_registry/contract.py:418
    // self._set_metadata_payload(asset_id, metadata_size.as_uint64(), payload)
    dig 7
    dup
    dig 4
    dig 7
    callsub _set_metadata_payload
    // smart_contracts/asa_metadata_registry/contract.py:420-421
    // # Update Metadata Header
    // self._identify_metadata(asset_id)
    dup
    callsub _identify_metadata
    // smart_contracts/asa_metadata_registry/contract.py:425
    // uint=reversible_flags.as_uint64(), size=UInt64(const.BYTE_SIZE)
    dig 7
    btoi
    // smart_contracts/avm_common.py:21
    // return op.extract(op.itob(uint), start, size)
    itob
    extract 7 1
    // smart_contracts/asa_metadata_registry/contract.py:92-94
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, value=flags
    // )
    dig 3
    dup
    cover 2
    // smart_contracts/asa_metadata_registry/contract.py:93
    // start_index=const.IDX_REVERSIBLE_FLAGS, value=flags
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:92-94
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, value=flags
    // )
    uncover 2
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:431
    // uint=irreversible_flags.as_uint64(), size=UInt64(const.BYTE_SIZE)
    dig 7
    btoi
    // smart_contracts/avm_common.py:21
    // return op.extract(op.itob(uint), start, size)
    itob
    extract 7 1
    // smart_contracts/asa_metadata_registry/contract.py:104
    // start_index=const.IDX_IRREVERSIBLE_FLAGS, value=flags
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:103-105
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS, value=flags
    // )
    swap
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:434
    // if asset_id.metadata_hash != Bytes(
    asset_params_get AssetMetadataHash
    assert // asset exists
    // smart_contracts/asa_metadata_registry/contract.py:434-436
    // if asset_id.metadata_hash != Bytes(
    //     const.BYTES32_SIZE * b"\x00"
    // ):  # Not empty metadata hash
    pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000
    !=
    bz arc89_create_metadata_else_body@5
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    dig 1
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:110
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:108-111
    // return op.getbit(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:437
    // assert self._is_immutable(asset_id), err.REQUIRES_IMMUTABLE
    assert // Must be flagged as immutable
    // smart_contracts/asa_metadata_registry/contract.py:438
    // metadata_hash = asset_id.metadata_hash
    dig 7
    asset_params_get AssetMetadataHash
    swap
    bury 12
    assert // asset exists

arc89_create_metadata_after_if_else@6:
    // smart_contracts/asa_metadata_registry/contract.py:127-129
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_METADATA_HASH, value=metadata_hash
    // )
    dig 1
    dup
    // smart_contracts/asa_metadata_registry/contract.py:128
    // start_index=const.IDX_METADATA_HASH, value=metadata_hash
    pushint 3
    // smart_contracts/asa_metadata_registry/contract.py:127-129
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_METADATA_HASH, value=metadata_hash
    // )
    dig 13
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:442
    // self._set_last_modified_round(asset_id, Global.round)
    global Round
    // smart_contracts/asa_metadata_registry/contract.py:142
    // value=op.itob(last_modified_round),
    itob
    // smart_contracts/asa_metadata_registry/contract.py:140-143
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_LAST_MODIFIED_ROUND,
    //     value=op.itob(last_modified_round),
    // )
    dig 1
    // smart_contracts/asa_metadata_registry/contract.py:141
    // start_index=const.IDX_LAST_MODIFIED_ROUND,
    pushint 35
    // smart_contracts/asa_metadata_registry/contract.py:140-143
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_LAST_MODIFIED_ROUND,
    //     value=op.itob(last_modified_round),
    // )
    uncover 2
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:443
    // self._set_deprecated_by(asset_id, UInt64(0))
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:156
    // value=op.itob(deprecated_by),
    itob
    // smart_contracts/asa_metadata_registry/contract.py:154-157
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_DEPRECATED_BY,
    //     value=op.itob(deprecated_by),
    // )
    dig 1
    // smart_contracts/asa_metadata_registry/contract.py:155
    // start_index=const.IDX_DEPRECATED_BY,
    pushint 43
    // smart_contracts/asa_metadata_registry/contract.py:154-157
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_DEPRECATED_BY,
    //     value=op.itob(deprecated_by),
    // )
    uncover 2
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:110
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    pushint 7
    // smart_contracts/asa_metadata_registry/contract.py:108-111
    // return op.getbit(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:445-446
    // # Postconditions
    // if self._is_arc3(asset_id):
    bz arc89_create_metadata_after_if_else@8
    // smart_contracts/asa_validation.py:22
    // asa_name = asa.name
    dig 7
    dup
    asset_params_get AssetName
    swap
    dup
    cover 3
    bury 16
    assert // asset exists
    // smart_contracts/asa_validation.py:23
    // asa_url = asa.url
    asset_params_get AssetURL
    swap
    bury 14
    assert // asset exists
    // smart_contracts/asa_validation.py:27
    // if asa_name == ARC3_NAME:
    pushbytes 0x61726333
    ==
    bz arc89_create_metadata_after_if_else@19
    // smart_contracts/asa_validation.py:28
    // return True
    intc_0 // 1

arc89_create_metadata_after_inlined_smart_contracts.asa_validation.AsaValidation._is_arc3_compliant@26:
    // smart_contracts/asa_metadata_registry/contract.py:447
    // assert self._is_arc3_compliant(asset_id), err.ASA_NOT_ARC3_COMPLIANT
    assert // Invalid ARC-3 parameters (name or URL)

arc89_create_metadata_after_if_else@8:
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    dig 1
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:110
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    pushint 6
    // smart_contracts/asa_metadata_registry/contract.py:108-111
    // return op.getbit(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:448
    // if self._is_arc89_native(asset_id):
    bz arc89_create_metadata_after_if_else@10
    // smart_contracts/asa_validation.py:41-42
    // # This validation does not enforce ARC-90 compliance fragments (optional)
    // arc89_partial_uri = arc90_box_query(Global.current_application_id, Bytes())
    global CurrentApplicationID
    bytec_1 // 0x
    callsub arc90_box_query
    dup
    bury 15
    // smart_contracts/asa_validation.py:43
    // asa_url = asa.url
    dig 8
    asset_params_get AssetURL
    swap
    dup
    cover 2
    bury 15
    assert // asset exists
    // smart_contracts/asa_validation.py:45
    // if asa_url.length < arc89_partial_uri.length:
    len
    dup
    bury 12
    swap
    len
    dup
    bury 11
    <
    bz arc89_create_metadata_after_if_else@13
    // smart_contracts/asa_validation.py:46
    // return False
    intc_1 // 0

arc89_create_metadata_after_inlined_smart_contracts.asa_validation.AsaValidation._is_arc89_compliant@14:
    // smart_contracts/asa_metadata_registry/contract.py:449
    // assert self._is_arc89_compliant(asset_id), err.ASA_NOT_ARC89_COMPLIANT
    assert // Invalid ARC-89 partial URI

arc89_create_metadata_after_if_else@10:
    // smart_contracts/asa_metadata_registry/contract.py:451
    // self._emit_updated_event(asset_id, metadata_hash)
    dig 7
    dig 11
    callsub _emit_updated_event
    // smart_contracts/asa_metadata_registry/contract.py:453
    // mbr_delta_amount = Global.current_application_address.min_balance - mbr_i
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    dig 1
    -
    // smart_contracts/asa_metadata_registry/contract.py:455
    // mbr_delta_payment.amount >= mbr_delta_amount
    dig 4
    gtxns Amount
    dig 1
    >=
    // smart_contracts/asa_metadata_registry/contract.py:454-456
    // assert (
    //     mbr_delta_payment.amount >= mbr_delta_amount
    // ), err.MBR_DELTA_AMOUNT_INVALID
    assert // Invalid MBR Delta amount
    // smart_contracts/asa_metadata_registry/contract.py:458-460
    // return abi.MbrDelta(
    //     sign=arc4.UInt8(enums.MBR_DELTA_POS), amount=mbr_delta_amount
    // )
    itob
    // smart_contracts/asa_metadata_registry/contract.py:378
    // @arc4.abimethod
    bytec 5 // 0x151f7c7501
    swap
    concat
    log
    intc_0 // 1
    return

arc89_create_metadata_after_if_else@13:
    // smart_contracts/avm_common.py:50
    // assert prefix.length <= s.length
    dig 8
    dup
    dig 11
    dup
    cover 3
    <=
    assert
    // smart_contracts/avm_common.py:51
    // return s[: prefix.length] == prefix
    dup
    dig 2
    >=
    swap
    cover 2
    select
    dig 12
    intc_1 // 0
    uncover 2
    substring3
    dig 14
    ==
    // smart_contracts/asa_metadata_registry/contract.py:449
    // assert self._is_arc89_compliant(asset_id), err.ASA_NOT_ARC89_COMPLIANT
    b arc89_create_metadata_after_inlined_smart_contracts.asa_validation.AsaValidation._is_arc89_compliant@14

arc89_create_metadata_after_if_else@19:
    // smart_contracts/asa_validation.py:30
    // if asa_name.length >= arc3_name_suffix.length:
    dig 12
    len
    pushint 5
    >=
    bz arc89_create_metadata_after_if_else@22
    // smart_contracts/asa_validation.py:31
    // if endswith(asa_name, arc3_name_suffix):
    dig 12
    // smart_contracts/asa_validation.py:24
    // arc3_name_suffix = Bytes(ARC3_NAME_SUFFIX)
    pushbytes 0x4061726333
    // smart_contracts/asa_validation.py:31
    // if endswith(asa_name, arc3_name_suffix):
    callsub endswith
    bz arc89_create_metadata_after_if_else@22
    // smart_contracts/asa_validation.py:32
    // return True
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:447
    // assert self._is_arc3_compliant(asset_id), err.ASA_NOT_ARC3_COMPLIANT
    b arc89_create_metadata_after_inlined_smart_contracts.asa_validation.AsaValidation._is_arc3_compliant@26

arc89_create_metadata_after_if_else@22:
    // smart_contracts/asa_validation.py:34
    // if asa_url.length >= arc3_url_suffix.length:
    dig 11
    len
    pushint 5
    >=
    bz arc89_create_metadata_after_if_else@25
    // smart_contracts/asa_validation.py:35
    // if endswith(asa_url, arc3_url_suffix):
    dig 11
    // smart_contracts/asa_validation.py:25
    // arc3_url_suffix = Bytes(ARC3_URL_SUFFIX)
    pushbytes 0x2361726333
    // smart_contracts/asa_validation.py:35
    // if endswith(asa_url, arc3_url_suffix):
    callsub endswith
    bz arc89_create_metadata_after_if_else@25
    // smart_contracts/asa_validation.py:36
    // return True
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:447
    // assert self._is_arc3_compliant(asset_id), err.ASA_NOT_ARC3_COMPLIANT
    b arc89_create_metadata_after_inlined_smart_contracts.asa_validation.AsaValidation._is_arc3_compliant@26

arc89_create_metadata_after_if_else@25:
    // smart_contracts/asa_validation.py:38
    // return False
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:447
    // assert self._is_arc3_compliant(asset_id), err.ASA_NOT_ARC3_COMPLIANT
    b arc89_create_metadata_after_inlined_smart_contracts.asa_validation.AsaValidation._is_arc3_compliant@26

arc89_create_metadata_else_body@5:
    // smart_contracts/asa_metadata_registry/contract.py:440
    // metadata_hash = self._compute_metadata_hash(asset_id)
    dig 7
    callsub _compute_metadata_hash
    bury 11
    b arc89_create_metadata_after_if_else@6


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_replace_metadata[routing]() -> void:
arc89_replace_metadata:
    // smart_contracts/asa_metadata_registry/contract.py:462
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 3
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/asa_metadata_registry/contract.py:483-484
    // # Preconditions
    // self._check_update_preconditions(asset_id, metadata_size.as_uint64())
    swap
    btoi
    dig 2
    dig 1
    callsub _check_update_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:485-487
    // assert metadata_size.as_uint64() <= self._get_metadata_size(
    //     asset_id
    // ), err.LARGER_METADATA_SIZE
    dig 2
    callsub _get_metadata_size
    dig 1
    >=
    assert // Invalid Metadata size, must be smaller than or equal to the current size
    // smart_contracts/asa_metadata_registry/contract.py:489-490
    // # Update Metadata Body
    // mbr_i = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/asa_metadata_registry/contract.py:491
    // self._set_metadata_payload(asset_id, metadata_size.as_uint64(), payload)
    dig 3
    dig 2
    uncover 4
    callsub _set_metadata_payload
    // smart_contracts/asa_metadata_registry/contract.py:493-494
    // # Update Metadata Header
    // self._update_header_excluding_flags_and_emit(asset_id)
    dig 2
    callsub _update_header_excluding_flags_and_emit
    // smart_contracts/asa_metadata_registry/contract.py:498
    // self._get_metadata_size(asset_id) == metadata_size.as_uint64()
    uncover 2
    callsub _get_metadata_size
    uncover 2
    ==
    // smart_contracts/asa_metadata_registry/contract.py:496-499
    // # Postconditions
    // assert (
    //     self._get_metadata_size(asset_id) == metadata_size.as_uint64()
    // ), err.METADATA_SIZE_MISMATCH
    assert // Metadata size mismatch, must be exactly equal to declared size
    // smart_contracts/asa_metadata_registry/contract.py:501
    // mbr_delta_amount = mbr_i - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    dup
    // smart_contracts/asa_metadata_registry/contract.py:502
    // if mbr_delta_amount == UInt64(0):
    bnz arc89_replace_metadata_else_body@3
    // smart_contracts/asa_metadata_registry/contract.py:503
    // sign = UInt64(enums.MBR_DELTA_NULL)
    intc_1 // 0

arc89_replace_metadata_after_if_else@5:
    // smart_contracts/asa_metadata_registry/contract.py:511
    // return abi.MbrDelta(sign=arc4.UInt8(sign), amount=mbr_delta_amount)
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    dig 1
    itob
    concat
    // smart_contracts/asa_metadata_registry/contract.py:462
    // @arc4.abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

arc89_replace_metadata_else_body@3:
    // smart_contracts/asa_metadata_registry/contract.py:505
    // sign = UInt64(enums.MBR_DELTA_NEG)
    pushint 255
    // smart_contracts/asa_metadata_registry/contract.py:506-509
    // itxn.Payment(
    //     receiver=asset_id.manager,
    //     amount=mbr_delta_amount,
    // ).submit()
    itxn_begin
    // smart_contracts/asa_metadata_registry/contract.py:507
    // receiver=asset_id.manager,
    dig 2
    asset_params_get AssetManager
    assert // asset exists
    dig 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/asa_metadata_registry/contract.py:506
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/asa_metadata_registry/contract.py:506-509
    // itxn.Payment(
    //     receiver=asset_id.manager,
    //     amount=mbr_delta_amount,
    // ).submit()
    itxn_submit
    b arc89_replace_metadata_after_if_else@5


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_replace_metadata_larger[routing]() -> void:
arc89_replace_metadata_larger:
    // smart_contracts/asa_metadata_registry/contract.py:513
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 3
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/asa_metadata_registry/contract.py:536-537
    // # Preconditions
    // self._check_update_preconditions(asset_id, metadata_size.as_uint64())
    uncover 2
    btoi
    dig 3
    dig 1
    callsub _check_update_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:538-540
    // assert metadata_size.as_uint64() > self._get_metadata_size(
    //     asset_id
    // ), err.SMALLER_METADATA_SIZE
    dig 3
    callsub _get_metadata_size
    dig 1
    <
    assert // Invalid Metadata size, must be larger than the current size
    // smart_contracts/asa_metadata_registry/contract.py:542
    // mbr_delta_payment.receiver == Global.current_application_address
    dig 1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/asa_metadata_registry/contract.py:541-543
    // assert (
    //     mbr_delta_payment.receiver == Global.current_application_address
    // ), err.MBR_DELTA_RECEIVER_INVALID
    assert // Invalid MBR Delta receiver, must be the ASA Metadata Registry
    // smart_contracts/asa_metadata_registry/contract.py:545-546
    // # Update Metadata Body
    // mbr_i = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/asa_metadata_registry/contract.py:547
    // self._set_metadata_payload(asset_id, metadata_size.as_uint64(), payload)
    dig 4
    dig 2
    uncover 5
    callsub _set_metadata_payload
    // smart_contracts/asa_metadata_registry/contract.py:549-550
    // # Update Metadata Header
    // self._update_header_excluding_flags_and_emit(asset_id)
    dig 3
    callsub _update_header_excluding_flags_and_emit
    // smart_contracts/asa_metadata_registry/contract.py:554
    // self._get_metadata_size(asset_id) == metadata_size.as_uint64()
    uncover 3
    callsub _get_metadata_size
    uncover 2
    ==
    // smart_contracts/asa_metadata_registry/contract.py:552-555
    // # Postconditions
    // assert (
    //     self._get_metadata_size(asset_id) == metadata_size.as_uint64()
    // ), err.METADATA_SIZE_MISMATCH
    assert // Metadata size mismatch, must be exactly equal to declared size
    // smart_contracts/asa_metadata_registry/contract.py:557
    // mbr_delta_amount = Global.current_application_address.min_balance - mbr_i
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    swap
    -
    // smart_contracts/asa_metadata_registry/contract.py:559
    // mbr_delta_payment.amount >= mbr_delta_amount
    swap
    gtxns Amount
    dig 1
    >=
    // smart_contracts/asa_metadata_registry/contract.py:558-560
    // assert (
    //     mbr_delta_payment.amount >= mbr_delta_amount
    // ), err.MBR_DELTA_AMOUNT_INVALID
    assert // Invalid MBR Delta amount
    // smart_contracts/asa_metadata_registry/contract.py:562-564
    // return abi.MbrDelta(
    //     sign=arc4.UInt8(enums.MBR_DELTA_POS), amount=mbr_delta_amount
    // )
    itob
    // smart_contracts/asa_metadata_registry/contract.py:513
    // @arc4.abimethod
    bytec 5 // 0x151f7c7501
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_replace_metadata_slice[routing]() -> void:
arc89_replace_metadata_slice:
    // smart_contracts/asa_metadata_registry/contract.py:566
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 3
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    dup
    cover 3
    // smart_contracts/asa_metadata_registry/contract.py:583-584
    // # Preconditions
    // self._check_update_preconditions(asset_id, self._get_metadata_size(asset_id))
    dig 2
    callsub _get_metadata_size
    dig 3
    swap
    callsub _check_update_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:585
    // assert offset.as_uint64() + payload.length <= self._get_metadata_size(
    swap
    btoi
    dig 1
    len
    dup2
    +
    // smart_contracts/asa_metadata_registry/contract.py:585-587
    // assert offset.as_uint64() + payload.length <= self._get_metadata_size(
    //     asset_id
    // ), err.EXCEEDS_METADATA_SIZE
    dig 4
    callsub _get_metadata_size
    <=
    assert // Slice exceeds metadata range
    // smart_contracts/asa_metadata_registry/contract.py:258
    // return self.asset_metadata.box(asa).extract(
    uncover 3
    itob
    dup
    cover 4
    // smart_contracts/asa_metadata_registry/contract.py:259
    // start_index=const.IDX_METADATA + offset, length=size
    pushint 51
    uncover 3
    +
    dup
    cover 4
    // smart_contracts/asa_metadata_registry/contract.py:258-260
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA + offset, length=size
    // )
    uncover 2
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:591
    // if payload != existing_slice:
    !=
    bz arc89_replace_metadata_slice_after_if_else@3
    // smart_contracts/asa_metadata_registry/contract.py:592-596
    // # Update Metadata Body
    // self.asset_metadata.box(asset_id).replace(
    //     start_index=const.IDX_METADATA + offset.as_uint64(),
    //     value=payload,
    // )
    dup2
    dig 4
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:598-599
    // # Update Metadata Header
    // self._update_header_excluding_flags_and_emit(asset_id)
    dig 3
    callsub _update_header_excluding_flags_and_emit

arc89_replace_metadata_slice_after_if_else@3:
    // smart_contracts/asa_metadata_registry/contract.py:566
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_migrate_metadata[routing]() -> void:
arc89_migrate_metadata:
    // smart_contracts/asa_metadata_registry/contract.py:601
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:616-617
    // # Preconditions
    // self._check_set_flag_preconditions(asset_id)
    dig 1
    callsub _check_set_flag_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:619
    // new_registry_id != Global.current_application_id.id
    dup
    global CurrentApplicationID
    !=
    // smart_contracts/asa_metadata_registry/contract.py:618-620
    // assert (
    //     new_registry_id != Global.current_application_id.id
    // ), err.NEW_REGISTRY_ID_INVALID
    assert // Invalid new ASA Metadata Registry ID, must be different from current
    // smart_contracts/asa_metadata_registry/contract.py:154
    // self.asset_metadata.box(asa).replace(
    swap
    itob
    // smart_contracts/asa_metadata_registry/contract.py:156
    // value=op.itob(deprecated_by),
    swap
    itob
    // smart_contracts/asa_metadata_registry/contract.py:154-157
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_DEPRECATED_BY,
    //     value=op.itob(deprecated_by),
    // )
    dig 1
    // smart_contracts/asa_metadata_registry/contract.py:155
    // start_index=const.IDX_DEPRECATED_BY,
    pushint 43
    // smart_contracts/asa_metadata_registry/contract.py:154-157
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_DEPRECATED_BY,
    //     value=op.itob(deprecated_by),
    // )
    uncover 2
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:628
    // round=Global.round,
    global Round
    // smart_contracts/asa_metadata_registry/contract.py:629
    // timestamp=Global.latest_timestamp,
    global LatestTimestamp
    // smart_contracts/asa_metadata_registry/contract.py:147-150
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_DEPRECATED_BY,
    //     length=const.DEPRECATED_BY_SIZE,
    // )
    dig 2
    // smart_contracts/asa_metadata_registry/contract.py:148
    // start_index=const.IDX_DEPRECATED_BY,
    pushint 43
    // smart_contracts/asa_metadata_registry/contract.py:149
    // length=const.DEPRECATED_BY_SIZE,
    intc_2 // 8
    // smart_contracts/asa_metadata_registry/contract.py:147-150
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_DEPRECATED_BY,
    //     length=const.DEPRECATED_BY_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:146-151
    // return op.btoi(
    //     self.asset_metadata.box(asa).extract(
    //         start_index=const.IDX_DEPRECATED_BY,
    //         length=const.DEPRECATED_BY_SIZE,
    //     )
    // )
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:626-631
    // abi.Arc89MetadataMigrated(
    //     asset_id=asset_id.id,
    //     round=Global.round,
    //     timestamp=Global.latest_timestamp,
    //     new_registry_id=self._get_deprecated_by(asset_id),
    // )
    itob
    uncover 3
    swap
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/asa_metadata_registry/contract.py:625-632
    // arc4.emit(
    //     abi.Arc89MetadataMigrated(
    //         asset_id=asset_id.id,
    //         round=Global.round,
    //         timestamp=Global.latest_timestamp,
    //         new_registry_id=self._get_deprecated_by(asset_id),
    //     )
    // )
    pushbytes 0xc87023bf // method "Arc89MetadataMigrated(uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // smart_contracts/asa_metadata_registry/contract.py:601
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_delete_metadata[routing]() -> void:
arc89_delete_metadata:
    bytec_1 // ""
    // smart_contracts/asa_metadata_registry/contract.py:634
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dupn 2
    // smart_contracts/asa_metadata_registry/contract.py:47
    // return asa in self.asset_metadata
    itob
    dup
    cover 2
    box_len
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:649-650
    // # Preconditions
    // assert self._metadata_exists(asset_id), err.ASSET_METADATA_NOT_EXIST
    assert // Asset Metadata does not exist for the specified ASA
    // smart_contracts/asa_validation.py:15
    // _creator, exists = op.AssetParamsGet.asset_creator(asa)
    asset_params_get AssetCreator
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:651
    // if self._asa_exists(asset_id):
    bz arc89_delete_metadata_after_if_else@3
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:110
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:108-111
    // return op.getbit(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:652
    // assert not self._is_immutable(asset_id), err.IMMUTABLE
    !
    assert // Metadata is immutable
    // smart_contracts/asa_metadata_registry/contract.py:653
    // assert self._is_asa_manager(asset_id), err.UNAUTHORIZED
    dig 1
    callsub _is_asa_manager
    assert // Unauthorized, must be the Asset Manager

arc89_delete_metadata_after_if_else@3:
    // smart_contracts/asa_metadata_registry/contract.py:655-656
    // # Delete Metadata and refund MBR
    // mbr_i = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/asa_metadata_registry/contract.py:657
    // del self.asset_metadata[asset_id]
    dig 1
    box_del
    pop
    // smart_contracts/asa_metadata_registry/contract.py:658
    // mbr_delta_amount = mbr_i - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    bury 3
    // smart_contracts/asa_metadata_registry/contract.py:659-662
    // itxn.Payment(
    //     receiver=asset_id.manager if self._asa_exists(asset_id) else Txn.sender,
    //     amount=mbr_delta_amount,
    // ).submit()
    itxn_begin
    // smart_contracts/asa_validation.py:15
    // _creator, exists = op.AssetParamsGet.asset_creator(asa)
    dig 1
    asset_params_get AssetCreator
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:660
    // receiver=asset_id.manager if self._asa_exists(asset_id) else Txn.sender,
    bz arc89_delete_metadata_ternary_false@5
    dig 1
    asset_params_get AssetManager
    assert // asset exists

arc89_delete_metadata_ternary_merge@6:
    dig 3
    dup
    itxn_field Amount
    swap
    itxn_field Receiver
    // smart_contracts/asa_metadata_registry/contract.py:659
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/asa_metadata_registry/contract.py:659-662
    // itxn.Payment(
    //     receiver=asset_id.manager if self._asa_exists(asset_id) else Txn.sender,
    //     amount=mbr_delta_amount,
    // ).submit()
    itxn_submit
    // smart_contracts/asa_metadata_registry/contract.py:668
    // timestamp=Global.latest_timestamp,
    global LatestTimestamp
    // smart_contracts/asa_metadata_registry/contract.py:667
    // round=Global.round,
    global Round
    // smart_contracts/asa_metadata_registry/contract.py:665-669
    // abi.Arc89MetadataDeleted(
    //     asset_id=asset_id.id,
    //     round=Global.round,
    //     timestamp=Global.latest_timestamp,
    // )
    itob
    dig 3
    swap
    concat
    swap
    itob
    concat
    // smart_contracts/asa_metadata_registry/contract.py:664-670
    // arc4.emit(
    //     abi.Arc89MetadataDeleted(
    //         asset_id=asset_id.id,
    //         round=Global.round,
    //         timestamp=Global.latest_timestamp,
    //     )
    // )
    pushbytes 0xbc3f20d1 // method "Arc89MetadataDeleted(uint64,uint64,uint64)"
    swap
    concat
    log
    // smart_contracts/asa_metadata_registry/contract.py:672-674
    // return abi.MbrDelta(
    //     sign=arc4.UInt8(enums.MBR_DELTA_NEG), amount=mbr_delta_amount
    // )
    itob
    // smart_contracts/asa_metadata_registry/contract.py:634
    // @arc4.abimethod
    pushbytes 0x151f7c75ff
    swap
    concat
    log
    intc_0 // 1
    return

arc89_delete_metadata_ternary_false@5:
    // smart_contracts/asa_metadata_registry/contract.py:660
    // receiver=asset_id.manager if self._asa_exists(asset_id) else Txn.sender,
    txn Sender
    b arc89_delete_metadata_ternary_merge@6


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_extra_payload[routing]() -> void:
arc89_extra_payload:
    // smart_contracts/asa_metadata_registry/contract.py:676
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/asa_metadata_registry/contract.py:690-691
    // # Preconditions
    // assert Global.group_size >= 2, err.NO_PAYLOAD_HEAD_CALL
    global GroupSize
    intc_3 // 2
    >=
    assert // No payload head call in Group
    // smart_contracts/asa_validation.py:15
    // _creator, exists = op.AssetParamsGet.asset_creator(asa)
    dup
    asset_params_get AssetCreator
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:692
    // assert self._asa_exists(asset_id), err.ASA_NOT_EXIST
    assert // The specified ASA does not exist
    // smart_contracts/asa_metadata_registry/contract.py:47
    // return asa in self.asset_metadata
    dup
    itob
    box_len
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:693
    // assert self._metadata_exists(asset_id), err.ASSET_METADATA_NOT_EXIST
    assert // Asset Metadata does not exist for the specified ASA
    // smart_contracts/asa_metadata_registry/contract.py:694
    // assert self._is_asa_manager(asset_id), err.UNAUTHORIZED
    callsub _is_asa_manager
    assert // Unauthorized, must be the Asset Manager
    // smart_contracts/asa_metadata_registry/contract.py:676
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_set_reversible_flag[routing]() -> void:
arc89_set_reversible_flag:
    // smart_contracts/asa_metadata_registry/contract.py:696
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 3
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_1 // 0
    getbit
    dup
    cover 3
    cover 3
    // smart_contracts/asa_metadata_registry/contract.py:712-713
    // # Preconditions
    // self._check_set_flag_preconditions(asset_id)
    dig 1
    callsub _check_set_flag_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:714
    // assert flag.as_uint64() <= flg.REV_FLG_RESERVED_7, err.FLAG_IDX_INVALID
    btoi
    dup
    pushint 7
    <=
    assert // Invalid flag index
    // smart_contracts/asa_metadata_registry/contract.py:73
    // return self.asset_metadata.box(asa).extract(
    swap
    itob
    dup
    cover 3
    // smart_contracts/asa_metadata_registry/contract.py:74
    // start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    intc_0 // 1
    dup
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:80
    // const.BIT_RIGHTMOST_REV_FLAG - flag,
    pushint 7
    uncover 2
    -
    dup
    cover 3
    // smart_contracts/asa_metadata_registry/contract.py:78-81
    // return op.getbit(
    //     self._get_reversible_flags(asa),
    //     const.BIT_RIGHTMOST_REV_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:718
    // if value != existing_value:
    !=
    bz arc89_set_reversible_flag_after_if_else@3
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    dig 1
    dup
    // smart_contracts/asa_metadata_registry/contract.py:74
    // start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    intc_0 // 1
    dup
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:86-88
    // updated_flags = op.setbit_bytes(
    //     self._get_reversible_flags(asa), const.BIT_RIGHTMOST_REV_FLAG - flag, value
    // )
    dig 2
    dig 5
    setbit
    // smart_contracts/asa_metadata_registry/contract.py:93
    // start_index=const.IDX_REVERSIBLE_FLAGS, value=flags
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:92-94
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, value=flags
    // )
    swap
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:722-723
    // # Update Metadata Header
    // self._update_header_excluding_flags_and_emit(asset_id)
    dig 3
    callsub _update_header_excluding_flags_and_emit

arc89_set_reversible_flag_after_if_else@3:
    // smart_contracts/asa_metadata_registry/contract.py:696
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_set_irreversible_flag[routing]() -> void:
arc89_set_irreversible_flag:
    // smart_contracts/asa_metadata_registry/contract.py:725
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    // smart_contracts/asa_metadata_registry/contract.py:739-740
    // # Preconditions
    // self._check_set_flag_preconditions(asset_id)
    swap
    callsub _check_set_flag_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:742
    // flg.IRR_FLG_RESERVED_2 <= flag.as_uint64() <= flg.IRR_FLG_RESERVED_6
    btoi
    dup
    intc_3 // 2
    >=
    bz arc89_set_irreversible_flag_bool_false@4
    dup
    pushint 6
    <=
    bz arc89_set_irreversible_flag_bool_false@4
    intc_0 // 1

arc89_set_irreversible_flag_bool_merge@5:
    // smart_contracts/asa_metadata_registry/contract.py:741-743
    // assert (
    //     flg.IRR_FLG_RESERVED_2 <= flag.as_uint64() <= flg.IRR_FLG_RESERVED_6
    // ), err.FLAG_IDX_INVALID
    assert // Invalid flag index
    // smart_contracts/asa_metadata_registry/contract.py:97
    // return self.asset_metadata.box(asa).extract(
    dig 1
    itob
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:110
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    pushint 7
    dig 2
    -
    // smart_contracts/asa_metadata_registry/contract.py:108-111
    // return op.getbit(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:747
    // if not existing_value:
    bnz arc89_set_irreversible_flag_after_if_else@7
    // smart_contracts/asa_metadata_registry/contract.py:748-749
    // # Set Irreversible Flag
    // self._set_irreversible_flag_value(asset_id, flag.as_uint64())
    dig 1
    dup
    dig 2
    callsub _set_irreversible_flag_value
    // smart_contracts/asa_metadata_registry/contract.py:751-752
    // # Update Metadata Header
    // self._update_header_excluding_flags_and_emit(asset_id)
    callsub _update_header_excluding_flags_and_emit

arc89_set_irreversible_flag_after_if_else@7:
    // smart_contracts/asa_metadata_registry/contract.py:725
    // @arc4.abimethod
    intc_0 // 1
    return

arc89_set_irreversible_flag_bool_false@4:
    intc_1 // 0
    b arc89_set_irreversible_flag_bool_merge@5


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_set_immutable[routing]() -> void:
arc89_set_immutable:
    // smart_contracts/asa_metadata_registry/contract.py:754
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:766-767
    // # Preconditions
    // self._check_set_flag_preconditions(asset_id)
    dup
    callsub _check_set_flag_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:769-770
    // # Set Immutable Flag
    // self._set_irreversible_flag_value(asset_id, UInt64(flg.IRR_FLG_IMMUTABLE))
    dup
    pushint 7
    callsub _set_irreversible_flag_value
    // smart_contracts/asa_metadata_registry/contract.py:772-773
    // # Update Metadata Header
    // self._update_header_excluding_flags_and_emit(asset_id)
    callsub _update_header_excluding_flags_and_emit
    // smart_contracts/asa_metadata_registry/contract.py:754
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_partial_uri[routing]() -> void:
arc89_get_metadata_partial_uri:
    // smart_contracts/asa_metadata_registry/contract.py:805
    // arc90_box_query(Global.current_application_id, Bytes())
    global CurrentApplicationID
    bytec_1 // 0x
    callsub arc90_box_query
    // smart_contracts/asa_metadata_registry/contract.py:796
    // @arc4.abimethod(readonly=True)
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_mbr_delta[routing]() -> void:
arc89_get_metadata_mbr_delta:
    bytec_1 // ""
    dup
    // smart_contracts/asa_metadata_registry/contract.py:808
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    // smart_contracts/asa_metadata_registry/contract.py:828
    // new_metadata_size.as_uint64() <= const.MAX_METADATA_SIZE
    btoi
    dup
    cover 2
    intc 6 // 30506
    <=
    // smart_contracts/asa_metadata_registry/contract.py:826-829
    // # Preconditions
    // assert (
    //     new_metadata_size.as_uint64() <= const.MAX_METADATA_SIZE
    // ), err.EXCEEDS_MAX_METADATA_SIZE
    assert // Invalid Metadata size, exceeds maximum allowed size
    // smart_contracts/asa_metadata_registry/contract.py:47
    // return asa in self.asset_metadata
    itob
    box_len
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:831
    // if self._metadata_exists(asset_id):
    bz arc89_get_metadata_mbr_delta_else_body@9
    // smart_contracts/asa_metadata_registry/contract.py:832
    // metadata_size = self._get_metadata_size(asset_id)
    dig 1
    callsub _get_metadata_size
    dup
    bury 4
    // smart_contracts/asa_metadata_registry/contract.py:833
    // flat_mbr = UInt64(0)
    intc_1 // 0
    bury 5
    // smart_contracts/asa_metadata_registry/contract.py:834
    // if new_metadata_size.as_uint64() == metadata_size:
    dig 1
    ==
    bz arc89_get_metadata_mbr_delta_else_body@4
    // smart_contracts/asa_metadata_registry/contract.py:836
    // delta_size = UInt64(0)
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:835
    // sign = UInt64(enums.MBR_DELTA_NULL)
    dup

arc89_get_metadata_mbr_delta_after_if_else@10:
    // smart_contracts/asa_metadata_registry/contract.py:852
    // delta_amount = flat_mbr + const.BYTE_MBR * delta_size
    pushint 400
    uncover 2
    *
    dig 5
    +
    // smart_contracts/asa_metadata_registry/contract.py:854
    // return abi.MbrDelta(sign=arc4.UInt8(sign), amount=delta_amount)
    swap
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    swap
    itob
    concat
    // smart_contracts/asa_metadata_registry/contract.py:808
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

arc89_get_metadata_mbr_delta_else_body@4:
    // smart_contracts/asa_metadata_registry/contract.py:837
    // elif new_metadata_size.as_uint64() > metadata_size:
    dup
    dig 3
    >
    bz arc89_get_metadata_mbr_delta_else_body@6
    // smart_contracts/asa_metadata_registry/contract.py:838
    // sign = UInt64(enums.MBR_DELTA_POS)
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:839
    // delta_size = new_metadata_size.as_uint64() - metadata_size
    dig 1
    dig 4
    -
    swap
    b arc89_get_metadata_mbr_delta_after_if_else@10

arc89_get_metadata_mbr_delta_else_body@6:
    // smart_contracts/asa_metadata_registry/contract.py:841
    // sign = UInt64(enums.MBR_DELTA_NEG)
    pushint 255
    // smart_contracts/asa_metadata_registry/contract.py:842
    // delta_size = metadata_size - new_metadata_size.as_uint64()
    dig 3
    dig 2
    -
    swap
    b arc89_get_metadata_mbr_delta_after_if_else@10

arc89_get_metadata_mbr_delta_else_body@9:
    // smart_contracts/asa_metadata_registry/contract.py:844
    // flat_mbr = UInt64(const.FLAT_MBR)
    pushint 2500
    bury 4
    // smart_contracts/asa_metadata_registry/contract.py:845
    // sign = UInt64(enums.MBR_DELTA_POS)
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:847-848
    // const.ASSET_METADATA_BOX_KEY_SIZE
    // + const.HEADER_SIZE
    pushint 59
    // smart_contracts/asa_metadata_registry/contract.py:847-849
    // const.ASSET_METADATA_BOX_KEY_SIZE
    // + const.HEADER_SIZE
    // + new_metadata_size.as_uint64()
    dig 2
    +
    swap
    b arc89_get_metadata_mbr_delta_after_if_else@10


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_check_metadata_exists[routing]() -> void:
arc89_check_metadata_exists:
    // smart_contracts/asa_metadata_registry/contract.py:856
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/asa_validation.py:15
    // _creator, exists = op.AssetParamsGet.asset_creator(asa)
    dup
    asset_params_get AssetCreator
    cover 2
    pop
    // smart_contracts/asa_metadata_registry/contract.py:47
    // return asa in self.asset_metadata
    itob
    box_len
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:871-874
    // return abi.MetadataExistence(
    //     asa_exists=self._asa_exists(asset_id),
    //     metadata_exists=self._metadata_exists(asset_id),
    // )
    bytec_2 // 0x00
    intc_1 // 0
    uncover 3
    setbit
    intc_0 // 1
    uncover 2
    setbit
    // smart_contracts/asa_metadata_registry/contract.py:856
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_is_metadata_immutable[routing]() -> void:
arc89_is_metadata_immutable:
    // smart_contracts/asa_metadata_registry/contract.py:876
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dupn 2
    // smart_contracts/asa_metadata_registry/contract.py:891-892
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:97
    // return self.asset_metadata.box(asa).extract(
    itob
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:110
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:108-111
    // return op.getbit(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:894
    // return self._is_immutable(asset_id) or asset_id.manager == Global.zero_address
    bnz arc89_is_metadata_immutable_bool_true@3
    dup
    asset_params_get AssetManager
    assert // asset exists
    global ZeroAddress
    ==
    bz arc89_is_metadata_immutable_bool_false@4

arc89_is_metadata_immutable_bool_true@3:
    intc_0 // 1

arc89_is_metadata_immutable_bool_merge@5:
    // smart_contracts/asa_metadata_registry/contract.py:876
    // @arc4.abimethod(readonly=True)
    bytec_2 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

arc89_is_metadata_immutable_bool_false@4:
    intc_1 // 0
    b arc89_is_metadata_immutable_bool_merge@5


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_is_metadata_short[routing]() -> void:
arc89_is_metadata_short:
    // smart_contracts/asa_metadata_registry/contract.py:896
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:911-912
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dup
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:56
    // return self.asset_metadata.box(asa).extract(
    itob
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:57
    // start_index=const.IDX_METADATA_IDENTIFIERS,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:58
    // length=const.METADATA_IDENTIFIERS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:69
    // const.BIT_RIGHTMOST_IDENTIFIER - flg.ID_SHORT,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:67-70
    // return op.getbit(
    //     self._get_metadata_identifiers(asa),
    //     const.BIT_RIGHTMOST_IDENTIFIER - flg.ID_SHORT,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:133-136
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_LAST_MODIFIED_ROUND,
    //     length=const.LAST_MODIFIED_ROUND_SIZE,
    // )
    swap
    // smart_contracts/asa_metadata_registry/contract.py:134
    // start_index=const.IDX_LAST_MODIFIED_ROUND,
    pushint 35
    // smart_contracts/asa_metadata_registry/contract.py:135
    // length=const.LAST_MODIFIED_ROUND_SIZE,
    intc_2 // 8
    // smart_contracts/asa_metadata_registry/contract.py:133-136
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_LAST_MODIFIED_ROUND,
    //     length=const.LAST_MODIFIED_ROUND_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:132-137
    // return op.btoi(
    //     self.asset_metadata.box(asa).extract(
    //         start_index=const.IDX_LAST_MODIFIED_ROUND,
    //         length=const.LAST_MODIFIED_ROUND_SIZE,
    //     )
    // )
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:914-917
    // return abi.MutableFlag(
    //     flag=self._is_short(asset_id),
    //     last_modified_round=self._get_last_modified_round(asset_id),
    // )
    bytec_2 // 0x00
    intc_1 // 0
    uncover 3
    setbit
    swap
    itob
    concat
    // smart_contracts/asa_metadata_registry/contract.py:896
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_header[routing]() -> void:
arc89_get_metadata_header:
    // smart_contracts/asa_metadata_registry/contract.py:919
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:935-936
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dup
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:56
    // return self.asset_metadata.box(asa).extract(
    itob
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:57
    // start_index=const.IDX_METADATA_IDENTIFIERS,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:58
    // length=const.METADATA_IDENTIFIERS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    dig 1
    // smart_contracts/asa_metadata_registry/contract.py:74
    // start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    intc_0 // 1
    dup
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    dig 2
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:122-124
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_HASH, length=const.METADATA_HASH_SIZE
    // )
    dig 3
    // smart_contracts/asa_metadata_registry/contract.py:123
    // start_index=const.IDX_METADATA_HASH, length=const.METADATA_HASH_SIZE
    pushints 3 32
    // smart_contracts/asa_metadata_registry/contract.py:122-124
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_HASH, length=const.METADATA_HASH_SIZE
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:944
    // hash=abi.Hash(self._get_metadata_hash(asset_id)),
    dup
    len
    pushint 32
    ==
    assert // expected bytes to be length 32
    // smart_contracts/asa_metadata_registry/contract.py:133-136
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_LAST_MODIFIED_ROUND,
    //     length=const.LAST_MODIFIED_ROUND_SIZE,
    // )
    dig 4
    // smart_contracts/asa_metadata_registry/contract.py:134
    // start_index=const.IDX_LAST_MODIFIED_ROUND,
    pushint 35
    // smart_contracts/asa_metadata_registry/contract.py:135
    // length=const.LAST_MODIFIED_ROUND_SIZE,
    intc_2 // 8
    // smart_contracts/asa_metadata_registry/contract.py:133-136
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_LAST_MODIFIED_ROUND,
    //     length=const.LAST_MODIFIED_ROUND_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:132-137
    // return op.btoi(
    //     self.asset_metadata.box(asa).extract(
    //         start_index=const.IDX_LAST_MODIFIED_ROUND,
    //         length=const.LAST_MODIFIED_ROUND_SIZE,
    //     )
    // )
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:147-150
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_DEPRECATED_BY,
    //     length=const.DEPRECATED_BY_SIZE,
    // )
    uncover 5
    // smart_contracts/asa_metadata_registry/contract.py:148
    // start_index=const.IDX_DEPRECATED_BY,
    pushint 43
    // smart_contracts/asa_metadata_registry/contract.py:149
    // length=const.DEPRECATED_BY_SIZE,
    intc_2 // 8
    // smart_contracts/asa_metadata_registry/contract.py:147-150
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_DEPRECATED_BY,
    //     length=const.DEPRECATED_BY_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:146-151
    // return op.btoi(
    //     self.asset_metadata.box(asa).extract(
    //         start_index=const.IDX_DEPRECATED_BY,
    //         length=const.DEPRECATED_BY_SIZE,
    //     )
    // )
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:938-947
    // return abi.MetadataHeader(
    //     identifiers=arc4.Byte.from_bytes(self._get_metadata_identifiers(asset_id)),
    //     reversible_flags=arc4.Byte.from_bytes(self._get_reversible_flags(asset_id)),
    //     irreversible_flags=arc4.Byte.from_bytes(
    //         self._get_irreversible_flags(asset_id)
    //     ),
    //     hash=abi.Hash(self._get_metadata_hash(asset_id)),
    //     last_modified_round=self._get_last_modified_round(asset_id),
    //     deprecated_by=self._get_deprecated_by(asset_id),
    // )
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/asa_metadata_registry/contract.py:919
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_pagination[routing]() -> void:
arc89_get_metadata_pagination:
    // smart_contracts/asa_metadata_registry/contract.py:949
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:963-964
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dup
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:967
    // metadata_size=arc4.UInt16(self._get_metadata_size(asset_id)),
    dup
    callsub _get_metadata_size
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/asa_metadata_registry/contract.py:232
    // n = self._get_metadata_size(asa)
    swap
    callsub _get_metadata_size
    // smart_contracts/avm_common.py:31
    // return (num + (den - 1)) // den
    intc 5 // 1006
    +
    // smart_contracts/asa_metadata_registry/contract.py:233
    // return ceil_div(num=n, den=UInt64(const.PAGE_SIZE))
    intc 4 // 1007
    // smart_contracts/avm_common.py:31
    // return (num + (den - 1)) // den
    /
    // smart_contracts/asa_metadata_registry/contract.py:969
    // total_pages=arc4.UInt8(self._get_total_pages(asset_id)),
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asa_metadata_registry/contract.py:966-970
    // return abi.Pagination(
    //     metadata_size=arc4.UInt16(self._get_metadata_size(asset_id)),
    //     page_size=arc4.UInt16(const.PAGE_SIZE),
    //     total_pages=arc4.UInt8(self._get_total_pages(asset_id)),
    // )
    swap
    // smart_contracts/asa_metadata_registry/contract.py:968
    // page_size=arc4.UInt16(const.PAGE_SIZE),
    pushbytes 0x03ef
    // smart_contracts/asa_metadata_registry/contract.py:966-970
    // return abi.Pagination(
    //     metadata_size=arc4.UInt16(self._get_metadata_size(asset_id)),
    //     page_size=arc4.UInt16(const.PAGE_SIZE),
    //     total_pages=arc4.UInt8(self._get_total_pages(asset_id)),
    // )
    concat
    swap
    concat
    // smart_contracts/asa_metadata_registry/contract.py:949
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata[routing]() -> void:
arc89_get_metadata:
    bytec_1 // ""
    // smart_contracts/asa_metadata_registry/contract.py:972
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    // smart_contracts/asa_metadata_registry/contract.py:989-990
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dup
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:232
    // n = self._get_metadata_size(asa)
    callsub _get_metadata_size
    // smart_contracts/avm_common.py:31
    // return (num + (den - 1)) // den
    intc 5 // 1006
    +
    // smart_contracts/asa_metadata_registry/contract.py:233
    // return ceil_div(num=n, den=UInt64(const.PAGE_SIZE))
    intc 4 // 1007
    // smart_contracts/avm_common.py:31
    // return (num + (den - 1)) // den
    /
    dup
    cover 2
    // smart_contracts/asa_metadata_registry/contract.py:992
    // if total_pages > 0:
    bz arc89_get_metadata_else_body@3
    // smart_contracts/asa_metadata_registry/contract.py:993
    // assert page.as_uint64() < total_pages, err.PAGE_IDX_INVALID
    btoi
    dup
    dig 2
    dup
    cover 2
    <
    assert // Invalid page index
    // smart_contracts/asa_metadata_registry/contract.py:994
    // has_next_page = page.as_uint64() < total_pages - 1
    intc_0 // 1
    -
    dig 1
    >
    bury 4
    // smart_contracts/asa_metadata_registry/contract.py:995
    // page_content = self._get_metadata_page(asset_id, page.as_uint64())
    dig 2
    swap
    callsub _get_metadata_page

arc89_get_metadata_after_if_else@4:
    // smart_contracts/asa_metadata_registry/contract.py:133
    // self.asset_metadata.box(asa).extract(
    dig 2
    itob
    // smart_contracts/asa_metadata_registry/contract.py:134
    // start_index=const.IDX_LAST_MODIFIED_ROUND,
    pushint 35
    // smart_contracts/asa_metadata_registry/contract.py:135
    // length=const.LAST_MODIFIED_ROUND_SIZE,
    intc_2 // 8
    // smart_contracts/asa_metadata_registry/contract.py:133-136
    // self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_LAST_MODIFIED_ROUND,
    //     length=const.LAST_MODIFIED_ROUND_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:132-137
    // return op.btoi(
    //     self.asset_metadata.box(asa).extract(
    //         start_index=const.IDX_LAST_MODIFIED_ROUND,
    //         length=const.LAST_MODIFIED_ROUND_SIZE,
    //     )
    // )
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:1001-1005
    // return abi.PaginatedMetadata(
    //     has_next_page=has_next_page,
    //     last_modified_round=self._get_last_modified_round(asset_id),
    //     page_content=page_content,
    // )
    bytec_2 // 0x00
    intc_1 // 0
    dig 6
    setbit
    swap
    itob
    concat
    swap
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    pushbytes 0x000b
    concat
    swap
    concat
    // smart_contracts/asa_metadata_registry/contract.py:972
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

arc89_get_metadata_else_body@3:
    // smart_contracts/asa_metadata_registry/contract.py:997
    // assert page.as_uint64() == 0, err.PAGE_IDX_INVALID
    btoi
    !
    assert // Invalid page index
    // smart_contracts/asa_metadata_registry/contract.py:998
    // has_next_page = False
    intc_1 // 0
    bury 3
    // smart_contracts/asa_metadata_registry/contract.py:999
    // page_content = Bytes()
    bytec_1 // 0x
    b arc89_get_metadata_after_if_else@4


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_slice[routing]() -> void:
arc89_get_metadata_slice:
    // smart_contracts/asa_metadata_registry/contract.py:1007
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    // smart_contracts/asa_metadata_registry/contract.py:1026-1027
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dig 2
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:1028
    // assert size.as_uint64() <= const.PAGE_SIZE, err.EXCEEDS_PAGE_SIZE
    btoi
    dup
    intc 4 // 1007
    <=
    assert // Payload exceeds page size
    // smart_contracts/asa_metadata_registry/contract.py:1029
    // assert offset.as_uint64() + size.as_uint64() <= self._get_metadata_size(
    swap
    btoi
    dup
    dig 2
    +
    // smart_contracts/asa_metadata_registry/contract.py:1029-1031
    // assert offset.as_uint64() + size.as_uint64() <= self._get_metadata_size(
    //     asset_id
    // ), err.EXCEEDS_METADATA_SIZE
    dig 3
    callsub _get_metadata_size
    <=
    assert // Slice exceeds metadata range
    // smart_contracts/asa_metadata_registry/contract.py:1033
    // metadata_slice = self.asset_metadata.box(asset_id).extract(
    uncover 2
    itob
    // smart_contracts/asa_metadata_registry/contract.py:1034
    // start_index=const.IDX_METADATA + offset.as_uint64(), length=size.as_uint64()
    pushint 51
    uncover 2
    +
    // smart_contracts/asa_metadata_registry/contract.py:1033-1035
    // metadata_slice = self.asset_metadata.box(asset_id).extract(
    //     start_index=const.IDX_METADATA + offset.as_uint64(), length=size.as_uint64()
    // )
    uncover 2
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:1007
    // @arc4.abimethod(readonly=True)
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_header_hash[routing]() -> void:
arc89_get_metadata_header_hash:
    // smart_contracts/asa_metadata_registry/contract.py:1038
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:1053-1054
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dup
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:1056
    // return abi.Hash(self._compute_header_hash(asset_id))
    callsub _compute_header_hash
    dup
    len
    pushint 32
    ==
    assert // expected bytes to be length 32
    // smart_contracts/asa_metadata_registry/contract.py:1038
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_page_hash[routing]() -> void:
arc89_get_metadata_page_hash:
    // smart_contracts/asa_metadata_registry/contract.py:1058
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    // smart_contracts/asa_metadata_registry/contract.py:1075-1076
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dig 1
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:232
    // n = self._get_metadata_size(asa)
    dig 1
    callsub _get_metadata_size
    // smart_contracts/avm_common.py:31
    // return (num + (den - 1)) // den
    intc 5 // 1006
    +
    // smart_contracts/asa_metadata_registry/contract.py:233
    // return ceil_div(num=n, den=UInt64(const.PAGE_SIZE))
    intc 4 // 1007
    // smart_contracts/avm_common.py:31
    // return (num + (den - 1)) // den
    /
    // smart_contracts/asa_metadata_registry/contract.py:1078
    // if total_pages > 0:
    dup
    assert // Metadata is empty
    // smart_contracts/asa_metadata_registry/contract.py:1079
    // assert page.as_uint64() < total_pages, err.PAGE_IDX_INVALID
    swap
    btoi
    dup
    uncover 2
    <
    assert // Invalid page index
    // smart_contracts/asa_metadata_registry/contract.py:1083
    // page_content = self._get_metadata_page(asset_id, page.as_uint64())
    dup2
    callsub _get_metadata_page
    // smart_contracts/asa_metadata_registry/contract.py:1084
    // page_hash = self._compute_page_hash(asset_id, page.as_uint64(), page_content)
    callsub _compute_page_hash
    // smart_contracts/asa_metadata_registry/contract.py:1085
    // return abi.Hash(page_hash)
    dup
    len
    pushint 32
    ==
    assert // expected bytes to be length 32
    // smart_contracts/asa_metadata_registry/contract.py:1058
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_hash[routing]() -> void:
arc89_get_metadata_hash:
    // smart_contracts/asa_metadata_registry/contract.py:1087
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:1102-1103
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dup
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:122
    // return self.asset_metadata.box(asa).extract(
    itob
    // smart_contracts/asa_metadata_registry/contract.py:123
    // start_index=const.IDX_METADATA_HASH, length=const.METADATA_HASH_SIZE
    pushints 3 32
    // smart_contracts/asa_metadata_registry/contract.py:122-124
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_HASH, length=const.METADATA_HASH_SIZE
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:1105
    // return abi.Hash(self._get_metadata_hash(asset_id))
    dup
    len
    pushint 32
    ==
    assert // expected bytes to be length 32
    // smart_contracts/asa_metadata_registry/contract.py:1087
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_string_by_key[routing]() -> void:
arc89_get_metadata_string_by_key:
    // smart_contracts/asa_metadata_registry/contract.py:1107
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/asa_metadata_registry/contract.py:1126-1127
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dig 1
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:1129-1134
    // # Fetch key's value
    // #  WARNING: The following conditions cause AVM runtime error:
    // # - The short Metadata is not a valid UTF-8 encoded JSON object
    // # - The top-level key does not exist
    // # - The top-level key's value is not a JSON String
    // obj = self._get_short_metadata(asset_id)
    swap
    callsub _get_short_metadata
    // smart_contracts/asa_metadata_registry/contract.py:1135
    // value = op.JsonRef.json_string(obj, key.bytes)
    swap
    json_ref JSONString
    // smart_contracts/asa_metadata_registry/contract.py:1137-1138
    // # Postconditions
    // assert value.length <= const.PAGE_SIZE, err.EXCEEDS_PAGE_SIZE
    dup
    len
    dup
    intc 4 // 1007
    <=
    assert // Payload exceeds page size
    // smart_contracts/asa_metadata_registry/contract.py:1107
    // @arc4.abimethod(readonly=True)
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_uint64_by_key[routing]() -> void:
arc89_get_metadata_uint64_by_key:
    // smart_contracts/asa_metadata_registry/contract.py:1142
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/asa_metadata_registry/contract.py:1161-1162
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dig 1
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:1164-1169
    // # Fetch key's value
    // #  WARNING: The following conditions cause AVM runtime error:
    // # - The short Metadata is not a valid UTF-8 encoded JSON object
    // # - The top-level key does not exist
    // # - The top-level key's value is not a JSON Uint64
    // obj = self._get_short_metadata(asset_id)
    swap
    callsub _get_short_metadata
    // smart_contracts/asa_metadata_registry/contract.py:1170
    // value = op.JsonRef.json_uint64(obj, key.bytes)
    swap
    json_ref JSONUint64
    // smart_contracts/asa_metadata_registry/contract.py:1142
    // @arc4.abimethod(readonly=True)
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_object_by_key[routing]() -> void:
arc89_get_metadata_object_by_key:
    // smart_contracts/asa_metadata_registry/contract.py:1174
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/asa_metadata_registry/contract.py:1193-1194
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dig 1
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:1196-1201
    // # Fetch key's value
    // #  WARNING: The following conditions cause AVM runtime error:
    // # - The short Metadata is not a valid UTF-8 encoded JSON object
    // # - The top-level key does not exist
    // # - The top-level key's value is not a JSON Object
    // obj = self._get_short_metadata(asset_id)
    swap
    callsub _get_short_metadata
    // smart_contracts/asa_metadata_registry/contract.py:1202
    // value = op.JsonRef.json_object(obj, key.bytes)
    swap
    json_ref JSONObject
    // smart_contracts/asa_metadata_registry/contract.py:1204-1205
    // # Postconditions
    // assert value.length <= const.PAGE_SIZE, err.EXCEEDS_PAGE_SIZE
    dup
    len
    dup
    intc 4 // 1007
    <=
    assert // Payload exceeds page size
    // smart_contracts/asa_metadata_registry/contract.py:1174
    // @arc4.abimethod(readonly=True)
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.arc89_get_metadata_b64_bytes_by_key[routing]() -> void:
arc89_get_metadata_b64_bytes_by_key:
    // smart_contracts/asa_metadata_registry/contract.py:1209
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 3
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    // smart_contracts/asa_metadata_registry/contract.py:1226-1227
    // # Preconditions
    // self._check_existence_preconditions(asset_id)
    dig 2
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:1229
    // b64_encoding.as_uint64() <= enums.B64_STD_ENCODING
    btoi
    dup
    intc_0 // 1
    <=
    // smart_contracts/asa_metadata_registry/contract.py:1228-1230
    // assert (
    //     b64_encoding.as_uint64() <= enums.B64_STD_ENCODING
    // ), err.B64_ENCODING_INVALID
    assert // Invalid base64 encoding, must be 0 (URL safe) or 1 (Std)
    // smart_contracts/asa_metadata_registry/contract.py:1232-1237
    // # Fetch key's value
    // #  WARNING: The following conditions cause AVM runtime error:
    // # - The short Metadata is not a valid UTF-8 encoded JSON object
    // # - The top-level key does not exist
    // # - The top-level key's value is not a JSON String
    // obj = self._get_short_metadata(asset_id)
    uncover 2
    callsub _get_short_metadata
    // smart_contracts/asa_metadata_registry/contract.py:1238
    // value = op.JsonRef.json_string(obj, key.bytes)
    uncover 2
    json_ref JSONString
    swap
    // smart_contracts/asa_metadata_registry/contract.py:1240-1244
    // # Decode value
    // #  WARNING: The following conditions cause AVM runtime error:
    // # - The top-level key's value is not a valid base64-encoding string for
    // # the chosen encoding.
    // if b64_encoding.as_uint64() == enums.B64_URL_ENCODING:
    bnz arc89_get_metadata_b64_bytes_by_key_else_body@3
    // smart_contracts/asa_metadata_registry/contract.py:1245
    // decoded_value = op.base64_decode(op.Base64.URLEncoding, value)
    base64_decode URLEncoding

arc89_get_metadata_b64_bytes_by_key_after_if_else@4:
    // smart_contracts/asa_metadata_registry/contract.py:1249-1250
    // # Postconditions
    // assert decoded_value.length <= const.PAGE_SIZE, err.EXCEEDS_PAGE_SIZE
    dup
    len
    dup
    intc 4 // 1007
    <=
    assert // Payload exceeds page size
    // smart_contracts/asa_metadata_registry/contract.py:1209
    // @arc4.abimethod(readonly=True)
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

arc89_get_metadata_b64_bytes_by_key_else_body@3:
    // smart_contracts/asa_metadata_registry/contract.py:1247
    // decoded_value = op.base64_decode(op.Base64.StdEncoding, value)
    base64_decode StdEncoding
    b arc89_get_metadata_b64_bytes_by_key_after_if_else@4


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry.withdraw_balance_excess[routing]() -> void:
withdraw_balance_excess:
    // smart_contracts/asa_metadata_registry/contract.py:1270
    // Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/asa_metadata_registry/contract.py:1271
    // - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/asa_metadata_registry/contract.py:1270-1271
    // Global.current_application_address.balance
    // - Global.current_application_address.min_balance
    -
    // smart_contracts/asa_metadata_registry/contract.py:1273-1276
    // itxn.Payment(
    //     receiver=Global.creator_address,
    //     amount=excess_balance,
    // ).submit()
    itxn_begin
    // smart_contracts/asa_metadata_registry/contract.py:1274
    // receiver=Global.creator_address,
    global CreatorAddress
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/asa_metadata_registry/contract.py:1273
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/asa_metadata_registry/contract.py:1273-1276
    // itxn.Payment(
    //     receiver=Global.creator_address,
    //     amount=excess_balance,
    // ).submit()
    itxn_submit
    // smart_contracts/asa_metadata_registry/contract.py:1261
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._set_irreversible_flag_value(asa: uint64, flag: uint64) -> void:
_set_irreversible_flag_value:
    // smart_contracts/asa_metadata_registry/contract.py:113
    // def _set_irreversible_flag_value(self, asa: Asset, flag: UInt64) -> None:
    proto 2 0
    // smart_contracts/asa_metadata_registry/contract.py:97
    // return self.asset_metadata.box(asa).extract(
    frame_dig -2
    itob
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:116
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    pushint 7
    frame_dig -1
    -
    // smart_contracts/asa_metadata_registry/contract.py:117
    // True,  # noqa: FBT003
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:114-118
    // updated_flags = op.setbit_bytes(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    //     True,  # noqa: FBT003
    // )
    setbit
    // smart_contracts/asa_metadata_registry/contract.py:104
    // start_index=const.IDX_IRREVERSIBLE_FLAGS, value=flags
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:103-105
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS, value=flags
    // )
    swap
    box_replace
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._get_metadata_size(asa: uint64) -> uint64:
_get_metadata_size:
    // smart_contracts/asa_metadata_registry/contract.py:159
    // def _get_metadata_size(self, asa: Asset) -> UInt64:
    proto 1 1
    // smart_contracts/asa_metadata_registry/contract.py:160
    // return self.asset_metadata.box(asa).length - const.HEADER_SIZE
    frame_dig -1
    itob
    box_len
    assert // check Box exists
    pushint 51
    -
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._append_payload(asa: uint64, payload: bytes) -> void:
_append_payload:
    // smart_contracts/asa_metadata_registry/contract.py:162
    // def _append_payload(self, asa: Asset, payload: Bytes) -> None:
    proto 2 0
    // smart_contracts/asa_metadata_registry/contract.py:163
    // old_asset_metadata_box_size = self.asset_metadata.box(asa).length
    frame_dig -2
    itob
    dup
    box_len
    assert // check Box exists
    // smart_contracts/asa_metadata_registry/contract.py:165
    // new_size=old_asset_metadata_box_size + payload.length
    frame_dig -1
    len
    dig 1
    +
    // smart_contracts/asa_metadata_registry/contract.py:164-166
    // self.asset_metadata.box(asa).resize(
    //     new_size=old_asset_metadata_box_size + payload.length
    // )
    dig 2
    swap
    box_resize
    // smart_contracts/asa_metadata_registry/contract.py:167-169
    // self.asset_metadata.box(asa).replace(
    //     start_index=old_asset_metadata_box_size, value=payload
    // )
    frame_dig -1
    box_replace
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._set_metadata_payload(asa: uint64, metadata_size: uint64, payload: bytes) -> void:
_set_metadata_payload:
    // smart_contracts/asa_metadata_registry/contract.py:201-203
    // def _set_metadata_payload(
    //     self, asa: Asset, metadata_size: UInt64, payload: Bytes
    // ) -> None:
    proto 3 0
    // smart_contracts/asa_metadata_registry/contract.py:204-205
    // # Erase existing metadata payload
    // self.asset_metadata.box(asa).resize(new_size=UInt64(const.HEADER_SIZE))
    frame_dig -3
    itob
    dup
    pushint 51
    box_resize
    // smart_contracts/asa_metadata_registry/contract.py:207-208
    // # Append provided payload
    // self._append_payload(asa, payload)
    frame_dig -3
    frame_dig -1
    callsub _append_payload
    // smart_contracts/asa_metadata_registry/contract.py:209
    // assert self._get_metadata_size(asa) <= metadata_size, err.PAYLOAD_OVERFLOW
    frame_dig -3
    callsub _get_metadata_size
    frame_dig -2
    <=
    assert // Payload overflow, exceeds metadata size
    // smart_contracts/asa_metadata_registry/contract.py:211-212
    // # Append staged extra payload (in the same Group, if any)
    // group_size = Global.group_size
    global GroupSize
    // smart_contracts/asa_metadata_registry/contract.py:213
    // group_index = Txn.group_index
    txn GroupIndex
    // smart_contracts/asa_metadata_registry/contract.py:214
    // for idx in urange(group_index + 1, group_size):
    intc_0 // 1
    +

_set_metadata_payload_for_header@1:
    // smart_contracts/asa_metadata_registry/contract.py:214
    // for idx in urange(group_index + 1, group_size):
    frame_dig 2
    frame_dig 1
    <
    bz _set_metadata_payload_after_for@6
    // smart_contracts/asa_metadata_registry/contract.py:182
    // txn.type == TransactionType.ApplicationCall
    frame_dig 2
    gtxns TypeEnum
    pushint 6 // appl
    ==
    // smart_contracts/asa_metadata_registry/contract.py:182-184
    // txn.type == TransactionType.ApplicationCall
    // and txn.app_id == Global.current_application_id
    // and txn.on_completion == OnCompleteAction.NoOp
    bz _set_metadata_payload_bool_false@13
    // smart_contracts/asa_metadata_registry/contract.py:183
    // and txn.app_id == Global.current_application_id
    frame_dig 2
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/asa_metadata_registry/contract.py:182-184
    // txn.type == TransactionType.ApplicationCall
    // and txn.app_id == Global.current_application_id
    // and txn.on_completion == OnCompleteAction.NoOp
    bz _set_metadata_payload_bool_false@13
    // smart_contracts/asa_metadata_registry/contract.py:184
    // and txn.on_completion == OnCompleteAction.NoOp
    frame_dig 2
    gtxns OnCompletion
    // smart_contracts/asa_metadata_registry/contract.py:182-184
    // txn.type == TransactionType.ApplicationCall
    // and txn.app_id == Global.current_application_id
    // and txn.on_completion == OnCompleteAction.NoOp
    bnz _set_metadata_payload_bool_false@13
    intc_0 // 1

_set_metadata_payload_bool_merge@14:
    // smart_contracts/asa_metadata_registry/contract.py:189-192
    // self._is_registry_call(txn)
    // and txn.app_args(const.ARC4_ARG_METHOD_SELECTOR)
    // == arc4.arc4_signature(Arc89Interface.arc89_extra_payload)
    // and txn.app_args(const.ARC89_EXTRA_PAYLOAD_ARG_ASSET_ID) == op.itob(asa.id)
    bz _set_metadata_payload_bool_false@18
    // smart_contracts/asa_metadata_registry/contract.py:190
    // and txn.app_args(const.ARC4_ARG_METHOD_SELECTOR)
    frame_dig 2
    intc_1 // 0
    gtxnsas ApplicationArgs
    // smart_contracts/asa_metadata_registry/contract.py:191
    // == arc4.arc4_signature(Arc89Interface.arc89_extra_payload)
    bytec_3 // method "arc89_extra_payload(uint64,byte[])void"
    // smart_contracts/asa_metadata_registry/contract.py:190-191
    // and txn.app_args(const.ARC4_ARG_METHOD_SELECTOR)
    // == arc4.arc4_signature(Arc89Interface.arc89_extra_payload)
    ==
    // smart_contracts/asa_metadata_registry/contract.py:189-192
    // self._is_registry_call(txn)
    // and txn.app_args(const.ARC4_ARG_METHOD_SELECTOR)
    // == arc4.arc4_signature(Arc89Interface.arc89_extra_payload)
    // and txn.app_args(const.ARC89_EXTRA_PAYLOAD_ARG_ASSET_ID) == op.itob(asa.id)
    bz _set_metadata_payload_bool_false@18
    // smart_contracts/asa_metadata_registry/contract.py:192
    // and txn.app_args(const.ARC89_EXTRA_PAYLOAD_ARG_ASSET_ID) == op.itob(asa.id)
    frame_dig 2
    intc_0 // 1
    gtxnsas ApplicationArgs
    frame_dig 0
    ==
    // smart_contracts/asa_metadata_registry/contract.py:189-192
    // self._is_registry_call(txn)
    // and txn.app_args(const.ARC4_ARG_METHOD_SELECTOR)
    // == arc4.arc4_signature(Arc89Interface.arc89_extra_payload)
    // and txn.app_args(const.ARC89_EXTRA_PAYLOAD_ARG_ASSET_ID) == op.itob(asa.id)
    bz _set_metadata_payload_bool_false@18
    intc_0 // 1

_set_metadata_payload_bool_merge@19:
    // smart_contracts/asa_metadata_registry/contract.py:216
    // if self._is_extra_payload_call(asa, txn):
    bz _set_metadata_payload_after_if_else@4
    // smart_contracts/asa_metadata_registry/contract.py:196-199
    // # This subroutine assumes txn is already validated as an extra payload txn
    // return arc4.DynamicBytes.from_bytes(
    //     txn.app_args(const.ARC89_EXTRA_PAYLOAD_ARG_PAYLOAD)
    // ).native
    frame_dig 2
    // smart_contracts/asa_metadata_registry/contract.py:198
    // txn.app_args(const.ARC89_EXTRA_PAYLOAD_ARG_PAYLOAD)
    intc_3 // 2
    gtxnsas ApplicationArgs
    // smart_contracts/asa_metadata_registry/contract.py:196-199
    // # This subroutine assumes txn is already validated as an extra payload txn
    // return arc4.DynamicBytes.from_bytes(
    //     txn.app_args(const.ARC89_EXTRA_PAYLOAD_ARG_PAYLOAD)
    // ).native
    extract 2 0
    // smart_contracts/asa_metadata_registry/contract.py:219
    // self._get_metadata_size(asa) + extra_payload.length <= metadata_size
    frame_dig -3
    callsub _get_metadata_size
    dig 1
    len
    +
    frame_dig -2
    <=
    // smart_contracts/asa_metadata_registry/contract.py:218-220
    // assert (
    //     self._get_metadata_size(asa) + extra_payload.length <= metadata_size
    // ), err.PAYLOAD_OVERFLOW
    assert // Payload overflow, exceeds metadata size
    // smart_contracts/asa_metadata_registry/contract.py:221
    // self._append_payload(asa, extra_payload)
    frame_dig -3
    swap
    callsub _append_payload
    // smart_contracts/asa_metadata_registry/contract.py:223
    // self._get_metadata_size(asa) <= metadata_size
    frame_dig -3
    callsub _get_metadata_size
    frame_dig -2
    <=
    // smart_contracts/asa_metadata_registry/contract.py:222-224
    // assert (
    //     self._get_metadata_size(asa) <= metadata_size
    // ), err.PAYLOAD_OVERFLOW
    assert // Payload overflow, exceeds metadata size

_set_metadata_payload_after_if_else@4:
    // smart_contracts/asa_metadata_registry/contract.py:214
    // for idx in urange(group_index + 1, group_size):
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b _set_metadata_payload_for_header@1

_set_metadata_payload_bool_false@18:
    intc_1 // 0
    b _set_metadata_payload_bool_merge@19

_set_metadata_payload_bool_false@13:
    intc_1 // 0
    b _set_metadata_payload_bool_merge@14

_set_metadata_payload_after_for@6:
    // smart_contracts/asa_metadata_registry/contract.py:225
    // assert self._get_metadata_size(asa) == metadata_size, err.METADATA_SIZE_MISMATCH
    frame_dig -3
    callsub _get_metadata_size
    frame_dig -2
    ==
    assert // Metadata size mismatch, must be exactly equal to declared size
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._get_metadata_page(asa: uint64, page_index: uint64) -> bytes:
_get_metadata_page:
    // smart_contracts/asa_metadata_registry/contract.py:235
    // def _get_metadata_page(self, asa: Asset, page_index: UInt64) -> Bytes:
    proto 2 1
    // smart_contracts/asa_metadata_registry/contract.py:243
    // n = self._get_metadata_size(asa)
    frame_dig -2
    callsub _get_metadata_size
    dup
    // smart_contracts/asa_metadata_registry/contract.py:245
    // start = page_index * ps
    frame_dig -1
    // smart_contracts/asa_metadata_registry/contract.py:242
    // ps = UInt64(const.PAGE_SIZE)
    intc 4 // 1007
    // smart_contracts/asa_metadata_registry/contract.py:245
    // start = page_index * ps
    *
    dup
    uncover 2
    // smart_contracts/asa_metadata_registry/contract.py:246
    // if start >= n:
    >=
    bz _get_metadata_page_after_if_else@2
    // smart_contracts/asa_metadata_registry/contract.py:247-248
    // # Out-of-range page (including empty metadata with page_index > 0)
    // return Bytes(b"")
    bytec_1 // 0x
    frame_bury 0
    retsub

_get_metadata_page_after_if_else@2:
    // smart_contracts/asa_metadata_registry/contract.py:250
    // remaining = n - start
    frame_dig 0
    frame_dig 1
    dup
    cover 2
    -
    // smart_contracts/asa_metadata_registry/contract.py:242
    // ps = UInt64(const.PAGE_SIZE)
    intc 4 // 1007
    // smart_contracts/avm_common.py:26
    // return a if a < b else b
    dig 1
    <
    // smart_contracts/asa_metadata_registry/contract.py:242
    // ps = UInt64(const.PAGE_SIZE)
    intc 4 // 1007
    // smart_contracts/avm_common.py:26
    // return a if a < b else b
    swap
    select
    // smart_contracts/asa_metadata_registry/contract.py:253
    // return self.asset_metadata.box(asa).extract(
    frame_dig -2
    itob
    // smart_contracts/asa_metadata_registry/contract.py:254
    // start_index=const.IDX_METADATA + start, length=length
    pushint 51
    uncover 3
    +
    // smart_contracts/asa_metadata_registry/contract.py:253-255
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA + start, length=length
    // )
    uncover 2
    box_extract
    frame_bury 0
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._get_short_metadata(asa: uint64) -> bytes:
_get_short_metadata:
    // smart_contracts/asa_metadata_registry/contract.py:262
    // def _get_short_metadata(self, asa: Asset) -> Bytes:
    proto 1 1
    // smart_contracts/asa_metadata_registry/contract.py:56
    // return self.asset_metadata.box(asa).extract(
    frame_dig -1
    itob
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:57
    // start_index=const.IDX_METADATA_IDENTIFIERS,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:58
    // length=const.METADATA_IDENTIFIERS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:69
    // const.BIT_RIGHTMOST_IDENTIFIER - flg.ID_SHORT,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:67-70
    // return op.getbit(
    //     self._get_metadata_identifiers(asa),
    //     const.BIT_RIGHTMOST_IDENTIFIER - flg.ID_SHORT,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:263
    // assert self._is_short(asa), err.METADATA_NOT_SHORT
    assert // Metadata is not short
    // smart_contracts/asa_metadata_registry/contract.py:264
    // return self._get_slice(asa, UInt64(0), self._get_metadata_size(asa))
    frame_dig -1
    callsub _get_metadata_size
    // smart_contracts/asa_metadata_registry/contract.py:259
    // start_index=const.IDX_METADATA + offset, length=size
    pushint 51
    // smart_contracts/asa_metadata_registry/contract.py:258-260
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA + offset, length=size
    // )
    swap
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:264
    // return self._get_slice(asa, UInt64(0), self._get_metadata_size(asa))
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._identify_metadata(asa: uint64) -> void:
_identify_metadata:
    // smart_contracts/asa_metadata_registry/contract.py:266
    // def _identify_metadata(self, asa: Asset) -> None:
    proto 1 0
    // smart_contracts/asa_metadata_registry/contract.py:267
    // metadata_size = self._get_metadata_size(asa)
    frame_dig -1
    callsub _get_metadata_size
    // smart_contracts/asa_metadata_registry/contract.py:56
    // return self.asset_metadata.box(asa).extract(
    frame_dig -1
    itob
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:57
    // start_index=const.IDX_METADATA_IDENTIFIERS,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:58
    // length=const.METADATA_IDENTIFIERS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:53
    // return metadata_size <= const.SHORT_METADATA_SIZE
    uncover 2
    pushint 4096
    <=
    // smart_contracts/asa_metadata_registry/contract.py:270
    // const.BIT_RIGHTMOST_IDENTIFIER - flg.ID_SHORT,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:268-272
    // identifiers = op.setbit_bytes(
    //     self._get_metadata_identifiers(asa),
    //     const.BIT_RIGHTMOST_IDENTIFIER - flg.ID_SHORT,
    //     self._is_short_metadata_size(metadata_size),
    // )
    swap
    setbit
    // smart_contracts/asa_metadata_registry/contract.py:63
    // start_index=const.IDX_METADATA_IDENTIFIERS, value=identifiers
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:62-64
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_METADATA_IDENTIFIERS, value=identifiers
    // )
    swap
    box_replace
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._compute_header_hash(asa: uint64) -> bytes:
_compute_header_hash:
    // smart_contracts/asa_metadata_registry/contract.py:275
    // def _compute_header_hash(self, asa: Asset) -> Bytes:
    proto 1 1
    // smart_contracts/asa_metadata_registry/contract.py:276-278
    // # hh = SHA-512/256("arc0089/header" || Asset ID || Metadata Identifiers
    // # || Reversible Flags || Irreversible Flags || Metadata Size)
    // ensure_budget(required_budget=const.HEADER_HASH_OP_BUDGET)
    pushint 110
    intc_1 // 0
    callsub ensure_budget
    // smart_contracts/asa_metadata_registry/contract.py:280
    // asset_id = op.itob(asa.id)
    frame_dig -1
    itob
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:57
    // start_index=const.IDX_METADATA_IDENTIFIERS,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:58
    // length=const.METADATA_IDENTIFIERS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    dig 1
    // smart_contracts/asa_metadata_registry/contract.py:74
    // start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    intc_0 // 1
    dup
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    dig 2
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:285
    // uint=self._get_metadata_size(asa),
    frame_dig -1
    callsub _get_metadata_size
    // smart_contracts/avm_common.py:21
    // return op.extract(op.itob(uint), start, size)
    itob
    extract 6 2
    // smart_contracts/asa_metadata_registry/contract.py:279
    // domain = Bytes(const.HASH_DOMAIN_HEADER)
    pushbytes 0x617263303038392f686561646572
    // smart_contracts/asa_metadata_registry/contract.py:289-290
    // domain
    // + asset_id
    uncover 5
    concat
    // smart_contracts/asa_metadata_registry/contract.py:289-291
    // domain
    // + asset_id
    // + metadata_identifiers
    uncover 4
    concat
    // smart_contracts/asa_metadata_registry/contract.py:289-292
    // domain
    // + asset_id
    // + metadata_identifiers
    // + reversible_flags
    uncover 3
    concat
    // smart_contracts/asa_metadata_registry/contract.py:289-293
    // domain
    // + asset_id
    // + metadata_identifiers
    // + reversible_flags
    // + irreversible_flags
    uncover 2
    concat
    // smart_contracts/asa_metadata_registry/contract.py:289-294
    // domain
    // + asset_id
    // + metadata_identifiers
    // + reversible_flags
    // + irreversible_flags
    // + metadata_size
    swap
    concat
    // smart_contracts/asa_metadata_registry/contract.py:288-295
    // return op.sha512_256(
    //     domain
    //     + asset_id
    //     + metadata_identifiers
    //     + reversible_flags
    //     + irreversible_flags
    //     + metadata_size
    // )
    sha512_256
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._compute_page_hash(asa: uint64, page_index: uint64, page_content: bytes) -> bytes:
_compute_page_hash:
    // smart_contracts/asa_metadata_registry/contract.py:297-299
    // def _compute_page_hash(
    //     self, asa: Asset, page_index: UInt64, page_content: Bytes
    // ) -> Bytes:
    proto 3 1
    // smart_contracts/asa_metadata_registry/contract.py:300-301
    // # ph[i] = SHA-512/256("arc0089/page" || Asset ID || Page Index || Page Size || Page Content)
    // ensure_budget(required_budget=const.PAGE_HASH_OP_BUDGET)
    pushint 150
    intc_1 // 0
    callsub ensure_budget
    // smart_contracts/asa_metadata_registry/contract.py:303
    // asset_id = op.itob(asa.id)
    frame_dig -3
    itob
    // smart_contracts/avm_common.py:21
    // return op.extract(op.itob(uint), start, size)
    frame_dig -2
    itob
    extract 7 1
    // smart_contracts/asa_metadata_registry/contract.py:306
    // uint=page_content.length, size=UInt64(const.UINT16_SIZE)
    frame_dig -1
    len
    // smart_contracts/avm_common.py:21
    // return op.extract(op.itob(uint), start, size)
    itob
    extract 6 2
    // smart_contracts/asa_metadata_registry/contract.py:302
    // domain = Bytes(const.HASH_DOMAIN_PAGE)
    pushbytes 0x617263303038392f70616765
    // smart_contracts/asa_metadata_registry/contract.py:308
    // return op.sha512_256(domain + asset_id + page_idx + page_size + page_content)
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig -1
    concat
    sha512_256
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._compute_metadata_hash(asa: uint64) -> bytes:
_compute_metadata_hash:
    // smart_contracts/asa_metadata_registry/contract.py:310
    // def _compute_metadata_hash(self, asa: Asset) -> Bytes:
    proto 1 1
    bytec_1 // ""
    // smart_contracts/asa_metadata_registry/contract.py:314
    // hh = self._compute_header_hash(asa)
    frame_dig -1
    callsub _compute_header_hash
    // smart_contracts/asa_metadata_registry/contract.py:232
    // n = self._get_metadata_size(asa)
    frame_dig -1
    callsub _get_metadata_size
    // smart_contracts/avm_common.py:31
    // return (num + (den - 1)) // den
    intc 5 // 1006
    +
    // smart_contracts/asa_metadata_registry/contract.py:233
    // return ceil_div(num=n, den=UInt64(const.PAGE_SIZE))
    intc 4 // 1007
    // smart_contracts/avm_common.py:31
    // return (num + (den - 1)) // den
    /
    dup
    // smart_contracts/asa_metadata_registry/contract.py:316
    // concatenated_ph = Bytes()
    bytec_1 // 0x
    swap
    // smart_contracts/asa_metadata_registry/contract.py:317
    // if total_pages > 0:
    bz _compute_metadata_hash_after_if_else@6
    // smart_contracts/asa_metadata_registry/contract.py:318
    // for page_index in urange(0, total_pages):
    intc_1 // 0
    frame_bury 0

_compute_metadata_hash_for_header@2:
    // smart_contracts/asa_metadata_registry/contract.py:318
    // for page_index in urange(0, total_pages):
    frame_dig 0
    frame_dig 2
    <
    bz _compute_metadata_hash_after_if_else@6
    // smart_contracts/asa_metadata_registry/contract.py:319
    // page_content = self._get_metadata_page(asa, page_index)
    frame_dig -1
    frame_dig 0
    dup
    cover 2
    callsub _get_metadata_page
    // smart_contracts/asa_metadata_registry/contract.py:320
    // ph = self._compute_page_hash(asa, page_index, page_content)
    frame_dig -1
    dig 2
    uncover 2
    callsub _compute_page_hash
    // smart_contracts/asa_metadata_registry/contract.py:321
    // concatenated_ph += ph
    frame_dig 3
    swap
    concat
    frame_bury 3
    // smart_contracts/asa_metadata_registry/contract.py:318
    // for page_index in urange(0, total_pages):
    intc_0 // 1
    +
    frame_bury 0
    b _compute_metadata_hash_for_header@2

_compute_metadata_hash_after_if_else@6:
    // smart_contracts/asa_metadata_registry/contract.py:311-313
    // # am = SHA-512/256("arc0089/am" || hh || ph[0] || ph[1] || ... || ph[total_pages - 1]) or
    // # am = SHA-512/256("arc0089/am" || hh), if no pages
    // domain = Bytes(const.HASH_DOMAIN_METADATA)
    pushbytes 0x617263303038392f616d
    // smart_contracts/asa_metadata_registry/contract.py:322
    // return op.sha512_256(domain + hh + concatenated_ph)
    frame_dig 1
    concat
    frame_dig 3
    concat
    sha512_256
    frame_bury 0
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._check_base_preconditions(asa: uint64, metadata_size: uint64) -> void:
_check_base_preconditions:
    // smart_contracts/asa_metadata_registry/contract.py:324
    // def _check_base_preconditions(self, asa: Asset, metadata_size: UInt64) -> None:
    proto 2 0
    // smart_contracts/asa_validation.py:15
    // _creator, exists = op.AssetParamsGet.asset_creator(asa)
    frame_dig -2
    asset_params_get AssetCreator
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:325
    // assert self._asa_exists(asa), err.ASA_NOT_EXIST
    assert // The specified ASA does not exist
    // smart_contracts/asa_metadata_registry/contract.py:326
    // assert self._is_asa_manager(asa), err.UNAUTHORIZED
    frame_dig -2
    callsub _is_asa_manager
    assert // Unauthorized, must be the Asset Manager
    // smart_contracts/asa_metadata_registry/contract.py:50
    // return metadata_size <= const.MAX_METADATA_SIZE
    frame_dig -1
    intc 6 // 30506
    <=
    // smart_contracts/asa_metadata_registry/contract.py:327-329
    // assert self._is_valid_max_metadata_size(
    //     metadata_size
    // ), err.EXCEEDS_MAX_METADATA_SIZE
    assert // Invalid Metadata size, exceeds maximum allowed size
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._check_update_preconditions(asa: uint64, metadata_size: uint64) -> void:
_check_update_preconditions:
    // smart_contracts/asa_metadata_registry/contract.py:331
    // def _check_update_preconditions(self, asa: Asset, metadata_size: UInt64) -> None:
    proto 2 0
    // smart_contracts/asa_metadata_registry/contract.py:332
    // self._check_base_preconditions(asa, metadata_size)
    frame_dig -2
    frame_dig -1
    callsub _check_base_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:47
    // return asa in self.asset_metadata
    frame_dig -2
    itob
    dup
    box_len
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:333
    // assert self._metadata_exists(asa), err.ASSET_METADATA_NOT_EXIST
    assert // Asset Metadata does not exist for the specified ASA
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:110
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:108-111
    // return op.getbit(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:334
    // assert not self._is_immutable(asa), err.IMMUTABLE
    !
    assert // Metadata is immutable
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._check_existence_preconditions(asa: uint64) -> void:
_check_existence_preconditions:
    // smart_contracts/asa_metadata_registry/contract.py:336
    // def _check_existence_preconditions(self, asa: Asset) -> None:
    proto 1 0
    // smart_contracts/asa_validation.py:15
    // _creator, exists = op.AssetParamsGet.asset_creator(asa)
    frame_dig -1
    asset_params_get AssetCreator
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:337
    // assert self._asa_exists(asa), err.ASA_NOT_EXIST
    assert // The specified ASA does not exist
    // smart_contracts/asa_metadata_registry/contract.py:47
    // return asa in self.asset_metadata
    frame_dig -1
    itob
    box_len
    bury 1
    // smart_contracts/asa_metadata_registry/contract.py:338
    // assert self._metadata_exists(asa), err.ASSET_METADATA_NOT_EXIST
    assert // Asset Metadata does not exist for the specified ASA
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._check_set_flag_preconditions(asa: uint64) -> void:
_check_set_flag_preconditions:
    // smart_contracts/asa_metadata_registry/contract.py:340
    // def _check_set_flag_preconditions(self, asa: Asset) -> None:
    proto 1 0
    // smart_contracts/asa_metadata_registry/contract.py:341
    // self._check_existence_preconditions(asa)
    frame_dig -1
    callsub _check_existence_preconditions
    // smart_contracts/asa_metadata_registry/contract.py:342
    // assert self._is_asa_manager(asa), err.UNAUTHORIZED
    frame_dig -1
    callsub _is_asa_manager
    assert // Unauthorized, must be the Asset Manager
    // smart_contracts/asa_metadata_registry/contract.py:97
    // return self.asset_metadata.box(asa).extract(
    frame_dig -1
    itob
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:110
    // const.BIT_RIGHTMOST_IRR_FLAG - flag,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:108-111
    // return op.getbit(
    //     self._get_irreversible_flags(asa),
    //     const.BIT_RIGHTMOST_IRR_FLAG - flag,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:343
    // assert not self._is_immutable(asa), err.IMMUTABLE
    !
    assert // Metadata is immutable
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._emit_updated_event(asa: uint64, metadata_hash: bytes) -> void:
_emit_updated_event:
    // smart_contracts/asa_metadata_registry/contract.py:345
    // def _emit_updated_event(self, asa: Asset, metadata_hash: Bytes) -> None:
    proto 2 0
    // smart_contracts/asa_metadata_registry/contract.py:349
    // round=Global.round,
    global Round
    // smart_contracts/asa_metadata_registry/contract.py:350
    // timestamp=Global.latest_timestamp,
    global LatestTimestamp
    // smart_contracts/asa_metadata_registry/contract.py:73
    // return self.asset_metadata.box(asa).extract(
    frame_dig -2
    itob
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:74
    // start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    intc_0 // 1
    dup
    // smart_contracts/asa_metadata_registry/contract.py:73-75
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_REVERSIBLE_FLAGS, length=const.REVERSIBLE_FLAGS_SIZE
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:351
    // reversible_flags=arc4.Byte(op.btoi(self._get_reversible_flags(asa))),
    btoi
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    dig 1
    // smart_contracts/asa_metadata_registry/contract.py:98
    // start_index=const.IDX_IRREVERSIBLE_FLAGS,
    intc_3 // 2
    // smart_contracts/asa_metadata_registry/contract.py:99
    // length=const.IRREVERSIBLE_FLAGS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:97-100
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_IRREVERSIBLE_FLAGS,
    //     length=const.IRREVERSIBLE_FLAGS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:353
    // op.btoi(self._get_irreversible_flags(asa))
    btoi
    // smart_contracts/asa_metadata_registry/contract.py:352-354
    // irreversible_flags=arc4.Byte(
    //     op.btoi(self._get_irreversible_flags(asa))
    // ),
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    dig 2
    // smart_contracts/asa_metadata_registry/contract.py:57
    // start_index=const.IDX_METADATA_IDENTIFIERS,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:58
    // length=const.METADATA_IDENTIFIERS_SIZE,
    intc_0 // 1
    // smart_contracts/asa_metadata_registry/contract.py:56-59
    // return self.asset_metadata.box(asa).extract(
    //     start_index=const.IDX_METADATA_IDENTIFIERS,
    //     length=const.METADATA_IDENTIFIERS_SIZE,
    // )
    box_extract
    // smart_contracts/asa_metadata_registry/contract.py:69
    // const.BIT_RIGHTMOST_IDENTIFIER - flg.ID_SHORT,
    intc_1 // 0
    // smart_contracts/asa_metadata_registry/contract.py:67-70
    // return op.getbit(
    //     self._get_metadata_identifiers(asa),
    //     const.BIT_RIGHTMOST_IDENTIFIER - flg.ID_SHORT,
    // )
    getbit
    // smart_contracts/asa_metadata_registry/contract.py:347-357
    // abi.Arc89MetadataUpdated(
    //     asset_id=asa.id,
    //     round=Global.round,
    //     timestamp=Global.latest_timestamp,
    //     reversible_flags=arc4.Byte(op.btoi(self._get_reversible_flags(asa))),
    //     irreversible_flags=arc4.Byte(
    //         op.btoi(self._get_irreversible_flags(asa))
    //     ),
    //     is_short=self._is_short(asa),
    //     hash=abi.Hash.from_bytes(metadata_hash),  # No length validation
    // )
    uncover 5
    itob
    uncover 4
    swap
    concat
    uncover 4
    itob
    concat
    uncover 3
    concat
    uncover 2
    concat
    bytec_2 // 0x00
    intc_1 // 0
    uncover 3
    setbit
    concat
    frame_dig -1
    concat
    // smart_contracts/asa_metadata_registry/contract.py:346-358
    // arc4.emit(
    //     abi.Arc89MetadataUpdated(
    //         asset_id=asa.id,
    //         round=Global.round,
    //         timestamp=Global.latest_timestamp,
    //         reversible_flags=arc4.Byte(op.btoi(self._get_reversible_flags(asa))),
    //         irreversible_flags=arc4.Byte(
    //             op.btoi(self._get_irreversible_flags(asa))
    //         ),
    //         is_short=self._is_short(asa),
    //         hash=abi.Hash.from_bytes(metadata_hash),  # No length validation
    //     )
    // )
    pushbytes 0x8b035084 // method "Arc89MetadataUpdated(uint64,uint64,uint64,byte,byte,bool,byte[32])"
    swap
    concat
    log
    retsub


// smart_contracts.asa_metadata_registry.contract.AsaMetadataRegistry._update_header_excluding_flags_and_emit(asa: uint64) -> void:
_update_header_excluding_flags_and_emit:
    // smart_contracts/asa_metadata_registry/contract.py:360
    // def _update_header_excluding_flags_and_emit(self, asa: Asset) -> None:
    proto 1 0
    // smart_contracts/asa_metadata_registry/contract.py:361-362
    // #  The subroutine assumes that Metadata Flags have already been set
    // self._identify_metadata(asa)
    frame_dig -1
    callsub _identify_metadata
    // smart_contracts/asa_metadata_registry/contract.py:363
    // metadata_hash = self._compute_metadata_hash(asa)
    frame_dig -1
    callsub _compute_metadata_hash
    // smart_contracts/asa_metadata_registry/contract.py:127
    // self.asset_metadata.box(asa).replace(
    frame_dig -1
    itob
    // smart_contracts/asa_metadata_registry/contract.py:127-129
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_METADATA_HASH, value=metadata_hash
    // )
    dup
    // smart_contracts/asa_metadata_registry/contract.py:128
    // start_index=const.IDX_METADATA_HASH, value=metadata_hash
    pushint 3
    // smart_contracts/asa_metadata_registry/contract.py:127-129
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_METADATA_HASH, value=metadata_hash
    // )
    dig 3
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:365
    // self._set_last_modified_round(asa, Global.round)
    global Round
    // smart_contracts/asa_metadata_registry/contract.py:142
    // value=op.itob(last_modified_round),
    itob
    // smart_contracts/asa_metadata_registry/contract.py:141
    // start_index=const.IDX_LAST_MODIFIED_ROUND,
    pushint 35
    // smart_contracts/asa_metadata_registry/contract.py:140-143
    // self.asset_metadata.box(asa).replace(
    //     start_index=const.IDX_LAST_MODIFIED_ROUND,
    //     value=op.itob(last_modified_round),
    // )
    swap
    box_replace
    // smart_contracts/asa_metadata_registry/contract.py:366
    // self._emit_updated_event(asa, metadata_hash)
    frame_dig -1
    swap
    callsub _emit_updated_event
    retsub


// smart_contracts.asa_validation.AsaValidation._is_asa_manager(asa: uint64) -> uint64:
_is_asa_manager:
    // smart_contracts/asa_validation.py:18
    // def _is_asa_manager(self, asa: Asset) -> bool:
    proto 1 1
    // smart_contracts/asa_validation.py:19
    // return Txn.sender == asa.manager
    txn Sender
    frame_dig -1
    asset_params_get AssetManager
    assert // asset exists
    ==
    retsub
