# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to create the Asset Metadata for", "name": "asset_id"}, {"type": "byte", "desc": "The Reversible Flags. WARNING: LSB and 1 can by set only at creation time", "name": "reversible_flags"}, {"type": "byte", "desc": "The Irreversible Flags. WARNING: if the MSB is True the Asset Metadata is IMMUTABLE", "name": "irreversible_flags"}, {"type": "uint16", "desc": "The Metadata byte size to be created", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}, {"type": "pay", "desc": "Payment of the MBR Delta amount (microALGO) for the Asset Metadata Box creation", "name": "mbr_delta_payment"}], "name": "arc89_create_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Create Asset Metadata for an existing ASA, restricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Metadata byte size, must be less than or equal to the existing", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}], "name": "arc89_replace_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Replace mutable Metadata with a smaller or equal size payload for an existing ASA,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Metadata byte size, must be larger than the existing", "name": "metadata_size"}, {"type": "byte[]", "desc": "The Metadata payload (without Header). WARNING: Payload larger than args capacity must be provided with arc89_extra_payload calls in the Group", "name": "payload"}, {"type": "pay", "desc": "Payment of the MBR Delta amount (microALGO) for the larger Asset Metadata Box replace", "name": "mbr_delta_payment"}], "name": "arc89_replace_metadata_larger", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Replace mutable Metadata with a larger size payload for an existing ASA,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to replace the Asset Metadata slice for", "name": "asset_id"}, {"type": "uint16", "desc": "The 0-based byte offset within the Metadata (body) bytes", "name": "offset"}, {"type": "byte[]", "desc": "The slice payload", "name": "payload"}], "name": "arc89_replace_metadata_slice", "returns": {"type": "void"}, "desc": "Replace a slice of the Asset Metadata for an ASA with a payload of the same size,\nrestricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to migrate the Asset Metadata for", "name": "asset_id"}, {"type": "uint64", "desc": "The Application ID of the new ASA Metadata Registry version", "name": "new_registry_id"}], "name": "arc89_migrate_metadata", "returns": {"type": "void"}, "desc": "Migrate the Asset Metadata for an ASA to a new ASA Metadata Registry version,\nrestricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "new_registry_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataMigrated", "desc": "Event emitted when Asset Metadata has been migrated to a new ASA Metadata Registry version"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to delete the Asset Metadata for", "name": "asset_id"}], "name": "arc89_delete_metadata", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Delete Asset Metadata for an ASA, restricted to the ASA Manager Address (if the ASA still exists).", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataDeleted", "desc": "Event emitted when Asset Metadata is deleted"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to provide Metadata extra payload for", "name": "asset_id"}, {"type": "byte[]", "desc": "The Metadata extra payload to concatenate", "name": "payload"}], "name": "arc89_extra_payload", "returns": {"type": "void"}, "desc": "Concatenate extra payload to Asset Metadata head call methods (creation or replacement).", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set the Metadata Flag for", "name": "asset_id"}, {"type": "uint8", "desc": "The reversible flag index to set", "name": "flag"}, {"type": "bool", "desc": "The flag value to set", "name": "value"}], "name": "arc89_set_reversible_flag", "returns": {"type": "void"}, "desc": "Set a reversible Asset Metadata Flag, restricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set the Metadata Flag for", "name": "asset_id"}, {"type": "uint8", "desc": "The irreversible flag index to set. WARNING: must be in 2 ... 6", "name": "flag"}], "name": "arc89_set_irreversible_flag", "returns": {"type": "void"}, "desc": "Set an irreversible Asset Metadata Flag, restricted to the ASA Manager Address", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to set immutable Asset Metadata for", "name": "asset_id"}], "name": "arc89_set_immutable", "returns": {"type": "void"}, "desc": "Set Asset Metadata as immutable, restricted to the ASA Manager Address.", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "arc89_get_metadata_registry_parameters", "returns": {"type": "(uint8,uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", "desc": "Tuple of (ASSET_METADATA_BOX_KEY_SIZE, HEADER_SIZE, MAX_METADATA_SIZE, SHORT_METADATA_SIZE, PAGE_SIZE, FIRST_PAYLOAD_MAX_SIZE, EXTRA_PAYLOAD_MAX_SIZE, REPLACE_PAYLOAD_MAX_SIZE, FLAT_MBR, BYTE_MBR)", "struct": "RegistryParameters"}, "desc": "Return the ASA Metadata Registry parameters.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "arc89_get_metadata_partial_uri", "returns": {"type": "string", "desc": "Asset Metadata ARC-90 partial URI, without compliance fragment"}, "desc": "Return the Asset Metadata ARC-90 partial URI, without compliance fragment (optional)", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to calculate the Asset Metadata MBR Delta for", "name": "asset_id"}, {"type": "uint16", "desc": "The new Asset Metadata byte size", "name": "new_metadata_size"}], "name": "arc89_get_metadata_mbr_delta", "returns": {"type": "(uint8,uint64)", "desc": "MBR Delta: tuple of (sign enum, amount in microALGO)", "struct": "MbrDelta"}, "desc": "Return the Asset Metadata Box MBR Delta for an ASA, given a new Asset Metadata byte size.\nIf the Asset Metadata Box does not exist, the creation MBR Delta is returned.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the ASA and Asset Metadata existence for", "name": "asset_id"}], "name": "arc89_check_metadata_exists", "returns": {"type": "(bool,bool)", "desc": "Tuple of (ASA exists, Asset Metadata exists)", "struct": "MetadataExistence"}, "desc": "Checks whether the specified ASA exists and whether its associated Asset Metadata is available.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the Asset Metadata immutability for", "name": "asset_id"}], "name": "arc89_is_metadata_immutable", "returns": {"type": "bool", "desc": "Asset Metadata for the ASA is immutable"}, "desc": "Return True if the Asset Metadata for an ASA is immutable, False otherwise.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to check the Asset Metadata size classification for", "name": "asset_id"}], "name": "arc89_is_metadata_short", "returns": {"type": "(bool,uint64)", "desc": "Tuple of (is short metadata, Metadata Last Modified Round)", "struct": "MutableFlag"}, "desc": "Return True if Asset Metadata for an ASA is short (up to 4096 bytes), False otherwise.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata Header for", "name": "asset_id"}], "name": "arc89_get_metadata_header", "returns": {"type": "(byte,byte,byte,byte[32],uint64,uint64)", "desc": "Asset Metadata Header: (Identifiers, Reversible Flags, Irreversible Flags, Hash, Last Modified Round, Deprecated By)", "struct": "MetadataHeader"}, "desc": "Return the Asset Metadata Header for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata pagination for", "name": "asset_id"}], "name": "arc89_get_metadata_pagination", "returns": {"type": "(uint16,uint16,uint8)", "desc": "Tuple of (total metadata byte size, PAGE_SIZE, total number of pages)", "struct": "Pagination"}, "desc": "Return the Asset Metadata pagination for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata for", "name": "asset_id"}, {"type": "uint8", "desc": "The 0-based Metadata page number", "name": "page"}], "name": "arc89_get_metadata", "returns": {"type": "(bool,uint64,byte[])", "desc": "Tuple of (has next page, Metadata Last Modified Round, page content)", "struct": "PaginatedMetadata"}, "desc": "Return paginated Asset Metadata (without Header) for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata slice for", "name": "asset_id"}, {"type": "uint16", "desc": "The 0-based byte offset within the Metadata (body) bytes", "name": "offset"}, {"type": "uint16", "desc": "The slice bytes size to return", "name": "size"}], "name": "arc89_get_metadata_slice", "returns": {"type": "byte[]", "desc": "Asset Metadata slice (size limited to PAGE_SIZE)"}, "desc": "Return a slice of the Asset Metadata for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Metadata Header Hash for", "name": "asset_id"}], "name": "arc89_get_metadata_header_hash", "returns": {"type": "byte[32]", "desc": "Asset Metadata Header Hash"}, "desc": "Return the Metadata Header Hash for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Asset Metadata page hash for", "name": "asset_id"}, {"type": "uint8", "desc": "The 0-based Metadata page number", "name": "page"}], "name": "arc89_get_metadata_page_hash", "returns": {"type": "byte[32]", "desc": "The SHA512-256 of the Metadata page"}, "desc": "Return the SHA512-256 of a Metadata page for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the Metadata Hash for", "name": "asset_id"}], "name": "arc89_get_metadata_hash", "returns": {"type": "byte[32]", "desc": "Asset Metadata Hash"}, "desc": "Return the Metadata Hash for an ASA.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose string value to fetch", "name": "key"}], "name": "arc89_get_metadata_string_by_key", "returns": {"type": "string", "desc": "The string value from valid UTF-8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the UTF-8 string value for a top-level JSON key of type JSON String\nfrom short Metadata for an ASA; errors if the key does not exist or is not a JSON String", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose uint64 value to fetch", "name": "key"}], "name": "arc89_get_metadata_uint64_by_key", "returns": {"type": "uint64", "desc": "The uint64 value from valid UTF-8 JSON Metadata"}, "desc": "Return the uint64 value for a top-level JSON key of type JSON Uint64 from\nshort Metadata for an ASA; errors if the key does not exist or is not a JSON Uint64", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top level JSON key whose object value to fetch", "name": "key"}], "name": "arc89_get_metadata_object_by_key", "returns": {"type": "string", "desc": "The object value from valid UTF-8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the UTF-8 object value for a top-level JSON key of type JSON Object\nfrom short Metadata for an ASA; errors if the key does not exist or is not a JSON Object", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The Asset ID to get the key value for", "name": "asset_id"}, {"type": "string", "desc": "The top-level JSON key whose base64 string value to fetch and decode", "name": "key"}, {"type": "uint8", "desc": "base64 encoding enum: 0 = URLEncoding, 1 = StdEncoding", "name": "b64_encoding"}], "name": "arc89_get_metadata_b64_bytes_by_key", "returns": {"type": "byte[]", "desc": "The base64-decoded bytes from valid UTF-8 JSON Metadata (size limited to PAGE_SIZE)"}, "desc": "Return the base64-decoded bytes for a top-level JSON key of type JSON String\nfrom short Metadata for an ASA; errors if the key does not exist, is not a JSON String, or is not valid base64 for the chosen encoding", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "extra_resources", "returns": {"type": "void"}, "desc": "Non-normative placeholder method to acquire AVM extra resources.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "withdraw_balance_excess", "returns": {"type": "void"}, "desc": "Non-normative method to withdraw balance excess due to accidental deposits\n(it should never happen if deposits match exactly the required MBR. Deleted metadata MBR is not included in the excess, since it is immediately returned on delete).", "events": [], "readonly": false, "recommendations": {}}], "name": "AsaMetadataRegistry", "state": {"keys": {"box": {}, "global": {}, "local": {}}, "maps": {"box": {"asset_metadata": {"keyType": "uint64", "valueType": "AVMBytes", "prefix": ""}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 0}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"MbrDelta": [{"name": "sign", "type": "uint8"}, {"name": "amount", "type": "uint64"}], "MetadataExistence": [{"name": "asa_exists", "type": "bool"}, {"name": "metadata_exists", "type": "bool"}], "MetadataHeader": [{"name": "identifiers", "type": "byte"}, {"name": "reversible_flags", "type": "byte"}, {"name": "irreversible_flags", "type": "byte"}, {"name": "hash", "type": "byte[32]"}, {"name": "last_modified_round", "type": "uint64"}, {"name": "deprecated_by", "type": "uint64"}], "MutableFlag": [{"name": "flag", "type": "bool"}, {"name": "last_modified_round", "type": "uint64"}], "PaginatedMetadata": [{"name": "has_next_page", "type": "bool"}, {"name": "last_modified_round", "type": "uint64"}, {"name": "page_content", "type": "byte[]"}], "Pagination": [{"name": "metadata_size", "type": "uint16"}, {"name": "page_size", "type": "uint16"}, {"name": "total_pages", "type": "uint8"}], "RegistryParameters": [{"name": "key_size", "type": "uint8"}, {"name": "header_size", "type": "uint16"}, {"name": "max_metadata_size", "type": "uint16"}, {"name": "short_metadata_size", "type": "uint16"}, {"name": "page_size", "type": "uint16"}, {"name": "first_payload_max_size", "type": "uint16"}, {"name": "extra_payload_max_size", "type": "uint16"}, {"name": "replace_payload_max_size", "type": "uint16"}, {"name": "flat_mbr", "type": "uint64"}, {"name": "byte_mbr", "type": "uint64"}]}, "byteCode": {"approval": "DCAHAQAIAu8H7geq7gEmCAQVH3x1AAEABDesdV0DBoEBBRUffHUBAAAxG0EBAjEZFEQxGESCBgR4QHgxBLgup+8EEkX6+wQEXy5uBN3/y5IEFbJ1siuCFgS1Eh2KBEn7rpEEC1OM4wQBXlebBAifrqEEjl4QJAQkTEfEBC1Z9uAE7oW0cwS3WTG8BI8l73IEEcOEdgSwq/ZbBM6dvtcEylL7HgQiY5G5BHoT1TIEU8IiAwTTdyrTBH2ir0AEAFbZwQS5LiZ6NhoAjh0BUANVA9wEVASyBPsFZwWTBekGRAADBlwGcAbuBxAHQQdpB7gH9AhjCK0IyQkGCSUJXQmJCcEAAQoTACJDgCMVH3x1CAAzdyoQAAPvB+4H8gfwAAAAAAAACcQAAAAAAAABkLAiQzEZFDEYFBBEMQAnBhJEIkOKAgCL/oEKCIsAMgwNQQAqsYEGshCBBbIZJwSyHicEsh+L/40CAAsABLNC/9syALIBQv/1I7IBQv/viYoCAYv/FYv+FUoORElPAglJSwIPSwJMTYv+TE8CUov/EomKAgEjSSkyEYAgwGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8SQQCBKYALYWxnb3JhbmQ6Ly9MUIAEYXBwL1CMASmMAIv+jAKLAkEAQIsCSYEKGEmBCg9LAYEKTwJNTCIISYEKD4EKTE1JSwIMSwJMTYAKMDEyMzQ1Njc4OU4CUosAUIwAgQoKjAJC/7uLAEkVgAEwTgJNiwFMUIAFP2JveD1Qi/9QjACJJweAAS9QQv93I0cEKUcCNhoBSRUkEkQXSTYaAklOAhUiEkQ2GgNJTgIVIhJENhoESRUlEkQ2GgVJI1klCEsBFRJEVwIASU4CTgMxFiIJSU4ESTgQIhJETBdJTgRLA0yICppPAhZJTgNJvUUBFERMOAcyChJEMgpzAUxOA0QjuUgVQQAHgbwFI4j+aUsHSUsESweICIpJiAl0SwcXFlcHAUsDSU4CIk8Cu0sHFxZXBwElTLtxBkxJTgJFEUSAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE0lFDEEBH0sBJSK6I1NESw5FDEsBSYEDSw67MgYWSwGBI08CuyMWSwGBK08CuyUiuoEHU0EAHksHSXEETElOA0URRHEFTEUPRIAEYXJjMxJBAJciREsBJSK6gQVTQQAGSweICpdESwElIrqBBlNBADwyCCmI/fxJRRFLCHEFTElOAkUQRBVJRQxMFUlFCwxBADojREsKQQAUSwElIrqBB1NAAAlLB4gJGksPEkRLB0sMiAnGMgpzAURLAQlLBDgISwEPRBYnBUxQsCJDSwhJSwtJTgMORElLAg9MTgJNSw0jTwJSSxASQv+pSw0VgQUPQQATSw2ABUBhcmMziP1SQQAEIkL/TksMFYEFD0EAE0sMgAUjYXJjM4j9NkEABCJC/zIjQv8uSweICJhFDEL+4zYaAUkVJBJEF0k2GgJJFSUSRDYaA0kjWSUISwEVEkRXAgBMF0sCSwGICNpLAogGvksBD0QyCnMBREsDSwJPBIgGz0sCiAlVTwKIBqJPAhJEMgpzAUQJSUAAFCMWSZMkDkRXBwFLARZQKExQsCJDgf8BsUsCcQdESwKyCLIHIrIQI7IBs0L/1DYaAUkVJBJEFzYaAkkVJRJENhoDSSNZJQhLARUSRFcCADEWIglJOBAiEkRPAhdLA0sBiAhJSwOIBi1LAQxESwE4BzIKEkQyCnMBREsESwJPBYgGNksDiAi8TwOIBglPAhJEMgpzAURMCUw4CEsBD0QWJwVMULAiQzYaAUkVJBJEF0k2GgJJFSUSRDYaA0kjWSUISwEVEkRXAgBJTgNLAogFxUsDTIgH1kwXSwEVSghLBIgFsw5ETwMWSU4EgTNPAwhJTgRPAroTQQAJSksEu0sDiAhBIkM2GgFJFSQSRBc2GgJJFSQSRBdLAYgHvUkyCBNETBZMFksBgStPArsyBjIHSwKBKyS6FxZPA0xQTwIWUEwWUIAEyHAjv0xQsCJDNhoBSRUkEkQXRwIWSU4CvUUBRHELRQFBAA5JJSK6I1MUREsBiAfzRDIKcwFESwFJTgK8SDIKcwFECbExAEsBsgiyByKyECOyAbMyBzIGFk8DTFBMFlCABLw/INFMULAWgAUVH3x1/0xQsCJDNhoBSRUkEkQXNhoCSSNZJQhMFRJEMgQlD0RJcQtFAURJFr1FAUSIB4VEIkM2GgFJFSQSRBdJNhoCSRUiEkQ2GgNJFSISRCNTSU4DTgNLAYgGzRdJgQcOREwWSU4DIkm6gQdPAglJTgNTE0EAE0sBSSJJuksCSwVUIky7SwOIBwoiQyM2GgFJFSQSRBdJNhoCSRUiEkRMiAaGF0klD0EAOUmBBg5BADIiREsBFklFBCUiuoEHSwIJU0AAC0sBSUsCiAQEiAbESwIlIrqBBVNBAAZLAYgG5EQiQyNC/8s2GgFJFSQSRBdJiAY1SYEHiAPXiAaXIkMyCCmI+jZJFRZXBgJMUChMULAiQylJNhoBSRUkEkQXSTYaAkkVJRJEF0lOAiEGDkQWvUUBQQBMSwGIA6tJRQQjRQVLARJBAB4jSYGQA08CC0sFCEwWSZMkDkRXBwFMFlAoTFCwIkNJSwMNQQAKIksBSwQJTEL/04H/AUsDSwIJTEL/x4HEE0UEIoE7SwIITEL/uDYaAUkVJBJEF0lxC04CSBa9RQEqI08DVCJPAlQoTFCwIkM2GgFJFSQSRBdHAogFVhYlIrojU0AACklxB0QyAxJBAAwiKiNPAlQoTFCwIkMjQv/xNhoBSRUkEkQXSYgFJhZJIyK6I1NMgSMkuhcqI08DVEwWUChMULAiQzYaAUkVJBJEF0mIBP4WSSMiuksBIkm6SwIlIrpLA4MCAyC6SRWBIBJESwSBIyS6F08FgSskuhdPBU8FUE8EUE8DUE8CFlBMFlAoTFCwIkM2GgFJFSQSRBdJiASvSYgCehZJk4EQDkRXBgJMiAJsIQUIIQQKFkmTJA5EVwcBTIACA+9QTFAoTFCwIkMpNhoBSRUkEkQXSTYaAklOAhUiEkRJiARniAIzIQUIIQQKSU4CQQA9F0lLAklOAgxEIglLAQ1FBEsCTIgC00sCFoEjJLoXKiNLBlRMFlBMSRUWVwYCTFBMgAIAC1BMUChMULAiQxcURCNFAylC/882GgFJFSQSRBc2GgJJFSUSRDYaA0kVJRJESwKIA/MXSSEEDkRMF0lLAghLA4gBsQ5ETwIWgTNPAghPArpJFRZXBgJMUChMULAiQzYaAUkVJBJEF0mIA7qIArNJFYEgEkQoTFCwIkM2GgFJFSQSRBc2GgJJFSISREsBiAOVSwGIAV8hBQghBApJREwXSU8CDERKiAIOiAK5SRWBIBJEKExQsCJDNhoBSRUkEkQXSYgDYRaDAgMgukkVgSASRChMULAiQzYaAUkVJBJEFzYaAkkjWSUISwEVEkRXAgBLAYgDMUyIAfZMXwBJFUkhBA5EFlcGAkxQKExQsCJDNhoBSRUkEkQXNhoCSSNZJQhLARUSRFcCAEsBiAL5TIgBvkxfARYoTFCwIkM2GgFJFSQSRBc2GgJJI1klCEsBFRJEVwIASwGIAs1MiAGSTF8CSRVJIQQORBZXBgJMUChMULAiQzYaAUkVJBJEFzYaAkkjWSUISwEVEkRXAgA2GgNJFSISREsCiAKNF0kiDkRPAogBTE8CXwBMQAAVXgBJFUkhBA5EFlcGAkxQKExQsCJDXgFC/+gyCnMARDIKcwFECbEyCbIHsggishAjsgGzIkOKAgCL/hZJJSK6gQeL/wkiVCVMu4mKAQGL/xa9RIEzCYmKAgCL/hZJvUSL/xVLAQhLAkzTi/+7iYoDAIv9FkmBM9OL/Yv/iP/Yi/2I/8eL/g5EMgQxFiIIiwKLAQxBAG2LAjgQgQYSQQBfiwI4GDIIEkEAVYsCOBlAAE4iQQBGiwIjwhorEkEAPIsCIsIaiwASQQAxIkEAJIsCJcIaVwIAi/2I/3BLARUIi/4ORIv9TIj/bov9iP9di/4ORIsCIgiMAkL/kyNC/8wjQv+vi/2I/0OL/hJEiYoCAYv+iP82SYv/IQQLSU8CD0EABCmMAImLAIsBSU4CCSEESwEMIQRMTYv+FoEzTwMITwK6jACJigEBi/8WSSMiuiNTRIv/iP70gTNMuomKAQCL/4j+54v/FkkjIrpPAoGAIA4jTFQjTLuJigEBgW4jiPTCi/8WSSMiuksBIkm6SwIlIrqL/4j+tBZXBgKADmFyYzAwODkvaGVhZGVyTwVQTwRQTwNQTwJQTFADiYoDAYGWASOI9H6L/RaL/hZXBwGL/xUWVwYCgAxhcmMwMDg5L3BhZ2VPA1BPAlBMUIv/UAOJigEBKYv/iP9/i/+I/k0hBQghBApJKUxBACsjjACLAIsCDEEAIIv/iwBJTgKI/u6L/0sCTwKI/5OLA0xQjAMiCIwAQv/YgAphcmMwMDg5L2FtiwFQiwNQA4wAiYoCAIv+cQtFAUSL/ogAw0SL/yEGDkSJigIAi/6L/4j/34v+Fkm9RQFEJSK6I1MURImKAQCL/3ELRQFEi/8WvUUBRImKAQCL/4j/5ov/iACCRIv/FiUiuiNTFESJigIAMgYyB4v+FkkiSboXFkmTJA5EVwcBSwElIroXFkmTJA5EVwcBSwIjIrojU08FFk8ETFBPBBZQTwNQTwJQKiNPA1RQi/9QgASLA1CETFCwiYoBAIv/iP5bi/+I/uqL/xZJgQNLA7syBhaBI0y7i/9MiP+LiYoBATEAi/9xB0QSiYoBAYv/cQpBAAuLADIDEkEAAyJMiSNC//o=", "clear": "DIEBQw=="}, "desc": "\n    Singleton Application providing ASA metadata via Algod API and AVM\n    ", "events": [{"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}, {"type": "byte", "name": "reversible_flags"}, {"type": "byte", "name": "irreversible_flags"}, {"type": "bool", "name": "is_short"}, {"type": "byte[32]", "name": "hash"}], "name": "Arc89MetadataUpdated", "desc": "Event emitted when Asset Metadata is created or updated"}, {"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "new_registry_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataMigrated", "desc": "Event emitted when Asset Metadata has been migrated to a new ASA Metadata Registry version"}, {"args": [{"type": "uint64", "name": "asset_id"}, {"type": "uint64", "name": "round"}, {"type": "uint64", "name": "timestamp"}], "name": "Arc89MetadataDeleted", "desc": "Event emitted when Asset Metadata is deleted"}], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEyCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAxIDAgOCAyIDEwMDcgMTAwNiAzMDUwNgogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1IDB4IDB4MDAgMHgzN2FjNzU1ZCAweDA2ODEwMSAweDE1MWY3Yzc1MDEgVE1QTF9UUlVTVEVEX0RFUExPWUVSIFRNUExfQVJDOTBfTkVUQVVUSAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozOAogICAgLy8gY2xhc3MgQXNhTWV0YWRhdGFSZWdpc3RyeShBcmM4OUludGVyZmFjZSwgQXNhVmFsaWRhdGlvbik6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9kZXBsb3lAMzgKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydAogICAgcHVzaGJ5dGVzcyAweDc4NDA3ODMxIDB4YjgyZWE3ZWYgMHgxMjQ1ZmFmYiAweDA0NWYyZTZlIDB4ZGRmZmNiOTIgMHgxNWIyNzViMiAvLyBtZXRob2QgImFyYzg5X2NyZWF0ZV9tZXRhZGF0YSh1aW50NjQsYnl0ZSxieXRlLHVpbnQxNixieXRlW10scGF5KSh1aW50OCx1aW50NjQpIiwgbWV0aG9kICJhcmM4OV9yZXBsYWNlX21ldGFkYXRhKHVpbnQ2NCx1aW50MTYsYnl0ZVtdKSh1aW50OCx1aW50NjQpIiwgbWV0aG9kICJhcmM4OV9yZXBsYWNlX21ldGFkYXRhX2xhcmdlcih1aW50NjQsdWludDE2LGJ5dGVbXSxwYXkpKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfc2xpY2UodWludDY0LHVpbnQxNixieXRlW10pdm9pZCIsIG1ldGhvZCAiYXJjODlfbWlncmF0ZV9tZXRhZGF0YSh1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgImFyYzg5X2RlbGV0ZV9tZXRhZGF0YSh1aW50NjQpKHVpbnQ4LHVpbnQ2NCkiCiAgICBieXRlY18zIC8vIG1ldGhvZCAiYXJjODlfZXh0cmFfcGF5bG9hZCh1aW50NjQsYnl0ZVtdKXZvaWQiCiAgICBwdXNoYnl0ZXNzIDB4YjUxMjFkOGEgMHg0OWZiYWU5MSAweDBiNTM4Y2UzIDB4MDE1ZTU3OWIgMHgwODlmYWVhMSAweDhlNWUxMDI0IDB4MjQ0YzQ3YzQgMHgyZDU5ZjZlMCAweGVlODViNDczIDB4Yjc1OTMxYmMgMHg4ZjI1ZWY3MiAweDExYzM4NDc2IDB4YjBhYmY2NWIgMHhjZTlkYmVkNyAweGNhNTJmYjFlIDB4MjI2MzkxYjkgMHg3YTEzZDUzMiAweDUzYzIyMjAzIDB4ZDM3NzJhZDMgMHg3ZGEyYWY0MCAweDAwNTZkOWMxIDB4YjkyZTI2N2EgLy8gbWV0aG9kICJhcmM4OV9zZXRfcmV2ZXJzaWJsZV9mbGFnKHVpbnQ2NCx1aW50OCxib29sKXZvaWQiLCBtZXRob2QgImFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZyh1aW50NjQsdWludDgpdm9pZCIsIG1ldGhvZCAiYXJjODlfc2V0X2ltbXV0YWJsZSh1aW50NjQpdm9pZCIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3JlZ2lzdHJ5X3BhcmFtZXRlcnMoKSh1aW50OCx1aW50MTYsdWludDE2LHVpbnQxNix1aW50MTYsdWludDE2LHVpbnQxNix1aW50MTYsdWludDY0LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9wYXJ0aWFsX3VyaSgpc3RyaW5nIiwgbWV0aG9kICJhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhKHVpbnQ2NCx1aW50MTYpKHVpbnQ4LHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2NoZWNrX21ldGFkYXRhX2V4aXN0cyh1aW50NjQpKGJvb2wsYm9vbCkiLCBtZXRob2QgImFyYzg5X2lzX21ldGFkYXRhX2ltbXV0YWJsZSh1aW50NjQpYm9vbCIsIG1ldGhvZCAiYXJjODlfaXNfbWV0YWRhdGFfc2hvcnQodWludDY0KShib29sLHVpbnQ2NCkiLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXIodWludDY0KShieXRlLGJ5dGUsYnl0ZSxieXRlWzMyXSx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2luYXRpb24odWludDY0KSh1aW50MTYsdWludDE2LHVpbnQ4KSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhKHVpbnQ2NCx1aW50OCkoYm9vbCx1aW50NjQsYnl0ZVtdKSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3NsaWNlKHVpbnQ2NCx1aW50MTYsdWludDE2KWJ5dGVbXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlcl9oYXNoKHVpbnQ2NClieXRlWzMyXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaCh1aW50NjQsdWludDgpYnl0ZVszMl0iLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV9oYXNoKHVpbnQ2NClieXRlWzMyXSIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX3N0cmluZ19ieV9rZXkodWludDY0LHN0cmluZylzdHJpbmciLCBtZXRob2QgImFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5KHVpbnQ2NCxzdHJpbmcpdWludDY0IiwgbWV0aG9kICJhcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleSh1aW50NjQsc3RyaW5nKXN0cmluZyIsIG1ldGhvZCAiYXJjODlfZ2V0X21ldGFkYXRhX2I2NF9ieXRlc19ieV9rZXkodWludDY0LHN0cmluZyx1aW50OClieXRlW10iLCBtZXRob2QgImV4dHJhX3Jlc291cmNlcygpdm9pZCIsIG1ldGhvZCAid2l0aGRyYXdfYmFsYW5jZV9leGNlc3MoKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBhcmM4OV9jcmVhdGVfbWV0YWRhdGEgYXJjODlfcmVwbGFjZV9tZXRhZGF0YSBhcmM4OV9yZXBsYWNlX21ldGFkYXRhX2xhcmdlciBhcmM4OV9yZXBsYWNlX21ldGFkYXRhX3NsaWNlIGFyYzg5X21pZ3JhdGVfbWV0YWRhdGEgYXJjODlfZGVsZXRlX21ldGFkYXRhIGFyYzg5X2V4dHJhX3BheWxvYWQgYXJjODlfc2V0X3JldmVyc2libGVfZmxhZyBhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWcgYXJjODlfc2V0X2ltbXV0YWJsZSBtYWluX2FyYzg5X2dldF9tZXRhZGF0YV9yZWdpc3RyeV9wYXJhbWV0ZXJzX3JvdXRlQDE2IGFyYzg5X2dldF9tZXRhZGF0YV9wYXJ0aWFsX3VyaSBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhIGFyYzg5X2NoZWNrX21ldGFkYXRhX2V4aXN0cyBhcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGUgYXJjODlfaXNfbWV0YWRhdGFfc2hvcnQgYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlciBhcmM4OV9nZXRfbWV0YWRhdGFfcGFnaW5hdGlvbiBhcmM4OV9nZXRfbWV0YWRhdGEgYXJjODlfZ2V0X21ldGFkYXRhX3NsaWNlIGFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJfaGFzaCBhcmM4OV9nZXRfbWV0YWRhdGFfcGFnZV9oYXNoIGFyYzg5X2dldF9tZXRhZGF0YV9oYXNoIGFyYzg5X2dldF9tZXRhZGF0YV9zdHJpbmdfYnlfa2V5IGFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5IGFyYzg5X2dldF9tZXRhZGF0YV9vYmplY3RfYnlfa2V5IGFyYzg5X2dldF9tZXRhZGF0YV9iNjRfYnl0ZXNfYnlfa2V5IG1haW5fZXh0cmFfcmVzb3VyY2VzX3JvdXRlQDMzIHdpdGhkcmF3X2JhbGFuY2VfZXhjZXNzCiAgICBlcnIKCm1haW5fZXh0cmFfcmVzb3VyY2VzX3JvdXRlQDMzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjY3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCm1haW5fYXJjODlfZ2V0X21ldGFkYXRhX3JlZ2lzdHJ5X3BhcmFtZXRlcnNfcm91dGVAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc4NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NTA4MDAzMzc3MmExMDAwMDNlZjA3ZWUwN2YyMDdmMDAwMDAwMDAwMDAwMDA5YzQwMDAwMDAwMDAwMDAwMTkwCiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVwbG95QDM4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNzEKICAgIC8vIEBhcmM0LmJhcmVtZXRob2QoY3JlYXRlPSJyZXF1aXJlIikKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICAmJgogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3Ni0zNzcKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gVGVtcGxhdGVWYXJbQWNjb3VudF0oCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM3Ni0zNzkKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gVGVtcGxhdGVWYXJbQWNjb3VudF0oCiAgICAvLyAgICAgVFJVU1RFRF9ERVBMT1lFUgogICAgLy8gKSwgZXJyLlVOVFJVU1RFRF9ERVBMT1lFUgogICAgYnl0ZWMgNiAvLyBUTVBMX1RSVVNURURfREVQTE9ZRVIKICAgID09CiAgICBhc3NlcnQgLy8gVGhlIGRlcGxveWVyIGFkZHJlc3MgaXMgbm90IHRydXN0ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzcxCiAgICAvLyBAYXJjNC5iYXJlbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gX3B1eWFfbGliLnV0aWwuZW5zdXJlX2J1ZGdldChyZXF1aXJlZF9idWRnZXQ6IHVpbnQ2NCwgZmVlX3NvdXJjZTogdWludDY0KSAtPiB2b2lkOgplbnN1cmVfYnVkZ2V0OgogICAgcHJvdG8gMiAwCiAgICBmcmFtZV9kaWcgLTIKICAgIHB1c2hpbnQgMTAKICAgICsKCmVuc3VyZV9idWRnZXRfd2hpbGVfdG9wQDE6CiAgICBmcmFtZV9kaWcgMAogICAgZ2xvYmFsIE9wY29kZUJ1ZGdldAogICAgPgogICAgYnogZW5zdXJlX2J1ZGdldF9hZnRlcl93aGlsZUA2CiAgICBpdHhuX2JlZ2luCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgYnl0ZWMgNCAvLyAweDA2ODEwMQogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KICAgIGJ5dGVjIDQgLy8gMHgwNjgxMDEKICAgIGl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KICAgIGZyYW1lX2RpZyAtMQogICAgc3dpdGNoIGVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfMEAzIGVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfMUA0CgplbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlX25leHRANToKICAgIGl0eG5fc3VibWl0CiAgICBiIGVuc3VyZV9idWRnZXRfd2hpbGVfdG9wQDEKCmVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfMUA0OgogICAgZ2xvYmFsIE1pblR4bkZlZQogICAgaXR4bl9maWVsZCBGZWUKICAgIGIgZW5zdXJlX2J1ZGdldF9zd2l0Y2hfY2FzZV9uZXh0QDUKCmVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfMEAzOgogICAgaW50Y18xIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBiIGVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfbmV4dEA1CgplbnN1cmVfYnVkZ2V0X2FmdGVyX3doaWxlQDY6CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXZtX2xpYnJhcnkuZW5kc3dpdGgoczogYnl0ZXMsIHN1ZmZpeDogYnl0ZXMpIC0+IHVpbnQ2NDoKZW5kc3dpdGg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6NTMtNTQKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZW5kc3dpdGgoczogQnl0ZXMsIHN1ZmZpeDogQnl0ZXMpIC0+IGJvb2w6CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTo1NQogICAgLy8gYXNzZXJ0IHN1ZmZpeC5sZW5ndGggPD0gcy5sZW5ndGgKICAgIGZyYW1lX2RpZyAtMQogICAgbGVuCiAgICBmcmFtZV9kaWcgLTIKICAgIGxlbgogICAgZHVwMgogICAgPD0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjU2CiAgICAvLyByZXR1cm4gc1tzLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGggOl0gPT0gc3VmZml4CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgLQogICAgZHVwCiAgICBkaWcgMgogICAgPj0KICAgIGRpZyAyCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXZtX2xpYnJhcnkuYXJjOTBfYm94X3F1ZXJ5KGFwcF9pZDogdWludDY0LCBib3hfbmFtZTogYnl0ZXMpIC0+IGJ5dGVzOgphcmM5MF9ib3hfcXVlcnk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6NTktNjAKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgYXJjOTBfYm94X3F1ZXJ5KGFwcF9pZDogVUludDY0LCBib3hfbmFtZTogQnl0ZXMpIC0+IEJ5dGVzOgogICAgcHJvdG8gMiAxCiAgICBpbnRjXzEgLy8gMAogICAgZHVwCiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6NjEKICAgIC8vIGlmIEdsb2JhbC5nZW5lc2lzX2hhc2ggPT0gQnl0ZXMuZnJvbV9iYXNlNjQoTUFJTk5FVF9HSF9CNjQpOgogICAgZ2xvYmFsIEdlbmVzaXNIYXNoCiAgICBwdXNoYnl0ZXMgYmFzZTY0KHdHSEUyUHdkdmQ3UzEyQkw1RmFPUDIwRUdZZXNONzNrdGlDMXF6a2tpdDg9KQogICAgPT0KICAgIGJ6IGFyYzkwX2JveF9xdWVyeV9lbHNlX2JvZHlAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjYyCiAgICAvLyBhcmM5MF9uZXRhdXRoID0gQnl0ZXMoKQogICAgYnl0ZWNfMSAvLyAweAoKYXJjOTBfYm94X3F1ZXJ5X2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTo2NgogICAgLy8gQVJDOTBfVVJJX1NDSEVNRQogICAgcHVzaGJ5dGVzIDB4NjE2YzY3NmY3MjYxNmU2NDNhMmYyZgogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjY2LTY3CiAgICAvLyBBUkM5MF9VUklfU0NIRU1FCiAgICAvLyArIGFyYzkwX25ldGF1dGgKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjY4CiAgICAvLyArIEFSQzkwX1VSSV9BUFBfUEFUSAogICAgcHVzaGJ5dGVzIDB4NjE3MDcwMmYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTo2Ni02OAogICAgLy8gQVJDOTBfVVJJX1NDSEVNRQogICAgLy8gKyBhcmM5MF9uZXRhdXRoCiAgICAvLyArIEFSQzkwX1VSSV9BUFBfUEFUSAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTozNwogICAgLy8gYWNjID0gQnl0ZXMoYiIiKQogICAgYnl0ZWNfMSAvLyAweAogICAgZnJhbWVfYnVyeSAwCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2J1cnkgMgoKYXJjOTBfYm94X3F1ZXJ5X3doaWxlX3RvcEA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjM5CiAgICAvLyB3aGlsZSBpID4gMDoKICAgIGZyYW1lX2RpZyAyCiAgICBieiBhcmM5MF9ib3hfcXVlcnlfYWZ0ZXJfd2hpbGVANwogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjQwCiAgICAvLyBkID0gaSAlIFVJbnQ2NCgxMCkKICAgIGZyYW1lX2RpZyAyCiAgICBkdXAKICAgIHB1c2hpbnQgMTAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTo0MQogICAgLy8gYWNjID0gZGlnaXRzW2QgOiBkICsgVUludDY0KDEpXSArIGFjYwogICAgZHVwCiAgICBwdXNoaW50IDEwCiAgICA+PQogICAgZGlnIDEKICAgIHB1c2hpbnQgMTAKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgZHVwCiAgICBwdXNoaW50IDEwCiAgICA+PQogICAgcHVzaGludCAxMAogICAgc3dhcAogICAgc2VsZWN0CiAgICBkdXAKICAgIGRpZyAyCiAgICA8CiAgICBkaWcgMgogICAgc3dhcAogICAgc2VsZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6MzUtMzYKICAgIC8vICMgQVNDSUkgZGlnaXRzICh2YWxpZCBVVEYtOCkKICAgIC8vIGRpZ2l0cyA9IEJ5dGVzKGIiMDEyMzQ1Njc4OSIpCiAgICBwdXNoYnl0ZXMgMHgzMDMxMzIzMzM0MzUzNjM3MzgzOQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjQxCiAgICAvLyBhY2MgPSBkaWdpdHNbZCA6IGQgKyBVSW50NjQoMSldICsgYWNjCiAgICBjb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBmcmFtZV9kaWcgMAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTo0MgogICAgLy8gaSAvLz0gVUludDY0KDEwKQogICAgcHVzaGludCAxMAogICAgLwogICAgZnJhbWVfYnVyeSAyCiAgICBiIGFyYzkwX2JveF9xdWVyeV93aGlsZV90b3BANQoKYXJjOTBfYm94X3F1ZXJ5X2FmdGVyX3doaWxlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6NDQKICAgIC8vIHJldHVybiBhY2Mgb3IgQnl0ZXMoYiIwIikKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGJ5dGVzIDB4MzAKICAgIGNvdmVyIDIKICAgIHNlbGVjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjY2LTY5CiAgICAvLyBBUkM5MF9VUklfU0NIRU1FCiAgICAvLyArIGFyYzkwX25ldGF1dGgKICAgIC8vICsgQVJDOTBfVVJJX0FQUF9QQVRICiAgICAvLyArIGl0b2EoYXBwX2lkKQogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjcwCiAgICAvLyArIEFSQzkwX1VSSV9CT1hfUVVFUlkKICAgIHB1c2hieXRlcyAweDNmNjI2Zjc4M2QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTo2Ni03MAogICAgLy8gQVJDOTBfVVJJX1NDSEVNRQogICAgLy8gKyBhcmM5MF9uZXRhdXRoCiAgICAvLyArIEFSQzkwX1VSSV9BUFBfUEFUSAogICAgLy8gKyBpdG9hKGFwcF9pZCkKICAgIC8vICsgQVJDOTBfVVJJX0JPWF9RVUVSWQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6NjYtNzEKICAgIC8vIEFSQzkwX1VSSV9TQ0hFTUUKICAgIC8vICsgYXJjOTBfbmV0YXV0aAogICAgLy8gKyBBUkM5MF9VUklfQVBQX1BBVEgKICAgIC8vICsgaXRvYShhcHBfaWQpCiAgICAvLyArIEFSQzkwX1VSSV9CT1hfUVVFUlkKICAgIC8vICsgYm94X25hbWUKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6NjUtNzIKICAgIC8vIHJldHVybiAoCiAgICAvLyAgICAgQVJDOTBfVVJJX1NDSEVNRQogICAgLy8gICAgICsgYXJjOTBfbmV0YXV0aAogICAgLy8gICAgICsgQVJDOTBfVVJJX0FQUF9QQVRICiAgICAvLyAgICAgKyBpdG9hKGFwcF9pZCkKICAgIC8vICAgICArIEFSQzkwX1VSSV9CT1hfUVVFUlkKICAgIC8vICAgICArIGJveF9uYW1lCiAgICAvLyApCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKYXJjOTBfYm94X3F1ZXJ5X2Vsc2VfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjY0CiAgICAvLyBhcmM5MF9uZXRhdXRoID0gVGVtcGxhdGVWYXJbQnl0ZXNdKEFSQzkwX05FVEFVVEgpICsgQVJDOTBfVVJJX1BBVEhfU0VQCiAgICBieXRlYyA3IC8vIFRNUExfQVJDOTBfTkVUQVVUSAogICAgcHVzaGJ5dGVzIDB4MmYKICAgIGNvbmNhdAogICAgYiBhcmM5MF9ib3hfcXVlcnlfYWZ0ZXJfaWZfZWxzZUAzCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2NyZWF0ZV9tZXRhZGF0YVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2NyZWF0ZV9tZXRhZGF0YToKICAgIGludGNfMSAvLyAwCiAgICBkdXBuIDQKICAgIGJ5dGVjXzEgLy8gIiIKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozODEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBpbnRjXzAgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMCAvLyAxCiAgICAtCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMCAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDA3LTQwOAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQsIG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkpCiAgICBzd2FwCiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGRpZyAzCiAgICBzd2FwCiAgICBjYWxsc3ViIF9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDcKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQwOQogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNzZXRfaWQpLCBlcnIuQVNTRVRfTUVUQURBVEFfRVhJU1QKICAgICEKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDExCiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBzd2FwCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQxMC00MTIKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyX2RlbHRhX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgLy8gKSwgZXJyLk1CUl9ERUxUQV9SRUNFSVZFUl9JTlZBTElECiAgICBhc3NlcnQgLy8gSW52YWxpZCBNQlIgRGVsdGEgcmVjZWl2ZXIsIG11c3QgYmUgdGhlIEFTQSBNZXRhZGF0YSBSZWdpc3RyeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MTQtNDE1CiAgICAvLyAjIEluaXRpYWxpemUgZW1wdHkgQXNzZXQgTWV0YWRhdGEgQm94CiAgICAvLyBtYnJfaSA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIHN3YXAKICAgIGNvdmVyIDMKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MTYKICAgIC8vIF9leGlzdHMgPSBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc3NldF9pZCkuY3JlYXRlKHNpemU9VUludDY0KDApKQogICAgaW50Y18xIC8vIDAKICAgIGJveF9jcmVhdGUKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0MTgtNDE5CiAgICAvLyAjIFNldCBNZXRhZGF0YSBCb2R5CiAgICAvLyBpZiBwYXlsb2FkLmxlbmd0aCA+IDA6CiAgICBsZW4KICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDIwCiAgICAvLyBlbnN1cmVfYnVkZ2V0KHJlcXVpcmVkX2J1ZGdldD1jb25zdC5BUFBfQ0FMTF9PUF9CVURHRVQpCiAgICBwdXNoaW50IDcwMAogICAgaW50Y18xIC8vIDAKICAgIGNhbGxzdWIgZW5zdXJlX2J1ZGdldAoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDIxCiAgICAvLyBzZWxmLl9zZXRfbWV0YWRhdGFfcGF5bG9hZChhc3NldF9pZCwgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSwgcGF5bG9hZCkKICAgIGRpZyA3CiAgICBkdXAKICAgIGRpZyA0CiAgICBkaWcgNwogICAgY2FsbHN1YiBfc2V0X21ldGFkYXRhX3BheWxvYWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDIzLTQyNAogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl9pZGVudGlmeV9tZXRhZGF0YShhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfaWRlbnRpZnlfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDI4CiAgICAvLyB1aW50PXJldmVyc2libGVfZmxhZ3MuYXNfdWludDY0KCksIHNpemU9VUludDY0KGNvbnN0LkJZVEVfU0laRSkKICAgIGRpZyA3CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6MjAKICAgIC8vIHJldHVybiBvcC5leHRyYWN0KG9wLml0b2IodWludCksIHN0YXJ0LCBzaXplKQogICAgaXRvYgogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTItOTQKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIC8vICkKICAgIGRpZyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTItOTQKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDM0CiAgICAvLyB1aW50PWlycmV2ZXJzaWJsZV9mbGFncy5hc191aW50NjQoKSwgc2l6ZT1VSW50NjQoY29uc3QuQllURV9TSVpFKQogICAgZGlnIDcKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weToyMAogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBpdG9iCiAgICBleHRyYWN0IDcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDQKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDMtMTA1CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywgdmFsdWU9ZmxhZ3MKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQzOAogICAgLy8gYXNhX21ldGFkYXRhX2hhc2ggPSBhc3NldF9pZC5tZXRhZGF0YV9oYXNoCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWV0YWRhdGFIYXNoCiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMTcKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDM5CiAgICAvLyBoYXNfYW0gPSBhc2FfbWV0YWRhdGFfaGFzaCAhPSBCeXRlcyhjb25zdC5CWVRFUzMyX1NJWkUgKiBiIlx4MDAiKQogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgIT0KICAgIGR1cAogICAgYnVyeSAxMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NDAKICAgIC8vIGlmIGhhc19hbToKICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9lbHNlX2JvZHlANQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBkaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTAKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4LTExMQogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfaXJyZXZlcnNpYmxlX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDQxCiAgICAvLyBhc3NlcnQgc2VsZi5faXNfaW1tdXRhYmxlKGFzc2V0X2lkKSwgZXJyLlJFUVVJUkVTX0lNTVVUQUJMRQogICAgYXNzZXJ0IC8vIE11c3QgYmUgZmxhZ2dlZCBhcyBpbW11dGFibGUKICAgIGRpZyAxNAogICAgYnVyeSAxMgoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3LTEyOQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCB2YWx1ZT1tZXRhZGF0YV9oYXNoCiAgICAvLyApCiAgICBkaWcgMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyOAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIHB1c2hpbnQgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjctMTI5CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIHZhbHVlPW1ldGFkYXRhX2hhc2gKICAgIC8vICkKICAgIGRpZyAxNAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDQ2CiAgICAvLyBzZWxmLl9zZXRfbGFzdF9tb2RpZmllZF9yb3VuZChhc3NldF9pZCwgR2xvYmFsLnJvdW5kKQogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0MgogICAgLy8gdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQwLTE0MwogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgLy8gICAgIHZhbHVlPW9wLml0b2IobGFzdF9tb2RpZmllZF9yb3VuZCksCiAgICAvLyApCiAgICBkaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDEKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgcHVzaGludCAzNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDAtMTQzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDQ3CiAgICAvLyBzZWxmLl9zZXRfZGVwcmVjYXRlZF9ieShhc3NldF9pZCwgVUludDY0KDApKQogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTU2CiAgICAvLyB2YWx1ZT1vcC5pdG9iKGRlcHJlY2F0ZWRfYnkpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTQtMTU3CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICAvLyAgICAgdmFsdWU9b3AuaXRvYihkZXByZWNhdGVkX2J5KSwKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICBwdXNoaW50IDQzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1NC0xNTcKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICB2YWx1ZT1vcC5pdG9iKGRlcHJlY2F0ZWRfYnkpLAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTAKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgcHVzaGludCA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOC0xMTEKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ0OS00NTAKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGlmIHNlbGYuX2lzX2FyYzNfbWV0YWRhdGEoYXNzZXRfaWQpOgogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjIyCiAgICAvLyBhc2FfbmFtZSA9IGFzYS5uYW1lCiAgICBkaWcgNwogICAgZHVwCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TmFtZQogICAgc3dhcAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBidXJ5IDE3CiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MjMKICAgIC8vIGFzYV91cmwgPSBhc2EudXJsCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0VVJMCiAgICBzd2FwCiAgICBidXJ5IDE1CiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MjcKICAgIC8vIGlmIGFzYV9uYW1lID09IEFSQzNfTkFNRToKICAgIHB1c2hieXRlcyAweDYxNzI2MzMzCiAgICA9PQogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weToyOAogICAgLy8gcmV0dXJuIFRydWUKICAgIGludGNfMCAvLyAxCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMuYXNhX3ZhbGlkYXRpb24uQXNhVmFsaWRhdGlvbi5faXNfYXJjM19jb21wbGlhbnRAMzE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1MQogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FyYzNfY29tcGxpYW50KGFzc2V0X2lkKSwgZXJyLkFTQV9OT1RfQVJDM19DT01QTElBTlQKICAgIGFzc2VydCAvLyBJbnZhbGlkIEFSQy0zIHBhcmFtZXRlcnMgKG5hbWUgb3IgVVJMKQoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OQogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEwCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIHB1c2hpbnQgNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDgtMTExCiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9pcnJldmVyc2libGVfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NTIKICAgIC8vIGlmIHNlbGYuX2lzX2FyYzU0X2J1cm5hYmxlKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1MwogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FyYzU0X2NvbXBsaWFudChhc3NldF9pZCksIGVyci5BU0FfTk9UX0FSQzU0X0NPTVBMSUFOVAogICAgZGlnIDcKICAgIGNhbGxzdWIgX2lzX2FyYzU0X2NvbXBsaWFudAogICAgYXNzZXJ0IC8vIFRoZSBBU0EgbXVzdCBub3QgaGF2ZSBhIGNsYXdiYWNrIGFkZHJlc3MKCmFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBkaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTAKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgcHVzaGludCA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOC0xMTEKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1NAogICAgLy8gaWYgc2VsZi5faXNfYXJjODlfbmF0aXZlKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6NDUtNDYKICAgIC8vICMgVGhpcyB2YWxpZGF0aW9uIGRvZXMgbm90IGVuZm9yY2UgQVJDLTkwIGNvbXBsaWFuY2UgZnJhZ21lbnRzIChvcHRpb25hbCkKICAgIC8vIGFyYzg5X3BhcnRpYWxfdXJpID0gYXJjOTBfYm94X3F1ZXJ5KEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkLCBCeXRlcygpKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBieXRlY18xIC8vIDB4CiAgICBjYWxsc3ViIGFyYzkwX2JveF9xdWVyeQogICAgZHVwCiAgICBidXJ5IDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6NDcKICAgIC8vIGFzYV91cmwgPSBhc2EudXJsCiAgICBkaWcgOAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldFVSTAogICAgc3dhcAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDE2CiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6NDkKICAgIC8vIGlmIGFzYV91cmwubGVuZ3RoIDwgYXJjODlfcGFydGlhbF91cmkubGVuZ3RoOgogICAgbGVuCiAgICBkdXAKICAgIGJ1cnkgMTIKICAgIHN3YXAKICAgIGxlbgogICAgZHVwCiAgICBidXJ5IDExCiAgICA8CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAxOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjUwCiAgICAvLyByZXR1cm4gRmFsc2UKICAgIGludGNfMSAvLyAwCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMuYXNhX3ZhbGlkYXRpb24uQXNhVmFsaWRhdGlvbi5faXNfYXJjODlfY29tcGxpYW50QDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NTUKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hcmM4OV9jb21wbGlhbnQoYXNzZXRfaWQpLCBlcnIuQVNBX05PVF9BUkM4OV9DT01QTElBTlQKICAgIGFzc2VydCAvLyBJbnZhbGlkIEFSQy04OSBwYXJ0aWFsIFVSSQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NTYKICAgIC8vIGlmIGhhc19hbSBhbmQgbm90IHNlbGYuX2lzX2FyYzNfbWV0YWRhdGEoYXNzZXRfaWQpOgogICAgZGlnIDEwCiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBkaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTAKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgcHVzaGludCA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOC0xMTEKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1NgogICAgLy8gaWYgaGFzX2FtIGFuZCBub3Qgc2VsZi5faXNfYXJjM19tZXRhZGF0YShhc3NldF9pZCk6CiAgICBibnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDU3LTQ1OQogICAgLy8gYXNzZXJ0IGFzYV9tZXRhZGF0YV9oYXNoID09IHNlbGYuX2NvbXB1dGVfbWV0YWRhdGFfaGFzaCgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLkFTQV9NRVRBREFUQV9IQVNIX01JU01BVENICiAgICBkaWcgNwogICAgY2FsbHN1YiBfY29tcHV0ZV9tZXRhZGF0YV9oYXNoCiAgICBkaWcgMTUKICAgID09CiAgICBhc3NlcnQgLy8gQVNBIE1ldGFkYXRhIEhhc2ggKGFtKSBkb2VzIG5vdCBtYXRjaCB0aGUgY29tcHV0ZWQgaGFzaAoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ2MQogICAgLy8gc2VsZi5fZW1pdF91cGRhdGVkX2V2ZW50KGFzc2V0X2lkLCBtZXRhZGF0YV9oYXNoKQogICAgZGlnIDcKICAgIGRpZyAxMgogICAgY2FsbHN1YiBfZW1pdF91cGRhdGVkX2V2ZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ2MwogICAgLy8gbWJyX2RlbHRhX2Ftb3VudCA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UgLSBtYnJfaQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBkaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NjUKICAgIC8vIG1icl9kZWx0YV9wYXltZW50LmFtb3VudCA+PSBtYnJfZGVsdGFfYW1vdW50CiAgICBkaWcgNAogICAgZ3R4bnMgQW1vdW50CiAgICBkaWcgMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDY0LTQ2NgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgLy8gKSwgZXJyLk1CUl9ERUxUQV9BTU9VTlRfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NjgtNDcwCiAgICAvLyByZXR1cm4gYWJpLk1ickRlbHRhKAogICAgLy8gICAgIHNpZ249YXJjNC5VSW50OChlbnVtcy5NQlJfREVMVEFfUE9TKSwgYW1vdW50PW1icl9kZWx0YV9hbW91bnQKICAgIC8vICkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzgxCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NTAxCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMTg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6NDkKICAgIC8vIGFzc2VydCBwcmVmaXgubGVuZ3RoIDw9IHMubGVuZ3RoCiAgICBkaWcgOAogICAgZHVwCiAgICBkaWcgMTEKICAgIGR1cAogICAgY292ZXIgMwogICAgPD0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjUwCiAgICAvLyByZXR1cm4gc1s6IHByZWZpeC5sZW5ndGhdID09IHByZWZpeAogICAgZHVwCiAgICBkaWcgMgogICAgPj0KICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIHNlbGVjdAogICAgZGlnIDEzCiAgICBpbnRjXzEgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBkaWcgMTYKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1NQogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FyYzg5X2NvbXBsaWFudChhc3NldF9pZCksIGVyci5BU0FfTk9UX0FSQzg5X0NPTVBMSUFOVAogICAgYiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMuYXNhX3ZhbGlkYXRpb24uQXNhVmFsaWRhdGlvbi5faXNfYXJjODlfY29tcGxpYW50QDE5CgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAyNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTozMAogICAgLy8gaWYgYXNhX25hbWUubGVuZ3RoID49IGFyYzNfbmFtZV9zdWZmaXgubGVuZ3RoOgogICAgZGlnIDEzCiAgICBsZW4KICAgIHB1c2hpbnQgNQogICAgPj0KICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MzEKICAgIC8vIGlmIGVuZHN3aXRoKGFzYV9uYW1lLCBhcmMzX25hbWVfc3VmZml4KToKICAgIGRpZyAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjI0CiAgICAvLyBhcmMzX25hbWVfc3VmZml4ID0gQnl0ZXMoQVJDM19OQU1FX1NVRkZJWCkKICAgIHB1c2hieXRlcyAweDQwNjE3MjYzMzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTozMQogICAgLy8gaWYgZW5kc3dpdGgoYXNhX25hbWUsIGFyYzNfbmFtZV9zdWZmaXgpOgogICAgY2FsbHN1YiBlbmRzd2l0aAogICAgYnogYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMjcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTozMgogICAgLy8gcmV0dXJuIFRydWUKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ1MQogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FyYzNfY29tcGxpYW50KGFzc2V0X2lkKSwgZXJyLkFTQV9OT1RfQVJDM19DT01QTElBTlQKICAgIGIgYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLmFzYV92YWxpZGF0aW9uLkFzYVZhbGlkYXRpb24uX2lzX2FyYzNfY29tcGxpYW50QDMxCgphcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAyNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTozNAogICAgLy8gaWYgYXNhX3VybC5sZW5ndGggPj0gYXJjM191cmxfc3VmZml4Lmxlbmd0aDoKICAgIGRpZyAxMgogICAgbGVuCiAgICBwdXNoaW50IDUKICAgID49CiAgICBieiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUAzMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjM1CiAgICAvLyBpZiBlbmRzd2l0aChhc2FfdXJsLCBhcmMzX3VybF9zdWZmaXgpOgogICAgZGlnIDEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MjUKICAgIC8vIGFyYzNfdXJsX3N1ZmZpeCA9IEJ5dGVzKEFSQzNfVVJMX1NVRkZJWCkKICAgIHB1c2hieXRlcyAweDIzNjE3MjYzMzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTozNQogICAgLy8gaWYgZW5kc3dpdGgoYXNhX3VybCwgYXJjM191cmxfc3VmZml4KToKICAgIGNhbGxzdWIgZW5kc3dpdGgKICAgIGJ6IGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDMwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MzYKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NTEKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hcmMzX2NvbXBsaWFudChhc3NldF9pZCksIGVyci5BU0FfTk9UX0FSQzNfQ09NUExJQU5UCiAgICBiIGFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5hc2FfdmFsaWRhdGlvbi5Bc2FWYWxpZGF0aW9uLl9pc19hcmMzX2NvbXBsaWFudEAzMQoKYXJjODlfY3JlYXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMzA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MzgKICAgIC8vIHJldHVybiBGYWxzZQogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDUxCiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXJjM19jb21wbGlhbnQoYXNzZXRfaWQpLCBlcnIuQVNBX05PVF9BUkMzX0NPTVBMSUFOVAogICAgYiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMuYXNhX3ZhbGlkYXRpb24uQXNhVmFsaWRhdGlvbi5faXNfYXJjM19jb21wbGlhbnRAMzEKCmFyYzg5X2NyZWF0ZV9tZXRhZGF0YV9lbHNlX2JvZHlANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDQ0CiAgICAvLyBtZXRhZGF0YV9oYXNoID0gc2VsZi5fY29tcHV0ZV9tZXRhZGF0YV9oYXNoKGFzc2V0X2lkKQogICAgZGlnIDcKICAgIGNhbGxzdWIgX2NvbXB1dGVfbWV0YWRhdGFfaGFzaAogICAgYnVyeSAxMgogICAgYiBhcmM4OV9jcmVhdGVfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA2CgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9yZXBsYWNlX21ldGFkYXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NzIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OTMtNDk0CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkLCBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpKQogICAgc3dhcAogICAgYnRvaQogICAgZGlnIDIKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OTUtNDk3CiAgICAvLyBhc3NlcnQgbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLkxBUkdFUl9NRVRBREFUQV9TSVpFCiAgICBkaWcgMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGRpZyAxCiAgICA+PQogICAgYXNzZXJ0IC8vIEludmFsaWQgTWV0YWRhdGEgc2l6ZSwgbXVzdCBiZSBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGN1cnJlbnQgc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0OTktNTAwCiAgICAvLyAjIFVwZGF0ZSBNZXRhZGF0YSBCb2R5CiAgICAvLyBtYnJfaSA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MDEKICAgIC8vIHNlbGYuX3NldF9tZXRhZGF0YV9wYXlsb2FkKGFzc2V0X2lkLCBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpLCBwYXlsb2FkKQogICAgZGlnIDMKICAgIGRpZyAyCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgX3NldF9tZXRhZGF0YV9wYXlsb2FkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUwMy01MDQKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEhlYWRlcgogICAgLy8gc2VsZi5fdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQoYXNzZXRfaWQpCiAgICBkaWcgMgogICAgY2FsbHN1YiBfdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTA4CiAgICAvLyBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc3NldF9pZCkgPT0gbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKQogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgdW5jb3ZlciAyCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MDYtNTA5CiAgICAvLyAjIFBvc3Rjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSA9PSBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpCiAgICAvLyApLCBlcnIuTUVUQURBVEFfU0laRV9NSVNNQVRDSAogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIHNpemUgbWlzbWF0Y2gsIG11c3QgYmUgZXhhY3RseSBlcXVhbCB0byBkZWNsYXJlZCBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUxMQogICAgLy8gbWJyX2RlbHRhX2Ftb3VudCA9IG1icl9pIC0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAtCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTEyCiAgICAvLyBpZiBtYnJfZGVsdGFfYW1vdW50ID09IFVJbnQ2NCgwKToKICAgIGJueiBhcmM4OV9yZXBsYWNlX21ldGFkYXRhX2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUxMwogICAgLy8gc2lnbiA9IFVJbnQ2NChlbnVtcy5NQlJfREVMVEFfTlVMTCkKICAgIGludGNfMSAvLyAwCgphcmM4OV9yZXBsYWNlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTIxCiAgICAvLyByZXR1cm4gYWJpLk1ickRlbHRhKHNpZ249YXJjNC5VSW50OChzaWduKSwgYW1vdW50PW1icl9kZWx0YV9hbW91bnQpCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICBkaWcgMQogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ3MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9yZXBsYWNlX21ldGFkYXRhX2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MTUKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX05FRykKICAgIHB1c2hpbnQgMjU1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUxNi01MTkKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1hc3NldF9pZC5tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD1tYnJfZGVsdGFfYW1vdW50LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MTcKICAgIC8vIHJlY2VpdmVyPWFzc2V0X2lkLm1hbmFnZXIsCiAgICBkaWcgMgogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MTYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMCAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MTYtNTE5CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YXNzZXRfaWQubWFuYWdlciwKICAgIC8vICAgICBhbW91bnQ9bWJyX2RlbHRhX2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIGFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA1CgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3JlcGxhY2VfbWV0YWRhdGFfbGFyZ2VyW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9sYXJnZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUyMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICBleHRyYWN0IDIgMAogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMCAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU0Ni01NDcKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQsIG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkpCiAgICB1bmNvdmVyIDIKICAgIGJ0b2kKICAgIGRpZyAzCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTQ4LTU1MAogICAgLy8gYXNzZXJ0IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkgPiBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIC8vICAgICBhc3NldF9pZAogICAgLy8gKSwgZXJyLlNNQUxMRVJfTUVUQURBVEFfU0laRQogICAgZGlnIDMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBkaWcgMQogICAgPAogICAgYXNzZXJ0IC8vIEludmFsaWQgTWV0YWRhdGEgc2l6ZSwgbXVzdCBiZSBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1MgogICAgLy8gbWJyX2RlbHRhX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZGlnIDEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTUxLTU1MwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfZGVsdGFfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLCBlcnIuTUJSX0RFTFRBX1JFQ0VJVkVSX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1CUiBEZWx0YSByZWNlaXZlciwgbXVzdCBiZSB0aGUgQVNBIE1ldGFkYXRhIFJlZ2lzdHJ5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1NS01NTYKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEJvZHkKICAgIC8vIG1icl9pID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU1NwogICAgLy8gc2VsZi5fc2V0X21ldGFkYXRhX3BheWxvYWQoYXNzZXRfaWQsIG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCksIHBheWxvYWQpCiAgICBkaWcgNAogICAgZGlnIDIKICAgIHVuY292ZXIgNQogICAgY2FsbHN1YiBfc2V0X21ldGFkYXRhX3BheWxvYWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTU5LTU2MAogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NjQKICAgIC8vIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSA9PSBtZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICB1bmNvdmVyIDIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2Mi01NjUKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpID09IG1ldGFkYXRhX3NpemUuYXNfdWludDY0KCkKICAgIC8vICksIGVyci5NRVRBREFUQV9TSVpFX01JU01BVENICiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgc2l6ZSBtaXNtYXRjaCwgbXVzdCBiZSBleGFjdGx5IGVxdWFsIHRvIGRlY2xhcmVkIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTY3CiAgICAvLyBtYnJfZGVsdGFfYW1vdW50ID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZSAtIG1icl9pCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTY5CiAgICAvLyBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgc3dhcAogICAgZ3R4bnMgQW1vdW50CiAgICBkaWcgMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTY4LTU3MAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtYnJfZGVsdGFfcGF5bWVudC5hbW91bnQgPj0gbWJyX2RlbHRhX2Ftb3VudAogICAgLy8gKSwgZXJyLk1CUl9ERUxUQV9BTU9VTlRfSU5WQUxJRAogICAgYXNzZXJ0IC8vIEludmFsaWQgTUJSIERlbHRhIGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NzItNTc0CiAgICAvLyByZXR1cm4gYWJpLk1ickRlbHRhKAogICAgLy8gICAgIHNpZ249YXJjNC5VSW50OChlbnVtcy5NQlJfREVMVEFfUE9TKSwgYW1vdW50PW1icl9kZWx0YV9hbW91bnQKICAgIC8vICkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTIzCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NTAxCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9yZXBsYWNlX21ldGFkYXRhX3NsaWNlW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTc2CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1OTMtNTk0CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkLCBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc3NldF9pZCkpCiAgICBkaWcgMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGRpZyAzCiAgICBzd2FwCiAgICBjYWxsc3ViIF9jaGVja191cGRhdGVfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1OTUKICAgIC8vIGFzc2VydCBvZmZzZXQuYXNfdWludDY0KCkgKyBwYXlsb2FkLmxlbmd0aCA8PSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZSgKICAgIHN3YXAKICAgIGJ0b2kKICAgIGRpZyAxCiAgICBsZW4KICAgIGR1cDIKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTk1LTU5NwogICAgLy8gYXNzZXJ0IG9mZnNldC5hc191aW50NjQoKSArIHBheWxvYWQubGVuZ3RoIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgLy8gICAgIGFzc2V0X2lkCiAgICAvLyApLCBlcnIuRVhDRUVEU19NRVRBREFUQV9TSVpFCiAgICBkaWcgNAogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIDw9CiAgICBhc3NlcnQgLy8gU2xpY2UgZXhjZWVkcyBtZXRhZGF0YSByYW5nZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjEKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICB1bmNvdmVyIDMKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjIKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldCwgbGVuZ3RoPXNpemUKICAgIHB1c2hpbnQgNTEKICAgIHVuY292ZXIgMwogICAgKwogICAgZHVwCiAgICBjb3ZlciA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2MS0yNjMKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LCBsZW5ndGg9c2l6ZQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MDEKICAgIC8vIGlmIHBheWxvYWQgIT0gZXhpc3Rpbmdfc2xpY2U6CiAgICAhPQogICAgYnogYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjAyLTYwNgogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgQm9keQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNzZXRfaWQpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LmFzX3VpbnQ2NCgpLAogICAgLy8gICAgIHZhbHVlPXBheWxvYWQsCiAgICAvLyApCiAgICBkdXAyCiAgICBkaWcgNAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjA4LTYwOQogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAoKYXJjODlfcmVwbGFjZV9tZXRhZGF0YV9zbGljZV9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X21pZ3JhdGVfbWV0YWRhdGFbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9taWdyYXRlX21ldGFkYXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MjYtNjI3CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MjkKICAgIC8vIG5ld19yZWdpc3RyeV9pZCAhPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZC5pZAogICAgZHVwCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgICE9CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYyOC02MzAKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbmV3X3JlZ2lzdHJ5X2lkICE9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkCiAgICAvLyApLCBlcnIuTkVXX1JFR0lTVFJZX0lEX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIG5ldyBBU0EgTWV0YWRhdGEgUmVnaXN0cnkgSUQsIG11c3QgYmUgZGlmZmVyZW50IGZyb20gY3VycmVudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTQKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIHN3YXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTU2CiAgICAvLyB2YWx1ZT1vcC5pdG9iKGRlcHJlY2F0ZWRfYnkpLAogICAgc3dhcAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNTQtMTU3CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICAvLyAgICAgdmFsdWU9b3AuaXRvYihkZXByZWNhdGVkX2J5KSwKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1NQogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICBwdXNoaW50IDQzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1NC0xNTcKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICB2YWx1ZT1vcC5pdG9iKGRlcHJlY2F0ZWRfYnkpLAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MzgKICAgIC8vIHJvdW5kPUdsb2JhbC5yb3VuZCwKICAgIGdsb2JhbCBSb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MzkKICAgIC8vIHRpbWVzdGFtcD1HbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCwKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQ3LTE1MAogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9ERVBSRUNBVEVEX0JZLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5ERVBSRUNBVEVEX0JZX1NJWkUsCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDgKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9ERVBSRUNBVEVEX0JZLAogICAgcHVzaGludCA0MwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDkKICAgIC8vIGxlbmd0aD1jb25zdC5ERVBSRUNBVEVEX0JZX1NJWkUsCiAgICBpbnRjXzIgLy8gOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDctMTUwCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkRFUFJFQ0FURURfQllfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0Ni0xNTEKICAgIC8vIHJldHVybiBvcC5idG9pKAogICAgLy8gICAgIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICAvLyAgICAgICAgIGxlbmd0aD1jb25zdC5ERVBSRUNBVEVEX0JZX1NJWkUsCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MzYtNjQxCiAgICAvLyBhYmkuQXJjODlNZXRhZGF0YU1pZ3JhdGVkKAogICAgLy8gICAgIGFzc2V0X2lkPWFzc2V0X2lkLmlkLAogICAgLy8gICAgIHJvdW5kPUdsb2JhbC5yb3VuZCwKICAgIC8vICAgICB0aW1lc3RhbXA9R2xvYmFsLmxhdGVzdF90aW1lc3RhbXAsCiAgICAvLyAgICAgbmV3X3JlZ2lzdHJ5X2lkPXNlbGYuX2dldF9kZXByZWNhdGVkX2J5KGFzc2V0X2lkKSwKICAgIC8vICkKICAgIGl0b2IKICAgIHVuY292ZXIgMwogICAgc3dhcAogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYzNS02NDIKICAgIC8vIGFyYzQuZW1pdCgKICAgIC8vICAgICBhYmkuQXJjODlNZXRhZGF0YU1pZ3JhdGVkKAogICAgLy8gICAgICAgICBhc3NldF9pZD1hc3NldF9pZC5pZCwKICAgIC8vICAgICAgICAgcm91bmQ9R2xvYmFsLnJvdW5kLAogICAgLy8gICAgICAgICB0aW1lc3RhbXA9R2xvYmFsLmxhdGVzdF90aW1lc3RhbXAsCiAgICAvLyAgICAgICAgIG5ld19yZWdpc3RyeV9pZD1zZWxmLl9nZXRfZGVwcmVjYXRlZF9ieShhc3NldF9pZCksCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4Yzg3MDIzYmYgLy8gbWV0aG9kICJBcmM4OU1ldGFkYXRhTWlncmF0ZWQodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjYxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2RlbGV0ZV9tZXRhZGF0YVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2RlbGV0ZV9tZXRhZGF0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjQ0CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NwogICAgLy8gcmV0dXJuIGFzYSBpbiBzZWxmLmFzc2V0X21ldGFkYXRhCiAgICBpdG9iCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NTktNjYwCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNzZXRfaWQpLCBlcnIuQVNTRVRfTUVUQURBVEFfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gQXNzZXQgTWV0YWRhdGEgZG9lcyBub3QgZXhpc3QgZm9yIHRoZSBzcGVjaWZpZWQgQVNBCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MTUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjYxCiAgICAvLyBpZiBzZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X2RlbGV0ZV9tZXRhZGF0YV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTkKICAgIC8vIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3LTEwMAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMAogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDgtMTExCiAgICAvLyByZXR1cm4gb3AuZ2V0Yml0KAogICAgLy8gICAgIHNlbGYuX2dldF9pcnJldmVyc2libGVfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjIKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5faXNfaW1tdXRhYmxlKGFzc2V0X2lkKSwgZXJyLklNTVVUQUJMRQogICAgIQogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIGlzIGltbXV0YWJsZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NjMKICAgIC8vIGFzc2VydCBzZWxmLl9pc19hc2FfbWFuYWdlcihhc3NldF9pZCksIGVyci5VTkFVVEhPUklaRUQKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9pc19hc2FfbWFuYWdlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZCwgbXVzdCBiZSB0aGUgQXNzZXQgTWFuYWdlcgoKYXJjODlfZGVsZXRlX21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjY1LTY2NgogICAgLy8gIyBEZWxldGUgTWV0YWRhdGEgYW5kIHJlZnVuZCBNQlIKICAgIC8vIG1icl9pID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY2NwogICAgLy8gZGVsIHNlbGYuYXNzZXRfbWV0YWRhdGFbYXNzZXRfaWRdCiAgICBkaWcgMQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjY4CiAgICAvLyBtYnJfZGVsdGFfYW1vdW50ID0gbWJyX2kgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjY5CiAgICAvLyBpdHhuLlBheW1lbnQocmVjZWl2ZXI9VHhuLnNlbmRlciwgYW1vdW50PW1icl9kZWx0YV9hbW91bnQpLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICB0eG4gU2VuZGVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGludGNfMCAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6Njc1CiAgICAvLyB0aW1lc3RhbXA9R2xvYmFsLmxhdGVzdF90aW1lc3RhbXAsCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY3NAogICAgLy8gcm91bmQ9R2xvYmFsLnJvdW5kLAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY3Mi02NzYKICAgIC8vIGFiaS5BcmM4OU1ldGFkYXRhRGVsZXRlZCgKICAgIC8vICAgICBhc3NldF9pZD1hc3NldF9pZC5pZCwKICAgIC8vICAgICByb3VuZD1HbG9iYWwucm91bmQsCiAgICAvLyAgICAgdGltZXN0YW1wPUdsb2JhbC5sYXRlc3RfdGltZXN0YW1wLAogICAgLy8gKQogICAgaXRvYgogICAgdW5jb3ZlciAzCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NzEtNjc3CiAgICAvLyBhcmM0LmVtaXQoCiAgICAvLyAgICAgYWJpLkFyYzg5TWV0YWRhdGFEZWxldGVkKAogICAgLy8gICAgICAgICBhc3NldF9pZD1hc3NldF9pZC5pZCwKICAgIC8vICAgICAgICAgcm91bmQ9R2xvYmFsLnJvdW5kLAogICAgLy8gICAgICAgICB0aW1lc3RhbXA9R2xvYmFsLmxhdGVzdF90aW1lc3RhbXAsCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4YmMzZjIwZDEgLy8gbWV0aG9kICJBcmM4OU1ldGFkYXRhRGVsZXRlZCh1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2NzktNjgxCiAgICAvLyByZXR1cm4gYWJpLk1ickRlbHRhKAogICAgLy8gICAgIHNpZ249YXJjNC5VSW50OChlbnVtcy5NQlJfREVMVEFfTkVHKSwgYW1vdW50PW1icl9kZWx0YV9hbW91bnQKICAgIC8vICkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjQ0CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHB1c2hieXRlcyAweDE1MWY3Yzc1ZmYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2V4dHJhX3BheWxvYWRbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9leHRyYV9wYXlsb2FkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2ODMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY5Ny02OTgKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IEdsb2JhbC5ncm91cF9zaXplID49IDIsIGVyci5OT19QQVlMT0FEX0hFQURfQ0FMTAogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50Y18zIC8vIDIKICAgID49CiAgICBhc3NlcnQgLy8gTm8gcGF5bG9hZCBoZWFkIGNhbGwgaW4gR3JvdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weToxNQogICAgLy8gX2NyZWF0b3IsIGV4aXN0cyA9IG9wLkFzc2V0UGFyYW1zR2V0LmFzc2V0X2NyZWF0b3IoYXNhKQogICAgZHVwCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0Q3JlYXRvcgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY5OQogICAgLy8gYXNzZXJ0IHNlbGYuX2FzYV9leGlzdHMoYXNzZXRfaWQpLCBlcnIuQVNBX05PVF9FWElTVAogICAgYXNzZXJ0IC8vIFRoZSBzcGVjaWZpZWQgQVNBIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjQ3CiAgICAvLyByZXR1cm4gYXNhIGluIHNlbGYuYXNzZXRfbWV0YWRhdGEKICAgIGR1cAogICAgaXRvYgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcwMAogICAgLy8gYXNzZXJ0IHNlbGYuX21ldGFkYXRhX2V4aXN0cyhhc3NldF9pZCksIGVyci5BU1NFVF9NRVRBREFUQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzAxCiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXNhX21hbmFnZXIoYXNzZXRfaWQpLCBlcnIuVU5BVVRIT1JJWkVECiAgICBjYWxsc3ViIF9pc19hc2FfbWFuYWdlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZCwgbXVzdCBiZSB0aGUgQXNzZXQgTWFuYWdlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2ODMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9zZXRfcmV2ZXJzaWJsZV9mbGFnW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfc2V0X3JldmVyc2libGVfZmxhZzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzAzCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuYm9vbAogICAgaW50Y18xIC8vIDAKICAgIGdldGJpdAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcxOS03MjAKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcyMQogICAgLy8gYXNzZXJ0IGZsYWcuYXNfdWludDY0KCkgPD0gZmxnLlJFVl9GTEdfUkVTRVJWRURfNywgZXJyLkZMQUdfSURYX0lOVkFMSUQKICAgIGJ0b2kKICAgIGR1cAogICAgcHVzaGludCA3CiAgICA8PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZmxhZyBpbmRleAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MwogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIHN3YXAKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIGludGNfMCAvLyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMtNzUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgwCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX1JFVl9GTEFHIC0gZmxhZywKICAgIHB1c2hpbnQgNwogICAgdW5jb3ZlciAyCiAgICAtCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzgtODEKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X3JldmVyc2libGVfZmxhZ3MoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX1JFVl9GTEFHIC0gZmxhZywKICAgIC8vICkKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MjUKICAgIC8vIGlmIHZhbHVlICE9IGV4aXN0aW5nX3ZhbHVlOgogICAgIT0KICAgIGJ6IGFyYzg5X3NldF9yZXZlcnNpYmxlX2ZsYWdfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczLTc1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBkaWcgMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3My03NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYtODgKICAgIC8vIHVwZGF0ZWRfZmxhZ3MgPSBvcC5zZXRiaXRfYnl0ZXMoCiAgICAvLyAgICAgc2VsZi5fZ2V0X3JldmVyc2libGVfZmxhZ3MoYXNhKSwgY29uc3QuQklUX1JJR0hUTU9TVF9SRVZfRkxBRyAtIGZsYWcsIHZhbHVlCiAgICAvLyApCiAgICBkaWcgMgogICAgZGlnIDUKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Mi05NAogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgLy8gKQogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzI5LTczMAogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAoKYXJjODlfc2V0X3JldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjcwMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZzoKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NDYtNzQ3CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0OQogICAgLy8gZmxnLklSUl9GTEdfQVJDNTQgPD0gZmxhZy5hc191aW50NjQoKSA8PSBmbGcuSVJSX0ZMR19SRVNFUlZFRF82CiAgICBidG9pCiAgICBkdXAKICAgIGludGNfMyAvLyAyCiAgICA+PQogICAgYnogYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfZmFsc2VANAogICAgZHVwCiAgICBwdXNoaW50IDYKICAgIDw9CiAgICBieiBhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzAgLy8gMQoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQ4LTc1MAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBmbGcuSVJSX0ZMR19BUkM1NCA8PSBmbGFnLmFzX3VpbnQ2NCgpIDw9IGZsZy5JUlJfRkxHX1JFU0VSVkVEXzYKICAgIC8vICksIGVyci5GTEFHX0lEWF9JTlZBTElECiAgICBhc3NlcnQgLy8gSW52YWxpZCBmbGFnIGluZGV4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZGlnIDEKICAgIGl0b2IKICAgIGR1cAogICAgYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTkKICAgIC8vIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3LTEwMAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMAogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICBwdXNoaW50IDcKICAgIGRpZyAyCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOC0xMTEKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc1NAogICAgLy8gaWYgbm90IGV4aXN0aW5nX3ZhbHVlOgogICAgYm56IGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzU1LTc1NgogICAgLy8gIyBTZXQgSXJyZXZlcnNpYmxlIEZsYWcKICAgIC8vIHNlbGYuX3NldF9pcnJldmVyc2libGVfZmxhZ192YWx1ZShhc3NldF9pZCwgZmxhZy5hc191aW50NjQoKSkKICAgIGRpZyAxCiAgICBkdXAKICAgIGRpZyAyCiAgICBjYWxsc3ViIF9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfdmFsdWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzU4LTc1OQogICAgLy8gIyBVcGRhdGUgTWV0YWRhdGEgSGVhZGVyCiAgICAvLyBzZWxmLl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdChhc3NldF9pZCkKICAgIGNhbGxzdWIgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0CgphcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTAKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgcHVzaGludCA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOC0xMTEKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc2MS03NjIKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGlmIHNlbGYuX2lzX2FyYzU0X2J1cm5hYmxlKGFzc2V0X2lkKToKICAgIGJ6IGFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19hZnRlcl9pZl9lbHNlQDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzYzCiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXJjNTRfY29tcGxpYW50KGFzc2V0X2lkKSwgZXJyLkFTQV9OT1RfQVJDNTRfQ09NUExJQU5UCiAgICBkaWcgMQogICAgY2FsbHN1YiBfaXNfYXJjNTRfY29tcGxpYW50CiAgICBhc3NlcnQgLy8gVGhlIEFTQSBtdXN0IG5vdCBoYXZlIGEgY2xhd2JhY2sgYWRkcmVzcwoKYXJjODlfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX2FmdGVyX2lmX2Vsc2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X3NldF9pcnJldmVyc2libGVfZmxhZ19ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzEgLy8gMAogICAgYiBhcmM4OV9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfYm9vbF9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X3NldF9pbW11dGFibGVbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9zZXRfaW1tdXRhYmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NjUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NzctNzc4CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkdXAKICAgIGNhbGxzdWIgX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzgwLTc4MQogICAgLy8gIyBTZXQgSW1tdXRhYmxlIEZsYWcKICAgIC8vIHNlbGYuX3NldF9pcnJldmVyc2libGVfZmxhZ192YWx1ZShhc3NldF9pZCwgVUludDY0KGZsZy5JUlJfRkxHX0lNTVVUQUJMRSkpCiAgICBkdXAKICAgIHB1c2hpbnQgNwogICAgY2FsbHN1YiBfc2V0X2lycmV2ZXJzaWJsZV9mbGFnX3ZhbHVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc4My03ODQKICAgIC8vICMgVXBkYXRlIE1ldGFkYXRhIEhlYWRlcgogICAgLy8gc2VsZi5fdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQoYXNzZXRfaWQpCiAgICBjYWxsc3ViIF91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3NjUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfcGFydGlhbF91cmlbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfcGFydGlhbF91cmk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjgxOAogICAgLy8gYXJjOTBfYm94X3F1ZXJ5KEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkLCBCeXRlcygpKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBieXRlY18xIC8vIDB4CiAgICBjYWxsc3ViIGFyYzkwX2JveF9xdWVyeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4MDkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGE6CiAgICBieXRlY18xIC8vICIiCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODIxCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDEKICAgIC8vIG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpIDw9IGNvbnN0Lk1BWF9NRVRBREFUQV9TSVpFCiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludGMgNiAvLyAzMDUwNgogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODM5LTg0MgogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpIDw9IGNvbnN0Lk1BWF9NRVRBREFUQV9TSVpFCiAgICAvLyApLCBlcnIuRVhDRUVEU19NQVhfTUVUQURBVEFfU0laRQogICAgYXNzZXJ0IC8vIEludmFsaWQgTWV0YWRhdGEgc2l6ZSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo0NwogICAgLy8gcmV0dXJuIGFzYSBpbiBzZWxmLmFzc2V0X21ldGFkYXRhCiAgICBpdG9iCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODQ0CiAgICAvLyBpZiBzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNzZXRfaWQpOgogICAgYnogYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9lbHNlX2JvZHlAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDUKICAgIC8vIG1ldGFkYXRhX3NpemUgPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc3NldF9pZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgZHVwCiAgICBidXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODQ2CiAgICAvLyBmbGF0X21iciA9IFVJbnQ2NCgwKQogICAgaW50Y18xIC8vIDAKICAgIGJ1cnkgNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDcKICAgIC8vIGlmIG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpID09IG1ldGFkYXRhX3NpemU6CiAgICBkaWcgMQogICAgPT0KICAgIGJ6IGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODQ5CiAgICAvLyBkZWx0YV9zaXplID0gVUludDY0KDApCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NDgKICAgIC8vIHNpZ24gPSBVSW50NjQoZW51bXMuTUJSX0RFTFRBX05VTEwpCiAgICBkdXAKCmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfYWZ0ZXJfaWZfZWxzZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODY1CiAgICAvLyBkZWx0YV9hbW91bnQgPSBmbGF0X21iciArIGNvbnN0LkJZVEVfTUJSICogZGVsdGFfc2l6ZQogICAgcHVzaGludCA0MDAKICAgIHVuY292ZXIgMgogICAgKgogICAgZGlnIDUKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODY3CiAgICAvLyByZXR1cm4gYWJpLk1ickRlbHRhKHNpZ249YXJjNC5VSW50OChzaWduKSwgYW1vdW50PWRlbHRhX2Ftb3VudCkKICAgIHN3YXAKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4MjEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9lbHNlX2JvZHlANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODUwCiAgICAvLyBlbGlmIG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpID4gbWV0YWRhdGFfc2l6ZToKICAgIGR1cAogICAgZGlnIDMKICAgID4KICAgIGJ6IGFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODUxCiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9QT1MpCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NTIKICAgIC8vIGRlbHRhX3NpemUgPSBuZXdfbWV0YWRhdGFfc2l6ZS5hc191aW50NjQoKSAtIG1ldGFkYXRhX3NpemUKICAgIGRpZyAxCiAgICBkaWcgNAogICAgLQogICAgc3dhcAogICAgYiBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2FmdGVyX2lmX2Vsc2VAMTAKCmFyYzg5X2dldF9tZXRhZGF0YV9tYnJfZGVsdGFfZWxzZV9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg1NAogICAgLy8gc2lnbiA9IFVJbnQ2NChlbnVtcy5NQlJfREVMVEFfTkVHKQogICAgcHVzaGludCAyNTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODU1CiAgICAvLyBkZWx0YV9zaXplID0gbWV0YWRhdGFfc2l6ZSAtIG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpCiAgICBkaWcgMwogICAgZGlnIDIKICAgIC0KICAgIHN3YXAKICAgIGIgYXJjODlfZ2V0X21ldGFkYXRhX21icl9kZWx0YV9hZnRlcl9pZl9lbHNlQDEwCgphcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2Vsc2VfYm9keUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NTcKICAgIC8vIGZsYXRfbWJyID0gVUludDY0KGNvbnN0LkZMQVRfTUJSKQogICAgcHVzaGludCAyNTAwCiAgICBidXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODU4CiAgICAvLyBzaWduID0gVUludDY0KGVudW1zLk1CUl9ERUxUQV9QT1MpCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NjAtODYxCiAgICAvLyBjb25zdC5BU1NFVF9NRVRBREFUQV9CT1hfS0VZX1NJWkUKICAgIC8vICsgY29uc3QuSEVBREVSX1NJWkUKICAgIHB1c2hpbnQgNTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODYwLTg2MgogICAgLy8gY29uc3QuQVNTRVRfTUVUQURBVEFfQk9YX0tFWV9TSVpFCiAgICAvLyArIGNvbnN0LkhFQURFUl9TSVpFCiAgICAvLyArIG5ld19tZXRhZGF0YV9zaXplLmFzX3VpbnQ2NCgpCiAgICBkaWcgMgogICAgKwogICAgc3dhcAogICAgYiBhcmM4OV9nZXRfbWV0YWRhdGFfbWJyX2RlbHRhX2FmdGVyX2lmX2Vsc2VAMTAKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfY2hlY2tfbWV0YWRhdGFfZXhpc3RzW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfY2hlY2tfbWV0YWRhdGFfZXhpc3RzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4NjkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjE1CiAgICAvLyBfY3JlYXRvciwgZXhpc3RzID0gb3AuQXNzZXRQYXJhbXNHZXQuYXNzZXRfY3JlYXRvcihhc2EpCiAgICBkdXAKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBjb3ZlciAyCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDcKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgaXRvYgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojg4NC04ODcKICAgIC8vIHJldHVybiBhYmkuTWV0YWRhdGFFeGlzdGVuY2UoCiAgICAvLyAgICAgYXNhX2V4aXN0cz1zZWxmLl9hc2FfZXhpc3RzKGFzc2V0X2lkKSwKICAgIC8vICAgICBtZXRhZGF0YV9leGlzdHM9c2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzc2V0X2lkKSwKICAgIC8vICkKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMwogICAgc2V0Yml0CiAgICBpbnRjXzAgLy8gMQogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODY5CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo4ODkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwNC05MDUKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NwogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OQogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEwCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOC0xMTEKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjkwNwogICAgLy8gcmV0dXJuIHNlbGYuX2lzX2ltbXV0YWJsZShhc3NldF9pZCkgb3IgYXNzZXRfaWQubWFuYWdlciA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBibnogYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlX2Jvb2xfdHJ1ZUAzCiAgICBkdXAKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICBieiBhcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF9mYWxzZUA0CgphcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF90cnVlQDM6CiAgICBpbnRjXzAgLy8gMQoKYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6ODg5CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgphcmM4OV9pc19tZXRhZGF0YV9pbW11dGFibGVfYm9vbF9mYWxzZUA0OgogICAgaW50Y18xIC8vIDAKICAgIGIgYXJjODlfaXNfbWV0YWRhdGFfaW1tdXRhYmxlX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9pc19tZXRhZGF0YV9zaG9ydFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2lzX21ldGFkYXRhX3Nob3J0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MDkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MjQtOTI1CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYtNTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1OAogICAgLy8gbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1Ni01OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2OQogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9JREVOVElGSUVSIC0gZmxnLklEX1NIT1JULAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjctNzAKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2lkZW50aWZpZXJzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9JREVOVElGSUVSIC0gZmxnLklEX1NIT1JULAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMy0xMzYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzQKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgcHVzaGludCAzNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzUKICAgIC8vIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICBpbnRjXzIgLy8gOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzMtMTM2CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMi0xMzcKICAgIC8vIHJldHVybiBvcC5idG9pKAogICAgLy8gICAgIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgICAgIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MjctOTMwCiAgICAvLyByZXR1cm4gYWJpLk11dGFibGVGbGFnKAogICAgLy8gICAgIGZsYWc9c2VsZi5faXNfc2hvcnQoYXNzZXRfaWQpLAogICAgLy8gICAgIGxhc3RfbW9kaWZpZWRfcm91bmQ9c2VsZi5fZ2V0X2xhc3RfbW9kaWZpZWRfcm91bmQoYXNzZXRfaWQpLAogICAgLy8gKQogICAgYnl0ZWNfMiAvLyAweDAwCiAgICBpbnRjXzEgLy8gMAogICAgdW5jb3ZlciAzCiAgICBzZXRiaXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MDkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfaGVhZGVyW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX2hlYWRlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTMyCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTQ4LTk0OQogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2LTU5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTgKICAgIC8vIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYtNTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzMtNzUKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX1JFVkVSU0lCTEVfRkxBR1MsIGxlbmd0aD1jb25zdC5SRVZFUlNJQkxFX0ZMQUdTX1NJWkUKICAgIC8vICkKICAgIGRpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3My03NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OQogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIyLTEyNAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0hBU0hfU0laRQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIzCiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0hBU0hfU0laRQogICAgcHVzaGludHMgMyAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjItMTI0CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSEFTSF9TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NTcKICAgIC8vIGhhc2g9YWJpLkhhc2goc2VsZi5fZ2V0X21ldGFkYXRhX2hhc2goYXNzZXRfaWQpKSwKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGV4cGVjdGVkIGJ5dGVzIHRvIGJlIGxlbmd0aCAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzMtMTM2CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICkKICAgIGRpZyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzNAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICBwdXNoaW50IDM1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzNQogICAgLy8gbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIGludGNfMiAvLyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMy0xMzYKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTEFTVF9NT0RJRklFRF9ST1VORF9TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMyLTEzNwogICAgLy8gcmV0dXJuIG9wLmJ0b2koCiAgICAvLyAgICAgc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTEFTVF9NT0RJRklFRF9ST1VORCwKICAgIC8vICAgICAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0Ny0xNTAKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuREVQUkVDQVRFRF9CWV9TSVpFLAogICAgLy8gKQogICAgdW5jb3ZlciA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0OAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0RFUFJFQ0FURURfQlksCiAgICBwdXNoaW50IDQzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0OQogICAgLy8gbGVuZ3RoPWNvbnN0LkRFUFJFQ0FURURfQllfU0laRSwKICAgIGludGNfMiAvLyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE0Ny0xNTAKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuREVQUkVDQVRFRF9CWV9TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQ2LTE1MQogICAgLy8gcmV0dXJuIG9wLmJ0b2koCiAgICAvLyAgICAgc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfREVQUkVDQVRFRF9CWSwKICAgIC8vICAgICAgICAgbGVuZ3RoPWNvbnN0LkRFUFJFQ0FURURfQllfU0laRSwKICAgIC8vICAgICApCiAgICAvLyApCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk1MS05NjAKICAgIC8vIHJldHVybiBhYmkuTWV0YWRhdGFIZWFkZXIoCiAgICAvLyAgICAgaWRlbnRpZmllcnM9YXJjNC5CeXRlLmZyb21fYnl0ZXMoc2VsZi5fZ2V0X21ldGFkYXRhX2lkZW50aWZpZXJzKGFzc2V0X2lkKSksCiAgICAvLyAgICAgcmV2ZXJzaWJsZV9mbGFncz1hcmM0LkJ5dGUuZnJvbV9ieXRlcyhzZWxmLl9nZXRfcmV2ZXJzaWJsZV9mbGFncyhhc3NldF9pZCkpLAogICAgLy8gICAgIGlycmV2ZXJzaWJsZV9mbGFncz1hcmM0LkJ5dGUuZnJvbV9ieXRlcygKICAgIC8vICAgICAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc3NldF9pZCkKICAgIC8vICAgICApLAogICAgLy8gICAgIGhhc2g9YWJpLkhhc2goc2VsZi5fZ2V0X21ldGFkYXRhX2hhc2goYXNzZXRfaWQpKSwKICAgIC8vICAgICBsYXN0X21vZGlmaWVkX3JvdW5kPXNlbGYuX2dldF9sYXN0X21vZGlmaWVkX3JvdW5kKGFzc2V0X2lkKSwKICAgIC8vICAgICBkZXByZWNhdGVkX2J5PXNlbGYuX2dldF9kZXByZWNhdGVkX2J5KGFzc2V0X2lkKSwKICAgIC8vICkKICAgIHVuY292ZXIgNQogICAgdW5jb3ZlciA1CiAgICBjb25jYXQKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5MzIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfcGFnaW5hdGlvbltyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9wYWdpbmF0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NjIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5NzYtOTc3CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5ODAKICAgIC8vIG1ldGFkYXRhX3NpemU9YXJjNC5VSW50MTYoc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpKSwKICAgIGR1cAogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBwdXNoaW50IDE2CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDYgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMzUKICAgIC8vIG4gPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjMwCiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICBpbnRjIDUgLy8gMTAwNgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMzYKICAgIC8vIHJldHVybiBjZWlsX2RpdihudW09biwgZGVuPVVJbnQ2NChjb25zdC5QQUdFX1NJWkUpKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTozMAogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5ODIKICAgIC8vIHRvdGFsX3BhZ2VzPWFyYzQuVUludDgoc2VsZi5fZ2V0X3RvdGFsX3BhZ2VzKGFzc2V0X2lkKSksCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3OS05ODMKICAgIC8vIHJldHVybiBhYmkuUGFnaW5hdGlvbigKICAgIC8vICAgICBtZXRhZGF0YV9zaXplPWFyYzQuVUludDE2KHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzc2V0X2lkKSksCiAgICAvLyAgICAgcGFnZV9zaXplPWFyYzQuVUludDE2KGNvbnN0LlBBR0VfU0laRSksCiAgICAvLyAgICAgdG90YWxfcGFnZXM9YXJjNC5VSW50OChzZWxmLl9nZXRfdG90YWxfcGFnZXMoYXNzZXRfaWQpKSwKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgxCiAgICAvLyBwYWdlX3NpemU9YXJjNC5VSW50MTYoY29uc3QuUEFHRV9TSVpFKSwKICAgIHB1c2hieXRlcyAweDAzZWYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTc5LTk4MwogICAgLy8gcmV0dXJuIGFiaS5QYWdpbmF0aW9uKAogICAgLy8gICAgIG1ldGFkYXRhX3NpemU9YXJjNC5VSW50MTYoc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNzZXRfaWQpKSwKICAgIC8vICAgICBwYWdlX3NpemU9YXJjNC5VSW50MTYoY29uc3QuUEFHRV9TSVpFKSwKICAgIC8vICAgICB0b3RhbF9wYWdlcz1hcmM0LlVJbnQ4KHNlbGYuX2dldF90b3RhbF9wYWdlcyhhc3NldF9pZCkpLAogICAgLy8gKQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTYyCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhOgogICAgYnl0ZWNfMSAvLyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5ODUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAwMi0xMDAzCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZHVwCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMzUKICAgIC8vIG4gPSBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjMwCiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICBpbnRjIDUgLy8gMTAwNgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMzYKICAgIC8vIHJldHVybiBjZWlsX2RpdihudW09biwgZGVuPVVJbnQ2NChjb25zdC5QQUdFX1NJWkUpKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTozMAogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgZHVwCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMDUKICAgIC8vIGlmIHRvdGFsX3BhZ2VzID4gMDoKICAgIGJ6IGFyYzg5X2dldF9tZXRhZGF0YV9lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDA2CiAgICAvLyBhc3NlcnQgcGFnZS5hc191aW50NjQoKSA8IHRvdGFsX3BhZ2VzLCBlcnIuUEFHRV9JRFhfSU5WQUxJRAogICAgYnRvaQogICAgZHVwCiAgICBkaWcgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICA8CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYWdlIGluZGV4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMDcKICAgIC8vIGhhc19uZXh0X3BhZ2UgPSBwYWdlLmFzX3VpbnQ2NCgpIDwgdG90YWxfcGFnZXMgLSAxCiAgICBpbnRjXzAgLy8gMQogICAgLQogICAgZGlnIDEKICAgID4KICAgIGJ1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDA4CiAgICAvLyBwYWdlX2NvbnRlbnQgPSBzZWxmLl9nZXRfbWV0YWRhdGFfcGFnZShhc3NldF9pZCwgcGFnZS5hc191aW50NjQoKSkKICAgIGRpZyAyCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfcGFnZQoKYXJjODlfZ2V0X21ldGFkYXRhX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTMzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBkaWcgMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzQKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgcHVzaGludCAzNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzUKICAgIC8vIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICBpbnRjXzIgLy8gOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMzMtMTM2CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LkxBU1RfTU9ESUZJRURfUk9VTkRfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEzMi0xMzcKICAgIC8vIHJldHVybiBvcC5idG9pKAogICAgLy8gICAgIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgICAgIGxlbmd0aD1jb25zdC5MQVNUX01PRElGSUVEX1JPVU5EX1NJWkUsCiAgICAvLyAgICAgKQogICAgLy8gKQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDE0LTEwMTgKICAgIC8vIHJldHVybiBhYmkuUGFnaW5hdGVkTWV0YWRhdGEoCiAgICAvLyAgICAgaGFzX25leHRfcGFnZT1oYXNfbmV4dF9wYWdlLAogICAgLy8gICAgIGxhc3RfbW9kaWZpZWRfcm91bmQ9c2VsZi5fZ2V0X2xhc3RfbW9kaWZpZWRfcm91bmQoYXNzZXRfaWQpLAogICAgLy8gICAgIHBhZ2VfY29udGVudD1wYWdlX2NvbnRlbnQsCiAgICAvLyApCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICBkaWcgNgogICAgc2V0Yml0CiAgICBzd2FwCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBzd2FwCiAgICBwdXNoYnl0ZXMgMHgwMDBiCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5ODUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKYXJjODlfZ2V0X21ldGFkYXRhX2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDEwCiAgICAvLyBhc3NlcnQgcGFnZS5hc191aW50NjQoKSA9PSAwLCBlcnIuUEFHRV9JRFhfSU5WQUxJRAogICAgYnRvaQogICAgIQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGFnZSBpbmRleAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDExCiAgICAvLyBoYXNfbmV4dF9wYWdlID0gRmFsc2UKICAgIGludGNfMSAvLyAwCiAgICBidXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAxMgogICAgLy8gcGFnZV9jb250ZW50ID0gQnl0ZXMoKQogICAgYnl0ZWNfMSAvLyAweAogICAgYiBhcmM4OV9nZXRfbWV0YWRhdGFfYWZ0ZXJfaWZfZWxzZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9zbGljZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9zbGljZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAyMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwMzktMTA0MAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAyCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDQxCiAgICAvLyBhc3NlcnQgc2l6ZS5hc191aW50NjQoKSA8PSBjb25zdC5QQUdFX1NJWkUsIGVyci5FWENFRURTX1BBR0VfU0laRQogICAgYnRvaQogICAgZHVwCiAgICBpbnRjIDQgLy8gMTAwNwogICAgPD0KICAgIGFzc2VydCAvLyBQYXlsb2FkIGV4Y2VlZHMgcGFnZSBzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNDIKICAgIC8vIGFzc2VydCBvZmZzZXQuYXNfdWludDY0KCkgKyBzaXplLmFzX3VpbnQ2NCgpIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgc3dhcAogICAgYnRvaQogICAgZHVwCiAgICBkaWcgMgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDQyLTEwNDQKICAgIC8vIGFzc2VydCBvZmZzZXQuYXNfdWludDY0KCkgKyBzaXplLmFzX3VpbnQ2NCgpIDw9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKAogICAgLy8gICAgIGFzc2V0X2lkCiAgICAvLyApLCBlcnIuRVhDRUVEU19NRVRBREFUQV9TSVpFCiAgICBkaWcgMwogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIDw9CiAgICBhc3NlcnQgLy8gU2xpY2UgZXhjZWVkcyBtZXRhZGF0YSByYW5nZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDQ2CiAgICAvLyBtZXRhZGF0YV9zbGljZSA9IHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzc2V0X2lkKS5leHRyYWN0KAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNDcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldC5hc191aW50NjQoKSwgbGVuZ3RoPXNpemUuYXNfdWludDY0KCkKICAgIHB1c2hpbnQgNTEKICAgIHVuY292ZXIgMgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDQ2LTEwNDgKICAgIC8vIG1ldGFkYXRhX3NsaWNlID0gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNzZXRfaWQpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LmFzX3VpbnQ2NCgpLCBsZW5ndGg9c2l6ZS5hc191aW50NjQoKQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDIwCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJfaGFzaFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzg5X2dldF9tZXRhZGF0YV9oZWFkZXJfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA1MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNjYtMTA2NwogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA2OQogICAgLy8gcmV0dXJuIGFiaS5IYXNoKHNlbGYuX2NvbXB1dGVfaGVhZGVyX2hhc2goYXNzZXRfaWQpKQogICAgY2FsbHN1YiBfY29tcHV0ZV9oZWFkZXJfaGFzaAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIKICAgID09CiAgICBhc3NlcnQgLy8gZXhwZWN0ZWQgYnl0ZXMgdG8gYmUgbGVuZ3RoIDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwNTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5hcmM4OV9nZXRfbWV0YWRhdGFfcGFnZV9oYXNoW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX3BhZ2VfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA3MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4OC0xMDg5CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzNQogICAgLy8gbiA9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkKICAgIGRpZyAxCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjMwCiAgICAvLyByZXR1cm4gKG51bSArIChkZW4gLSAxKSkgLy8gZGVuCiAgICBpbnRjIDUgLy8gMTAwNgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMzYKICAgIC8vIHJldHVybiBjZWlsX2RpdihudW09biwgZGVuPVVJbnQ2NChjb25zdC5QQUdFX1NJWkUpKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTozMAogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDkxCiAgICAvLyBpZiB0b3RhbF9wYWdlcyA+IDA6CiAgICBkdXAKICAgIGFzc2VydCAvLyBNZXRhZGF0YSBpcyBlbXB0eQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDkyCiAgICAvLyBhc3NlcnQgcGFnZS5hc191aW50NjQoKSA8IHRvdGFsX3BhZ2VzLCBlcnIuUEFHRV9JRFhfSU5WQUxJRAogICAgc3dhcAogICAgYnRvaQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIDwKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBhZ2UgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA5NgogICAgLy8gcGFnZV9jb250ZW50ID0gc2VsZi5fZ2V0X21ldGFkYXRhX3BhZ2UoYXNzZXRfaWQsIHBhZ2UuYXNfdWludDY0KCkpCiAgICBkdXAyCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfcGFnZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDk3CiAgICAvLyBwYWdlX2hhc2ggPSBzZWxmLl9jb21wdXRlX3BhZ2VfaGFzaChhc3NldF9pZCwgcGFnZS5hc191aW50NjQoKSwgcGFnZV9jb250ZW50KQogICAgY2FsbHN1YiBfY29tcHV0ZV9wYWdlX2hhc2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA5OAogICAgLy8gcmV0dXJuIGFiaS5IYXNoKHBhZ2VfaGFzaCkKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGV4cGVjdGVkIGJ5dGVzIHRvIGJlIGxlbmd0aCAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMDcxCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX2hhc2hbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfaGFzaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEwMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMTUtMTExNgogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGR1cAogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIyCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjMKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSEFTSF9TSVpFCiAgICBwdXNoaW50cyAzIDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMi0xMjQKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0hBU0gsIGxlbmd0aD1jb25zdC5NRVRBREFUQV9IQVNIX1NJWkUKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMTgKICAgIC8vIHJldHVybiBhYmkuSGFzaChzZWxmLl9nZXRfbWV0YWRhdGFfaGFzaChhc3NldF9pZCkpCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMgogICAgPT0KICAgIGFzc2VydCAvLyBleHBlY3RlZCBieXRlcyB0byBiZSBsZW5ndGggMzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEwMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV9zdHJpbmdfYnlfa2V5W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX3N0cmluZ19ieV9rZXk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExMjAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEzOS0xMTQwCiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNDItMTE0NwogICAgLy8gIyBGZXRjaCBrZXkncyB2YWx1ZQogICAgLy8gIyDimqDvuI8gV0FSTklORzogVGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGNhdXNlIEFWTSBydW50aW1lIGVycm9yOgogICAgLy8gIyAtIFRoZSBzaG9ydCBNZXRhZGF0YSBpcyBub3QgYSB2YWxpZCBVVEYtOCBlbmNvZGVkIEpTT04gb2JqZWN0CiAgICAvLyAjIC0gVGhlIHRvcC1sZXZlbCBrZXkgZG9lcyBub3QgZXhpc3QKICAgIC8vICMgLSBUaGUgdG9wLWxldmVsIGtleSdzIHZhbHVlIGlzIG5vdCBhIEpTT04gU3RyaW5nCiAgICAvLyBvYmogPSBzZWxmLl9nZXRfc2hvcnRfbWV0YWRhdGEoYXNzZXRfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfc2hvcnRfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE0OAogICAgLy8gdmFsdWUgPSBvcC5Kc29uUmVmLmpzb25fc3RyaW5nKG9iaiwga2V5LmJ5dGVzKQogICAgc3dhcAogICAganNvbl9yZWYgSlNPTlN0cmluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTUwLTExNTEKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCB2YWx1ZS5sZW5ndGggPD0gY29uc3QuUEFHRV9TSVpFLCBlcnIuRVhDRUVEU19QQUdFX1NJWkUKICAgIGR1cAogICAgbGVuCiAgICBkdXAKICAgIGludGMgNCAvLyAxMDA3CiAgICA8PQogICAgYXNzZXJ0IC8vIFBheWxvYWQgZXhjZWVkcyBwYWdlIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEyMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5LmFyYzg5X2dldF9tZXRhZGF0YV91aW50NjRfYnlfa2V5W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjODlfZ2V0X21ldGFkYXRhX3VpbnQ2NF9ieV9rZXk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNTUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE3NC0xMTc1CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIHNlbGYuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzc2V0X2lkKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNzctMTE4MgogICAgLy8gIyBGZXRjaCBrZXkncyB2YWx1ZQogICAgLy8gIyDimqDvuI8gV0FSTklORzogVGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGNhdXNlIEFWTSBydW50aW1lIGVycm9yOgogICAgLy8gIyAtIFRoZSBzaG9ydCBNZXRhZGF0YSBpcyBub3QgYSB2YWxpZCBVVEYtOCBlbmNvZGVkIEpTT04gb2JqZWN0CiAgICAvLyAjIC0gVGhlIHRvcC1sZXZlbCBrZXkgZG9lcyBub3QgZXhpc3QKICAgIC8vICMgLSBUaGUgdG9wLWxldmVsIGtleSdzIHZhbHVlIGlzIG5vdCBhIEpTT04gVWludDY0CiAgICAvLyBvYmogPSBzZWxmLl9nZXRfc2hvcnRfbWV0YWRhdGEoYXNzZXRfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9nZXRfc2hvcnRfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE4MwogICAgLy8gdmFsdWUgPSBvcC5Kc29uUmVmLmpzb25fdWludDY0KG9iaiwga2V5LmJ5dGVzKQogICAgc3dhcAogICAganNvbl9yZWYgSlNPTlVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTU1CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGl0b2IKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX29iamVjdF9ieV9rZXlbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfb2JqZWN0X2J5X2tleToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE4NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjA2LTEyMDcKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gc2VsZi5fY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMoYXNzZXRfaWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIwOS0xMjE0CiAgICAvLyAjIEZldGNoIGtleSdzIHZhbHVlCiAgICAvLyAjIOKaoO+4jyBXQVJOSU5HOiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgY2F1c2UgQVZNIHJ1bnRpbWUgZXJyb3I6CiAgICAvLyAjIC0gVGhlIHNob3J0IE1ldGFkYXRhIGlzIG5vdCBhIHZhbGlkIFVURi04IGVuY29kZWQgSlNPTiBvYmplY3QKICAgIC8vICMgLSBUaGUgdG9wLWxldmVsIGtleSBkb2VzIG5vdCBleGlzdAogICAgLy8gIyAtIFRoZSB0b3AtbGV2ZWwga2V5J3MgdmFsdWUgaXMgbm90IGEgSlNPTiBPYmplY3QKICAgIC8vIG9iaiA9IHNlbGYuX2dldF9zaG9ydF9tZXRhZGF0YShhc3NldF9pZCkKICAgIHN3YXAKICAgIGNhbGxzdWIgX2dldF9zaG9ydF9tZXRhZGF0YQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjE1CiAgICAvLyB2YWx1ZSA9IG9wLkpzb25SZWYuanNvbl9vYmplY3Qob2JqLCBrZXkuYnl0ZXMpCiAgICBzd2FwCiAgICBqc29uX3JlZiBKU09OT2JqZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMTctMTIxOAogICAgLy8gIyBQb3N0Y29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IHZhbHVlLmxlbmd0aCA8PSBjb25zdC5QQUdFX1NJWkUsIGVyci5FWENFRURTX1BBR0VfU0laRQogICAgZHVwCiAgICBsZW4KICAgIGR1cAogICAgaW50YyA0IC8vIDEwMDcKICAgIDw9CiAgICBhc3NlcnQgLy8gUGF5bG9hZCBleGNlZWRzIHBhZ2Ugc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuYXJjODlfZ2V0X21ldGFkYXRhX2I2NF9ieXRlc19ieV9rZXlbcm91dGluZ10oKSAtPiB2b2lkOgphcmM4OV9nZXRfbWV0YWRhdGFfYjY0X2J5dGVzX2J5X2tleToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTIyMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyMzktMTI0MAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc3NldF9pZCkKICAgIGRpZyAyCiAgICBjYWxsc3ViIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjQyCiAgICAvLyBiNjRfZW5jb2RpbmcuYXNfdWludDY0KCkgPD0gZW51bXMuQjY0X1NURF9FTkNPRElORwogICAgYnRvaQogICAgZHVwCiAgICBpbnRjXzAgLy8gMQogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI0MS0xMjQzCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIGI2NF9lbmNvZGluZy5hc191aW50NjQoKSA8PSBlbnVtcy5CNjRfU1REX0VOQ09ESU5HCiAgICAvLyApLCBlcnIuQjY0X0VOQ09ESU5HX0lOVkFMSUQKICAgIGFzc2VydCAvLyBJbnZhbGlkIGJhc2U2NCBlbmNvZGluZywgbXVzdCBiZSAwIChVUkwgc2FmZSkgb3IgMSAoU3RkKQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjQ1LTEyNTAKICAgIC8vICMgRmV0Y2gga2V5J3MgdmFsdWUKICAgIC8vICMg4pqg77iPIFdBUk5JTkc6IFRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBjYXVzZSBBVk0gcnVudGltZSBlcnJvcjoKICAgIC8vICMgLSBUaGUgc2hvcnQgTWV0YWRhdGEgaXMgbm90IGEgdmFsaWQgVVRGLTggZW5jb2RlZCBKU09OIG9iamVjdAogICAgLy8gIyAtIFRoZSB0b3AtbGV2ZWwga2V5IGRvZXMgbm90IGV4aXN0CiAgICAvLyAjIC0gVGhlIHRvcC1sZXZlbCBrZXkncyB2YWx1ZSBpcyBub3QgYSBKU09OIFN0cmluZwogICAgLy8gb2JqID0gc2VsZi5fZ2V0X3Nob3J0X21ldGFkYXRhKGFzc2V0X2lkKQogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIF9nZXRfc2hvcnRfbWV0YWRhdGEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI1MQogICAgLy8gdmFsdWUgPSBvcC5Kc29uUmVmLmpzb25fc3RyaW5nKG9iaiwga2V5LmJ5dGVzKQogICAgdW5jb3ZlciAyCiAgICBqc29uX3JlZiBKU09OU3RyaW5nCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNTMtMTI1NwogICAgLy8gIyBEZWNvZGUgdmFsdWUKICAgIC8vICMg4pqg77iPIFdBUk5JTkc6IFRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBjYXVzZSBBVk0gcnVudGltZSBlcnJvcjoKICAgIC8vICMgLSBUaGUgdG9wLWxldmVsIGtleSdzIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGJhc2U2NC1lbmNvZGluZyBzdHJpbmcgZm9yCiAgICAvLyAjIHRoZSBjaG9zZW4gZW5jb2RpbmcuCiAgICAvLyBpZiBiNjRfZW5jb2RpbmcuYXNfdWludDY0KCkgPT0gZW51bXMuQjY0X1VSTF9FTkNPRElORzoKICAgIGJueiBhcmM4OV9nZXRfbWV0YWRhdGFfYjY0X2J5dGVzX2J5X2tleV9lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjU4CiAgICAvLyBkZWNvZGVkX3ZhbHVlID0gb3AuYmFzZTY0X2RlY29kZShvcC5CYXNlNjQuVVJMRW5jb2RpbmcsIHZhbHVlKQogICAgYmFzZTY0X2RlY29kZSBVUkxFbmNvZGluZwoKYXJjODlfZ2V0X21ldGFkYXRhX2I2NF9ieXRlc19ieV9rZXlfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjYyLTEyNjMKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBkZWNvZGVkX3ZhbHVlLmxlbmd0aCA8PSBjb25zdC5QQUdFX1NJWkUsIGVyci5FWENFRURTX1BBR0VfU0laRQogICAgZHVwCiAgICBsZW4KICAgIGR1cAogICAgaW50YyA0IC8vIDEwMDcKICAgIDw9CiAgICBhc3NlcnQgLy8gUGF5bG9hZCBleGNlZWRzIHBhZ2Ugc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjIyCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzg5X2dldF9tZXRhZGF0YV9iNjRfYnl0ZXNfYnlfa2V5X2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjYwCiAgICAvLyBkZWNvZGVkX3ZhbHVlID0gb3AuYmFzZTY0X2RlY29kZShvcC5CYXNlNjQuU3RkRW5jb2RpbmcsIHZhbHVlKQogICAgYmFzZTY0X2RlY29kZSBTdGRFbmNvZGluZwogICAgYiBhcmM4OV9nZXRfbWV0YWRhdGFfYjY0X2J5dGVzX2J5X2tleV9hZnRlcl9pZl9lbHNlQDQKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkud2l0aGRyYXdfYmFsYW5jZV9leGNlc3Nbcm91dGluZ10oKSAtPiB2b2lkOgp3aXRoZHJhd19iYWxhbmNlX2V4Y2VzczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI4MwogICAgLy8gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI4NAogICAgLy8gLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI4My0xMjg0CiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UKICAgIC8vIC0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMjg2LTEyODkKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1HbG9iYWwuY3JlYXRvcl9hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1leGNlc3NfYmFsYW5jZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI4NwogICAgLy8gcmVjZWl2ZXI9R2xvYmFsLmNyZWF0b3JfYWRkcmVzcywKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI4NgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18wIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18xIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyODYtMTI4OQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPUdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50PWV4Y2Vzc19iYWxhbmNlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3NAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9zZXRfaXJyZXZlcnNpYmxlX2ZsYWdfdmFsdWUoYXNhOiB1aW50NjQsIGZsYWc6IHVpbnQ2NCkgLT4gdm9pZDoKX3NldF9pcnJldmVyc2libGVfZmxhZ192YWx1ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEzCiAgICAvLyBkZWYgX3NldF9pcnJldmVyc2libGVfZmxhZ192YWx1ZShzZWxmLCBhc2E6IEFzc2V0LCBmbGFnOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTcKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTkKICAgIC8vIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk3LTEwMAogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5JUlJFVkVSU0lCTEVfRkxBR1NfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjExNgogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICBwdXNoaW50IDcKICAgIGZyYW1lX2RpZyAtMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTcKICAgIC8vIFRydWUsICAjIG5vcWE6IEZCVDAwMwogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTE0LTExOAogICAgLy8gdXBkYXRlZF9mbGFncyA9IG9wLnNldGJpdF9ieXRlcygKICAgIC8vICAgICBzZWxmLl9nZXRfaXJyZXZlcnNpYmxlX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICAvLyAgICAgVHJ1ZSwgICMgbm9xYTogRkJUMDAzCiAgICAvLyApCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA0CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfSVJSRVZFUlNJQkxFX0ZMQUdTLCB2YWx1ZT1mbGFncwogICAgaW50Y18zIC8vIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTAzLTEwNQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsIHZhbHVlPWZsYWdzCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9nZXRfbWV0YWRhdGFfc2l6ZShhc2E6IHVpbnQ2NCkgLT4gdWludDY0OgpfZ2V0X21ldGFkYXRhX3NpemU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE1OQogICAgLy8gZGVmIF9nZXRfbWV0YWRhdGFfc2l6ZShzZWxmLCBhc2E6IEFzc2V0KSAtPiBVSW50NjQ6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTYwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5sZW5ndGggLSBjb25zdC5IRUFERVJfU0laRQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gY2hlY2sgQm94IGV4aXN0cwogICAgcHVzaGludCA1MQogICAgLQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9hcHBlbmRfcGF5bG9hZChhc2E6IHVpbnQ2NCwgcGF5bG9hZDogYnl0ZXMpIC0+IHZvaWQ6Cl9hcHBlbmRfcGF5bG9hZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTYyCiAgICAvLyBkZWYgX2FwcGVuZF9wYXlsb2FkKHNlbGYsIGFzYTogQXNzZXQsIHBheWxvYWQ6IEJ5dGVzKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2MwogICAgLy8gb2xkX2Fzc2V0X21ldGFkYXRhX2JveF9zaXplID0gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5sZW5ndGgKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgZHVwCiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gY2hlY2sgQm94IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNjUKICAgIC8vIG5ld19zaXplPW9sZF9hc3NldF9tZXRhZGF0YV9ib3hfc2l6ZSArIHBheWxvYWQubGVuZ3RoCiAgICBmcmFtZV9kaWcgLTEKICAgIGxlbgogICAgZGlnIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTY0LTE2NgogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXNpemUoCiAgICAvLyAgICAgbmV3X3NpemU9b2xkX2Fzc2V0X21ldGFkYXRhX2JveF9zaXplICsgcGF5bG9hZC5sZW5ndGgKICAgIC8vICkKICAgIGRpZyAyCiAgICBzd2FwCiAgICBib3hfcmVzaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE2Ny0xNjkKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1vbGRfYXNzZXRfbWV0YWRhdGFfYm94X3NpemUsIHZhbHVlPXBheWxvYWQKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgYm94X3JlcGxhY2UKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fc2V0X21ldGFkYXRhX3BheWxvYWQoYXNhOiB1aW50NjQsIG1ldGFkYXRhX3NpemU6IHVpbnQ2NCwgcGF5bG9hZDogYnl0ZXMpIC0+IHZvaWQ6Cl9zZXRfbWV0YWRhdGFfcGF5bG9hZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjA0LTIwNgogICAgLy8gZGVmIF9zZXRfbWV0YWRhdGFfcGF5bG9hZCgKICAgIC8vICAgICBzZWxmLCBhc2E6IEFzc2V0LCBtZXRhZGF0YV9zaXplOiBVSW50NjQsIHBheWxvYWQ6IEJ5dGVzCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAzIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjA3LTIwOAogICAgLy8gIyBFcmFzZSBleGlzdGluZyBtZXRhZGF0YSBwYXlsb2FkCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlc2l6ZShuZXdfc2l6ZT1VSW50NjQoY29uc3QuSEVBREVSX1NJWkUpKQogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICBkdXAKICAgIHB1c2hpbnQgNTEKICAgIGJveF9yZXNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjEwLTIxMQogICAgLy8gIyBBcHBlbmQgcHJvdmlkZWQgcGF5bG9hZAogICAgLy8gc2VsZi5fYXBwZW5kX3BheWxvYWQoYXNhLCBwYXlsb2FkKQogICAgZnJhbWVfZGlnIC0zCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2FwcGVuZF9wYXlsb2FkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxMgogICAgLy8gYXNzZXJ0IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkgPD0gbWV0YWRhdGFfc2l6ZSwgZXJyLlBBWUxPQURfT1ZFUkZMT1cKICAgIGZyYW1lX2RpZyAtMwogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGZyYW1lX2RpZyAtMgogICAgPD0KICAgIGFzc2VydCAvLyBQYXlsb2FkIG92ZXJmbG93LCBleGNlZWRzIG1ldGFkYXRhIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjE0LTIxNQogICAgLy8gIyBBcHBlbmQgc3RhZ2VkIGV4dHJhIHBheWxvYWQgKGluIHRoZSBzYW1lIEdyb3VwLCBpZiBhbnkpCiAgICAvLyBncm91cF9zaXplID0gR2xvYmFsLmdyb3VwX3NpemUKICAgIGdsb2JhbCBHcm91cFNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjE2CiAgICAvLyBncm91cF9pbmRleCA9IFR4bi5ncm91cF9pbmRleAogICAgdHhuIEdyb3VwSW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjE3CiAgICAvLyBmb3IgaWR4IGluIHVyYW5nZShncm91cF9pbmRleCArIDEsIGdyb3VwX3NpemUpOgogICAgaW50Y18wIC8vIDEKICAgICsKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9mb3JfaGVhZGVyQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxNwogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoZ3JvdXBfaW5kZXggKyAxLCBncm91cF9zaXplKToKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9kaWcgMQogICAgPAogICAgYnogX3NldF9tZXRhZGF0YV9wYXlsb2FkX2FmdGVyX2ZvckA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4NQogICAgLy8gdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgZnJhbWVfZGlnIDIKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTg1LTE4NwogICAgLy8gdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gYW5kIHR4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIC8vIGFuZCB0eG4ub25fY29tcGxldGlvbiA9PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX2ZhbHNlQDEzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4NgogICAgLy8gYW5kIHR4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIGZyYW1lX2RpZyAyCiAgICBndHhucyBBcHBsaWNhdGlvbklECiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE4NS0xODcKICAgIC8vIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vIGFuZCB0eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkCiAgICAvLyBhbmQgdHhuLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxODcKICAgIC8vIGFuZCB0eG4ub25fY29tcGxldGlvbiA9PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIGZyYW1lX2RpZyAyCiAgICBndHhucyBPbkNvbXBsZXRpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTg1LTE4NwogICAgLy8gdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gYW5kIHR4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQKICAgIC8vIGFuZCB0eG4ub25fY29tcGxldGlvbiA9PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIGJueiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxMwogICAgaW50Y18wIC8vIDEKCl9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX21lcmdlQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTItMTk1CiAgICAvLyBzZWxmLl9pc19yZWdpc3RyeV9jYWxsKHR4bikKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9NRVRIT0RfU0VMRUNUT1JfQVJHKQogICAgLy8gPT0gYXJjNC5hcmM0X3NpZ25hdHVyZShBcmM4OUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTMKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9NRVRIT0RfU0VMRUNUT1JfQVJHKQogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMSAvLyAwCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTQKICAgIC8vID09IGFyYzQuYXJjNF9zaWduYXR1cmUoQXJjODlJbnRlcmZhY2UuYXJjODlfZXh0cmFfcGF5bG9hZCkKICAgIGJ5dGVjXzMgLy8gbWV0aG9kICJhcmM4OV9leHRyYV9wYXlsb2FkKHVpbnQ2NCxieXRlW10pdm9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTkzLTE5NAogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM0X01FVEhPRF9TRUxFQ1RPUl9BUkcpCiAgICAvLyA9PSBhcmM0LmFyYzRfc2lnbmF0dXJlKEFyYzg5SW50ZXJmYWNlLmFyYzg5X2V4dHJhX3BheWxvYWQpCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTItMTk1CiAgICAvLyBzZWxmLl9pc19yZWdpc3RyeV9jYWxsKHR4bikKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDNF9NRVRIT0RfU0VMRUNUT1JfQVJHKQogICAgLy8gPT0gYXJjNC5hcmM0X3NpZ25hdHVyZShBcmM4OUludGVyZmFjZS5hcmM4OV9leHRyYV9wYXlsb2FkKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19BU1NFVF9JRCkgPT0gb3AuaXRvYihhc2EuaWQpCiAgICBieiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9mYWxzZUAxOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxOTUKICAgIC8vIGFuZCB0eG4uYXBwX2FyZ3MoY29uc3QuQVJDODlfRVhUUkFfUEFZTE9BRF9BUkdfQVNTRVRfSUQpID09IG9wLml0b2IoYXNhLmlkKQogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMCAvLyAxCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDAKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjE5Mi0xOTUKICAgIC8vIHNlbGYuX2lzX3JlZ2lzdHJ5X2NhbGwodHhuKQogICAgLy8gYW5kIHR4bi5hcHBfYXJncyhjb25zdC5BUkM0X01FVEhPRF9TRUxFQ1RPUl9BUkcpCiAgICAvLyA9PSBhcmM0LmFyYzRfc2lnbmF0dXJlKEFyYzg5SW50ZXJmYWNlLmFyYzg5X2V4dHJhX3BheWxvYWQpCiAgICAvLyBhbmQgdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX0FTU0VUX0lEKSA9PSBvcC5pdG9iKGFzYS5pZCkKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9ib29sX2ZhbHNlQDE4CiAgICBpbnRjXzAgLy8gMQoKX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfbWVyZ2VAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIxOQogICAgLy8gaWYgc2VsZi5faXNfZXh0cmFfcGF5bG9hZF9jYWxsKGFzYSwgdHhuKToKICAgIGJ6IF9zZXRfbWV0YWRhdGFfcGF5bG9hZF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTk5LTIwMgogICAgLy8gIyBUaGlzIHN1YnJvdXRpbmUgYXNzdW1lcyB0eG4gaXMgYWxyZWFkeSB2YWxpZGF0ZWQgYXMgYW4gZXh0cmEgcGF5bG9hZCB0eG4KICAgIC8vIHJldHVybiBhcmM0LkR5bmFtaWNCeXRlcy5mcm9tX2J5dGVzKAogICAgLy8gICAgIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19QQVlMT0FEKQogICAgLy8gKS5uYXRpdmUKICAgIGZyYW1lX2RpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIwMQogICAgLy8gdHhuLmFwcF9hcmdzKGNvbnN0LkFSQzg5X0VYVFJBX1BBWUxPQURfQVJHX1BBWUxPQUQpCiAgICBpbnRjXzMgLy8gMgogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTk5LTIwMgogICAgLy8gIyBUaGlzIHN1YnJvdXRpbmUgYXNzdW1lcyB0eG4gaXMgYWxyZWFkeSB2YWxpZGF0ZWQgYXMgYW4gZXh0cmEgcGF5bG9hZCB0eG4KICAgIC8vIHJldHVybiBhcmM0LkR5bmFtaWNCeXRlcy5mcm9tX2J5dGVzKAogICAgLy8gICAgIHR4bi5hcHBfYXJncyhjb25zdC5BUkM4OV9FWFRSQV9QQVlMT0FEX0FSR19QQVlMT0FEKQogICAgLy8gKS5uYXRpdmUKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIyMgogICAgLy8gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSArIGV4dHJhX3BheWxvYWQubGVuZ3RoIDw9IG1ldGFkYXRhX3NpemUKICAgIGZyYW1lX2RpZyAtMwogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIGRpZyAxCiAgICBsZW4KICAgICsKICAgIGZyYW1lX2RpZyAtMgogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjIxLTIyMwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpICsgZXh0cmFfcGF5bG9hZC5sZW5ndGggPD0gbWV0YWRhdGFfc2l6ZQogICAgLy8gKSwgZXJyLlBBWUxPQURfT1ZFUkZMT1cKICAgIGFzc2VydCAvLyBQYXlsb2FkIG92ZXJmbG93LCBleGNlZWRzIG1ldGFkYXRhIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjI0CiAgICAvLyBzZWxmLl9hcHBlbmRfcGF5bG9hZChhc2EsIGV4dHJhX3BheWxvYWQpCiAgICBmcmFtZV9kaWcgLTMKICAgIHN3YXAKICAgIGNhbGxzdWIgX2FwcGVuZF9wYXlsb2FkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIyNgogICAgLy8gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSA8PSBtZXRhZGF0YV9zaXplCiAgICBmcmFtZV9kaWcgLTMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBmcmFtZV9kaWcgLTIKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIyNS0yMjcKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSA8PSBtZXRhZGF0YV9zaXplCiAgICAvLyApLCBlcnIuUEFZTE9BRF9PVkVSRkxPVwogICAgYXNzZXJ0IC8vIFBheWxvYWQgb3ZlcmZsb3csIGV4Y2VlZHMgbWV0YWRhdGEgc2l6ZQoKX3NldF9tZXRhZGF0YV9wYXlsb2FkX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjE3CiAgICAvLyBmb3IgaWR4IGluIHVyYW5nZShncm91cF9pbmRleCArIDEsIGdyb3VwX3NpemUpOgogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDIKICAgIGIgX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Zvcl9oZWFkZXJAMQoKX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfZmFsc2VAMTg6CiAgICBpbnRjXzEgLy8gMAogICAgYiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9tZXJnZUAxOQoKX3NldF9tZXRhZGF0YV9wYXlsb2FkX2Jvb2xfZmFsc2VAMTM6CiAgICBpbnRjXzEgLy8gMAogICAgYiBfc2V0X21ldGFkYXRhX3BheWxvYWRfYm9vbF9tZXJnZUAxNAoKX3NldF9tZXRhZGF0YV9wYXlsb2FkX2FmdGVyX2ZvckA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyMjgKICAgIC8vIGFzc2VydCBzZWxmLl9nZXRfbWV0YWRhdGFfc2l6ZShhc2EpID09IG1ldGFkYXRhX3NpemUsIGVyci5NRVRBREFUQV9TSVpFX01JU01BVENICiAgICBmcmFtZV9kaWcgLTMKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICBmcmFtZV9kaWcgLTIKICAgID09CiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgc2l6ZSBtaXNtYXRjaCwgbXVzdCBiZSBleGFjdGx5IGVxdWFsIHRvIGRlY2xhcmVkIHNpemUKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fZ2V0X21ldGFkYXRhX3BhZ2UoYXNhOiB1aW50NjQsIHBhZ2VfaW5kZXg6IHVpbnQ2NCkgLT4gYnl0ZXM6Cl9nZXRfbWV0YWRhdGFfcGFnZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjM4CiAgICAvLyBkZWYgX2dldF9tZXRhZGF0YV9wYWdlKHNlbGYsIGFzYTogQXNzZXQsIHBhZ2VfaW5kZXg6IFVJbnQ2NCkgLT4gQnl0ZXM6CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjQ2CiAgICAvLyBuID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKQogICAgZnJhbWVfZGlnIC0yCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0OAogICAgLy8gc3RhcnQgPSBwYWdlX2luZGV4ICogcHMKICAgIGZyYW1lX2RpZyAtMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNDUKICAgIC8vIHBzID0gVUludDY0KGNvbnN0LlBBR0VfU0laRSkKICAgIGludGMgNCAvLyAxMDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0OAogICAgLy8gc3RhcnQgPSBwYWdlX2luZGV4ICogcHMKICAgICoKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0OQogICAgLy8gaWYgc3RhcnQgPj0gbjoKICAgID49CiAgICBieiBfZ2V0X21ldGFkYXRhX3BhZ2VfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI1MC0yNTEKICAgIC8vICMgT3V0LW9mLXJhbmdlIHBhZ2UgKGluY2x1ZGluZyBlbXB0eSBtZXRhZGF0YSB3aXRoIHBhZ2VfaW5kZXggPiAwKQogICAgLy8gcmV0dXJuIEJ5dGVzKGIiIikKICAgIGJ5dGVjXzEgLy8gMHgKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpfZ2V0X21ldGFkYXRhX3BhZ2VfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNTMKICAgIC8vIHJlbWFpbmluZyA9IG4gLSBzdGFydAogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2RpZyAxCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjQ1CiAgICAvLyBwcyA9IFVJbnQ2NChjb25zdC5QQUdFX1NJWkUpCiAgICBpbnRjIDQgLy8gMTAwNwogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjI1CiAgICAvLyByZXR1cm4gYSBpZiBhIDwgYiBlbHNlIGIKICAgIGRpZyAxCiAgICA8CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI0NQogICAgLy8gcHMgPSBVSW50NjQoY29uc3QuUEFHRV9TSVpFKQogICAgaW50YyA0IC8vIDEwMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weToyNQogICAgLy8gcmV0dXJuIGEgaWYgYSA8IGIgZWxzZSBiCiAgICBzd2FwCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjU2CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI1NwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgc3RhcnQsIGxlbmd0aD1sZW5ndGgKICAgIHB1c2hpbnQgNTEKICAgIHVuY292ZXIgMwogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNTYtMjU4CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIHN0YXJ0LCBsZW5ndGg9bGVuZ3RoCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIGJveF9leHRyYWN0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fZ2V0X3Nob3J0X21ldGFkYXRhKGFzYTogdWludDY0KSAtPiBieXRlczoKX2dldF9zaG9ydF9tZXRhZGF0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjY1CiAgICAvLyBkZWYgX2dldF9zaG9ydF9tZXRhZGF0YShzZWxmLCBhc2E6IEFzc2V0KSAtPiBCeXRlczoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1Ni01OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU4CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2LTU5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjY5CiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2Ny03MAogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjY2CiAgICAvLyBhc3NlcnQgc2VsZi5faXNfc2hvcnQoYXNhKSwgZXJyLk1FVEFEQVRBX05PVF9TSE9SVAogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIGlzIG5vdCBzaG9ydAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjcKICAgIC8vIHJldHVybiBzZWxmLl9nZXRfc2xpY2UoYXNhLCBVSW50NjQoMCksIHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2dldF9tZXRhZGF0YV9zaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2MgogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBICsgb2Zmc2V0LCBsZW5ndGg9c2l6ZQogICAgcHVzaGludCA1MQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNjEtMjYzCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQSArIG9mZnNldCwgbGVuZ3RoPXNpemUKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI2NwogICAgLy8gcmV0dXJuIHNlbGYuX2dldF9zbGljZShhc2EsIFVJbnQ2NCgwKSwgc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5faWRlbnRpZnlfbWV0YWRhdGEoYXNhOiB1aW50NjQpIC0+IHZvaWQ6Cl9pZGVudGlmeV9tZXRhZGF0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjY5CiAgICAvLyBkZWYgX2lkZW50aWZ5X21ldGFkYXRhKHNlbGYsIGFzYTogQXNzZXQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjcwCiAgICAvLyBtZXRhZGF0YV9zaXplID0gc2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9nZXRfbWV0YWRhdGFfc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1NgogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1Ni01OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTcKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU4CiAgICAvLyBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIGludGNfMCAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2LTU5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjUzCiAgICAvLyByZXR1cm4gbWV0YWRhdGFfc2l6ZSA8PSBjb25zdC5TSE9SVF9NRVRBREFUQV9TSVpFCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgNDA5NgogICAgPD0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjczCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyNzEtMjc1CiAgICAvLyBpZGVudGlmaWVycyA9IG9wLnNldGJpdF9ieXRlcygKICAgIC8vICAgICBzZWxmLl9nZXRfbWV0YWRhdGFfaWRlbnRpZmllcnMoYXNhKSwKICAgIC8vICAgICBjb25zdC5CSVRfUklHSFRNT1NUX0lERU5USUZJRVIgLSBmbGcuSURfU0hPUlQsCiAgICAvLyAgICAgc2VsZi5faXNfc2hvcnRfbWV0YWRhdGFfc2l6ZShtZXRhZGF0YV9zaXplKSwKICAgIC8vICkKICAgIHN3YXAKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2MwogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLCB2YWx1ZT1pZGVudGlmaWVycwogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjItNjQKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsIHZhbHVlPWlkZW50aWZpZXJzCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9jb21wdXRlX2hlYWRlcl9oYXNoKGFzYTogdWludDY0KSAtPiBieXRlczoKX2NvbXB1dGVfaGVhZGVyX2hhc2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3OAogICAgLy8gZGVmIF9jb21wdXRlX2hlYWRlcl9oYXNoKHNlbGYsIGFzYTogQXNzZXQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI3OS0yODEKICAgIC8vICMgaGggPSBTSEEtNTEyLzI1NigiYXJjMDA4OS9oZWFkZXIiIHx8IEFzc2V0IElEIHx8IE1ldGFkYXRhIElkZW50aWZpZXJzCiAgICAvLyAjIHx8IFJldmVyc2libGUgRmxhZ3MgfHwgSXJyZXZlcnNpYmxlIEZsYWdzIHx8IE1ldGFkYXRhIFNpemUpCiAgICAvLyBlbnN1cmVfYnVkZ2V0KHJlcXVpcmVkX2J1ZGdldD1jb25zdC5IRUFERVJfSEFTSF9PUF9CVURHRVQpCiAgICBwdXNoaW50IDExMAogICAgaW50Y18xIC8vIDAKICAgIGNhbGxzdWIgZW5zdXJlX2J1ZGdldAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODMKICAgIC8vIGFzc2V0X2lkID0gb3AuaXRvYihhc2EuaWQpCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NTYtNTkKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX01FVEFEQVRBX0lERU5USUZJRVJTLAogICAgLy8gICAgIGxlbmd0aD1jb25zdC5NRVRBREFUQV9JREVOVElGSUVSU19TSVpFLAogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1OAogICAgLy8gbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1Ni01OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3My03NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NzQKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICBpbnRjXzAgLy8gMQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjczLTc1CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9SRVZFUlNJQkxFX0ZMQUdTLCBsZW5ndGg9Y29uc3QuUkVWRVJTSUJMRV9GTEFHU19TSVpFCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODgKICAgIC8vIHVpbnQ9c2VsZi5fZ2V0X21ldGFkYXRhX3NpemUoYXNhKSwKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weToyMAogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyODIKICAgIC8vIGRvbWFpbiA9IEJ5dGVzKGNvbnN0LkhBU0hfRE9NQUlOX0hFQURFUikKICAgIHB1c2hieXRlcyAweDYxNzI2MzMwMzAzODM5MmY2ODY1NjE2NDY1NzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjkyLTI5MwogICAgLy8gZG9tYWluCiAgICAvLyArIGFzc2V0X2lkCiAgICB1bmNvdmVyIDUKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyOTItMjk0CiAgICAvLyBkb21haW4KICAgIC8vICsgYXNzZXRfaWQKICAgIC8vICsgbWV0YWRhdGFfaWRlbnRpZmllcnMKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI5Mi0yOTUKICAgIC8vIGRvbWFpbgogICAgLy8gKyBhc3NldF9pZAogICAgLy8gKyBtZXRhZGF0YV9pZGVudGlmaWVycwogICAgLy8gKyByZXZlcnNpYmxlX2ZsYWdzCiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToyOTItMjk2CiAgICAvLyBkb21haW4KICAgIC8vICsgYXNzZXRfaWQKICAgIC8vICsgbWV0YWRhdGFfaWRlbnRpZmllcnMKICAgIC8vICsgcmV2ZXJzaWJsZV9mbGFncwogICAgLy8gKyBpcnJldmVyc2libGVfZmxhZ3MKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjI5Mi0yOTcKICAgIC8vIGRvbWFpbgogICAgLy8gKyBhc3NldF9pZAogICAgLy8gKyBtZXRhZGF0YV9pZGVudGlmaWVycwogICAgLy8gKyByZXZlcnNpYmxlX2ZsYWdzCiAgICAvLyArIGlycmV2ZXJzaWJsZV9mbGFncwogICAgLy8gKyBtZXRhZGF0YV9zaXplCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjkxLTI5OAogICAgLy8gcmV0dXJuIG9wLnNoYTUxMl8yNTYoCiAgICAvLyAgICAgZG9tYWluCiAgICAvLyAgICAgKyBhc3NldF9pZAogICAgLy8gICAgICsgbWV0YWRhdGFfaWRlbnRpZmllcnMKICAgIC8vICAgICArIHJldmVyc2libGVfZmxhZ3MKICAgIC8vICAgICArIGlycmV2ZXJzaWJsZV9mbGFncwogICAgLy8gICAgICsgbWV0YWRhdGFfc2l6ZQogICAgLy8gKQogICAgc2hhNTEyXzI1NgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9jb21wdXRlX3BhZ2VfaGFzaChhc2E6IHVpbnQ2NCwgcGFnZV9pbmRleDogdWludDY0LCBwYWdlX2NvbnRlbnQ6IGJ5dGVzKSAtPiBieXRlczoKX2NvbXB1dGVfcGFnZV9oYXNoOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMDAtMzAyCiAgICAvLyBkZWYgX2NvbXB1dGVfcGFnZV9oYXNoKAogICAgLy8gICAgIHNlbGYsIGFzYTogQXNzZXQsIHBhZ2VfaW5kZXg6IFVJbnQ2NCwgcGFnZV9jb250ZW50OiBCeXRlcwogICAgLy8gKSAtPiBCeXRlczoKICAgIHByb3RvIDMgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMDMtMzA0CiAgICAvLyAjIHBoW2ldID0gU0hBLTUxMi8yNTYoImFyYzAwODkvcGFnZSIgfHwgQXNzZXQgSUQgfHwgUGFnZSBJbmRleCB8fCBQYWdlIFNpemUgfHwgUGFnZSBDb250ZW50KQogICAgLy8gZW5zdXJlX2J1ZGdldChyZXF1aXJlZF9idWRnZXQ9Y29uc3QuUEFHRV9IQVNIX09QX0JVREdFVCkKICAgIHB1c2hpbnQgMTUwCiAgICBpbnRjXzEgLy8gMAogICAgY2FsbHN1YiBlbnN1cmVfYnVkZ2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMwNgogICAgLy8gYXNzZXRfaWQgPSBvcC5pdG9iKGFzYS5pZCkKICAgIGZyYW1lX2RpZyAtMwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2F2bV9saWJyYXJ5LnB5OjIwCiAgICAvLyByZXR1cm4gb3AuZXh0cmFjdChvcC5pdG9iKHVpbnQpLCBzdGFydCwgc2l6ZSkKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzA5CiAgICAvLyB1aW50PXBhZ2VfY29udGVudC5sZW5ndGgsIHNpemU9VUludDY0KGNvbnN0LlVJTlQxNl9TSVpFKQogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weToyMAogICAgLy8gcmV0dXJuIG9wLmV4dHJhY3Qob3AuaXRvYih1aW50KSwgc3RhcnQsIHNpemUpCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMDUKICAgIC8vIGRvbWFpbiA9IEJ5dGVzKGNvbnN0LkhBU0hfRE9NQUlOX1BBR0UpCiAgICBwdXNoYnl0ZXMgMHg2MTcyNjMzMDMwMzgzOTJmNzA2MTY3NjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzExCiAgICAvLyByZXR1cm4gb3Auc2hhNTEyXzI1Nihkb21haW4gKyBhc3NldF9pZCArIHBhZ2VfaWR4ICsgcGFnZV9zaXplICsgcGFnZV9jb250ZW50KQogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBzaGE1MTJfMjU2CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NvbXB1dGVfbWV0YWRhdGFfaGFzaChhc2E6IHVpbnQ2NCkgLT4gYnl0ZXM6Cl9jb21wdXRlX21ldGFkYXRhX2hhc2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMxMwogICAgLy8gZGVmIF9jb21wdXRlX21ldGFkYXRhX2hhc2goc2VsZiwgYXNhOiBBc3NldCkgLT4gQnl0ZXM6CiAgICBwcm90byAxIDEKICAgIGJ5dGVjXzEgLy8gIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzE3CiAgICAvLyBoaCA9IHNlbGYuX2NvbXB1dGVfaGVhZGVyX2hhc2goYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9jb21wdXRlX2hlYWRlcl9oYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjIzNQogICAgLy8gbiA9IHNlbGYuX2dldF9tZXRhZGF0YV9zaXplKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3NpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdm1fbGlicmFyeS5weTozMAogICAgLy8gcmV0dXJuIChudW0gKyAoZGVuIC0gMSkpIC8vIGRlbgogICAgaW50YyA1IC8vIDEwMDYKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MjM2CiAgICAvLyByZXR1cm4gY2VpbF9kaXYobnVtPW4sIGRlbj1VSW50NjQoY29uc3QuUEFHRV9TSVpFKSkKICAgIGludGMgNCAvLyAxMDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXZtX2xpYnJhcnkucHk6MzAKICAgIC8vIHJldHVybiAobnVtICsgKGRlbiAtIDEpKSAvLyBkZW4KICAgIC8KICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMTkKICAgIC8vIGNvbmNhdGVuYXRlZF9waCA9IEJ5dGVzKCkKICAgIGJ5dGVjXzEgLy8gMHgKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzIwCiAgICAvLyBpZiB0b3RhbF9wYWdlcyA+IDA6CiAgICBieiBfY29tcHV0ZV9tZXRhZGF0YV9oYXNoX2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMjEKICAgIC8vIGZvciBwYWdlX2luZGV4IGluIHVyYW5nZSgwLCB0b3RhbF9wYWdlcyk6CiAgICBpbnRjXzEgLy8gMAogICAgZnJhbWVfYnVyeSAwCgpfY29tcHV0ZV9tZXRhZGF0YV9oYXNoX2Zvcl9oZWFkZXJAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzIxCiAgICAvLyBmb3IgcGFnZV9pbmRleCBpbiB1cmFuZ2UoMCwgdG90YWxfcGFnZXMpOgogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2RpZyAyCiAgICA8CiAgICBieiBfY29tcHV0ZV9tZXRhZGF0YV9oYXNoX2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMjIKICAgIC8vIHBhZ2VfY29udGVudCA9IHNlbGYuX2dldF9tZXRhZGF0YV9wYWdlKGFzYSwgcGFnZV9pbmRleCkKICAgIGZyYW1lX2RpZyAtMQogICAgZnJhbWVfZGlnIDAKICAgIGR1cAogICAgY292ZXIgMgogICAgY2FsbHN1YiBfZ2V0X21ldGFkYXRhX3BhZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzIzCiAgICAvLyBwaCA9IHNlbGYuX2NvbXB1dGVfcGFnZV9oYXNoKGFzYSwgcGFnZV9pbmRleCwgcGFnZV9jb250ZW50KQogICAgZnJhbWVfZGlnIC0xCiAgICBkaWcgMgogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIF9jb21wdXRlX3BhZ2VfaGFzaAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMjQKICAgIC8vIGNvbmNhdGVuYXRlZF9waCArPSBwaAogICAgZnJhbWVfZGlnIDMKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMyMQogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKDAsIHRvdGFsX3BhZ2VzKToKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDAKICAgIGIgX2NvbXB1dGVfbWV0YWRhdGFfaGFzaF9mb3JfaGVhZGVyQDIKCl9jb21wdXRlX21ldGFkYXRhX2hhc2hfYWZ0ZXJfaWZfZWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMTQtMzE2CiAgICAvLyAjIGFtID0gU0hBLTUxMi8yNTYoImFyYzAwODkvYW0iIHx8IGhoIHx8IHBoWzBdIHx8IHBoWzFdIHx8IC4uLiB8fCBwaFt0b3RhbF9wYWdlcyAtIDFdKSBvcgogICAgLy8gIyBhbSA9IFNIQS01MTIvMjU2KCJhcmMwMDg5L2FtIiB8fCBoaCksIGlmIG5vIHBhZ2VzCiAgICAvLyBkb21haW4gPSBCeXRlcyhjb25zdC5IQVNIX0RPTUFJTl9NRVRBREFUQSkKICAgIHB1c2hieXRlcyAweDYxNzI2MzMwMzAzODM5MmY2MTZkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMyNQogICAgLy8gcmV0dXJuIG9wLnNoYTUxMl8yNTYoZG9tYWluICsgaGggKyBjb25jYXRlbmF0ZWRfcGgpCiAgICBmcmFtZV9kaWcgMQogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgMwogICAgY29uY2F0CiAgICBzaGE1MTJfMjU2CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zKGFzYTogdWludDY0LCBtZXRhZGF0YV9zaXplOiB1aW50NjQpIC0+IHZvaWQ6Cl9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMyNwogICAgLy8gZGVmIF9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnMoc2VsZiwgYXNhOiBBc3NldCwgbWV0YWRhdGFfc2l6ZTogVUludDY0KSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MTUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGZyYW1lX2RpZyAtMgogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMjgKICAgIC8vIGFzc2VydCBzZWxmLl9hc2FfZXhpc3RzKGFzYSksIGVyci5BU0FfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gVGhlIHNwZWNpZmllZCBBU0EgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzI5CiAgICAvLyBhc3NlcnQgc2VsZi5faXNfYXNhX21hbmFnZXIoYXNhKSwgZXJyLlVOQVVUSE9SSVpFRAogICAgZnJhbWVfZGlnIC0yCiAgICBjYWxsc3ViIF9pc19hc2FfbWFuYWdlcgogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZCwgbXVzdCBiZSB0aGUgQXNzZXQgTWFuYWdlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1MAogICAgLy8gcmV0dXJuIG1ldGFkYXRhX3NpemUgPD0gY29uc3QuTUFYX01FVEFEQVRBX1NJWkUKICAgIGZyYW1lX2RpZyAtMQogICAgaW50YyA2IC8vIDMwNTA2CiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMzAtMzMyCiAgICAvLyBhc3NlcnQgc2VsZi5faXNfdmFsaWRfbWF4X21ldGFkYXRhX3NpemUoCiAgICAvLyAgICAgbWV0YWRhdGFfc2l6ZQogICAgLy8gKSwgZXJyLkVYQ0VFRFNfTUFYX01FVEFEQVRBX1NJWkUKICAgIGFzc2VydCAvLyBJbnZhbGlkIE1ldGFkYXRhIHNpemUsIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHNpemUKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMoYXNhOiB1aW50NjQsIG1ldGFkYXRhX3NpemU6IHVpbnQ2NCkgLT4gdm9pZDoKX2NoZWNrX3VwZGF0ZV9wcmVjb25kaXRpb25zOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMzQKICAgIC8vIGRlZiBfY2hlY2tfdXBkYXRlX3ByZWNvbmRpdGlvbnMoc2VsZiwgYXNhOiBBc3NldCwgbWV0YWRhdGFfc2l6ZTogVUludDY0KSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMzNQogICAgLy8gc2VsZi5fY2hlY2tfYmFzZV9wcmVjb25kaXRpb25zKGFzYSwgbWV0YWRhdGFfc2l6ZSkKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9jaGVja19iYXNlX3ByZWNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDcKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozMzYKICAgIC8vIGFzc2VydCBzZWxmLl9tZXRhZGF0YV9leGlzdHMoYXNhKSwgZXJyLkFTU0VUX01FVEFEQVRBX05PVF9FWElTVAogICAgYXNzZXJ0IC8vIEFzc2V0IE1ldGFkYXRhIGRvZXMgbm90IGV4aXN0IGZvciB0aGUgc3BlY2lmaWVkIEFTQQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OAogICAgLy8gc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIGludGNfMyAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5Ny0xMDAKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0lSUkVWRVJTSUJMRV9GTEFHUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuSVJSRVZFUlNJQkxFX0ZMQUdTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxMTAKICAgIC8vIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTA4LTExMQogICAgLy8gcmV0dXJuIG9wLmdldGJpdCgKICAgIC8vICAgICBzZWxmLl9nZXRfaXJyZXZlcnNpYmxlX2ZsYWdzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9JUlJfRkxBRyAtIGZsYWcsCiAgICAvLyApCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzM3CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuX2lzX2ltbXV0YWJsZShhc2EpLCBlcnIuSU1NVVRBQkxFCiAgICAhCiAgICBhc3NlcnQgLy8gTWV0YWRhdGEgaXMgaW1tdXRhYmxlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX21ldGFkYXRhX3JlZ2lzdHJ5LmNvbnRyYWN0LkFzYU1ldGFkYXRhUmVnaXN0cnkuX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zKGFzYTogdWludDY0KSAtPiB2b2lkOgpfY2hlY2tfZXhpc3RlbmNlX3ByZWNvbmRpdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjMzOQogICAgLy8gZGVmIF9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhzZWxmLCBhc2E6IEFzc2V0KSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6MTUKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDAKICAgIC8vIGFzc2VydCBzZWxmLl9hc2FfZXhpc3RzKGFzYSksIGVyci5BU0FfTk9UX0VYSVNUCiAgICBhc3NlcnQgLy8gVGhlIHNwZWNpZmllZCBBU0EgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NDcKICAgIC8vIHJldHVybiBhc2EgaW4gc2VsZi5hc3NldF9tZXRhZGF0YQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzQxCiAgICAvLyBhc3NlcnQgc2VsZi5fbWV0YWRhdGFfZXhpc3RzKGFzYSksIGVyci5BU1NFVF9NRVRBREFUQV9OT1RfRVhJU1QKICAgIGFzc2VydCAvLyBBc3NldCBNZXRhZGF0YSBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIHNwZWNpZmllZCBBU0EKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fY2hlY2tfc2V0X2ZsYWdfcHJlY29uZGl0aW9ucyhhc2E6IHVpbnQ2NCkgLT4gdm9pZDoKX2NoZWNrX3NldF9mbGFnX3ByZWNvbmRpdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM0MwogICAgLy8gZGVmIF9jaGVja19zZXRfZmxhZ19wcmVjb25kaXRpb25zKHNlbGYsIGFzYTogQXNzZXQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzQ0CiAgICAvLyBzZWxmLl9jaGVja19leGlzdGVuY2VfcHJlY29uZGl0aW9ucyhhc2EpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2NoZWNrX2V4aXN0ZW5jZV9wcmVjb25kaXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM0NQogICAgLy8gYXNzZXJ0IHNlbGYuX2lzX2FzYV9tYW5hZ2VyKGFzYSksIGVyci5VTkFVVEhPUklaRUQKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfaXNfYXNhX21hbmFnZXIKICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQsIG11c3QgYmUgdGhlIEFzc2V0IE1hbmFnZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTcKICAgIC8vIHJldHVybiBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLmV4dHJhY3QoCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OQogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTEwCiAgICAvLyBjb25zdC5CSVRfUklHSFRNT1NUX0lSUl9GTEFHIC0gZmxhZywKICAgIGludGNfMSAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEwOC0xMTEKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X2lycmV2ZXJzaWJsZV9mbGFncyhhc2EpLAogICAgLy8gICAgIGNvbnN0LkJJVF9SSUdIVE1PU1RfSVJSX0ZMQUcgLSBmbGFnLAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM0NgogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLl9pc19pbW11dGFibGUoYXNhKSwgZXJyLklNTVVUQUJMRQogICAgIQogICAgYXNzZXJ0IC8vIE1ldGFkYXRhIGlzIGltbXV0YWJsZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmFzYV9tZXRhZGF0YV9yZWdpc3RyeS5jb250cmFjdC5Bc2FNZXRhZGF0YVJlZ2lzdHJ5Ll9lbWl0X3VwZGF0ZWRfZXZlbnQoYXNhOiB1aW50NjQsIG1ldGFkYXRhX2hhc2g6IGJ5dGVzKSAtPiB2b2lkOgpfZW1pdF91cGRhdGVkX2V2ZW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNDgKICAgIC8vIGRlZiBfZW1pdF91cGRhdGVkX2V2ZW50KHNlbGYsIGFzYTogQXNzZXQsIG1ldGFkYXRhX2hhc2g6IEJ5dGVzKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM1MgogICAgLy8gcm91bmQ9R2xvYmFsLnJvdW5kLAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM1MwogICAgLy8gdGltZXN0YW1wPUdsb2JhbC5sYXRlc3RfdGltZXN0YW1wLAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3MwogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3My03NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5Ojc0CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgaW50Y18wIC8vIDEKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo3My03NQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfUkVWRVJTSUJMRV9GTEFHUywgbGVuZ3RoPWNvbnN0LlJFVkVSU0lCTEVfRkxBR1NfU0laRQogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzU0CiAgICAvLyByZXZlcnNpYmxlX2ZsYWdzPWFyYzQuQnl0ZShvcC5idG9pKHNlbGYuX2dldF9yZXZlcnNpYmxlX2ZsYWdzKGFzYSkpKSwKICAgIGJ0b2kKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTgKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICBpbnRjXzMgLy8gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo5OQogICAgLy8gbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgaW50Y18wIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6OTctMTAwCiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9JUlJFVkVSU0lCTEVfRkxBR1MsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0LklSUkVWRVJTSUJMRV9GTEFHU19TSVpFLAogICAgLy8gKQogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzU2CiAgICAvLyBvcC5idG9pKHNlbGYuX2dldF9pcnJldmVyc2libGVfZmxhZ3MoYXNhKSkKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzU1LTM1NwogICAgLy8gaXJyZXZlcnNpYmxlX2ZsYWdzPWFyYzQuQnl0ZSgKICAgIC8vICAgICBvcC5idG9pKHNlbGYuX2dldF9pcnJldmVyc2libGVfZmxhZ3MoYXNhKSkKICAgIC8vICksCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU2LTU5CiAgICAvLyByZXR1cm4gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5leHRyYWN0KAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9JREVOVElGSUVSUywKICAgIC8vICAgICBsZW5ndGg9Y29uc3QuTUVUQURBVEFfSURFTlRJRklFUlNfU0laRSwKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjU3CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1OAogICAgLy8gbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICBpbnRjXzAgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo1Ni01OQogICAgLy8gcmV0dXJuIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkuZXh0cmFjdCgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSURFTlRJRklFUlMsCiAgICAvLyAgICAgbGVuZ3RoPWNvbnN0Lk1FVEFEQVRBX0lERU5USUZJRVJTX1NJWkUsCiAgICAvLyApCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTo2OQogICAgLy8gY29uc3QuQklUX1JJR0hUTU9TVF9JREVOVElGSUVSIC0gZmxnLklEX1NIT1JULAogICAgaW50Y18xIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6NjctNzAKICAgIC8vIHJldHVybiBvcC5nZXRiaXQoCiAgICAvLyAgICAgc2VsZi5fZ2V0X21ldGFkYXRhX2lkZW50aWZpZXJzKGFzYSksCiAgICAvLyAgICAgY29uc3QuQklUX1JJR0hUTU9TVF9JREVOVElGSUVSIC0gZmxnLklEX1NIT1JULAogICAgLy8gKQogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM1MC0zNjAKICAgIC8vIGFiaS5BcmM4OU1ldGFkYXRhVXBkYXRlZCgKICAgIC8vICAgICBhc3NldF9pZD1hc2EuaWQsCiAgICAvLyAgICAgcm91bmQ9R2xvYmFsLnJvdW5kLAogICAgLy8gICAgIHRpbWVzdGFtcD1HbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCwKICAgIC8vICAgICByZXZlcnNpYmxlX2ZsYWdzPWFyYzQuQnl0ZShvcC5idG9pKHNlbGYuX2dldF9yZXZlcnNpYmxlX2ZsYWdzKGFzYSkpKSwKICAgIC8vICAgICBpcnJldmVyc2libGVfZmxhZ3M9YXJjNC5CeXRlKAogICAgLy8gICAgICAgICBvcC5idG9pKHNlbGYuX2dldF9pcnJldmVyc2libGVfZmxhZ3MoYXNhKSkKICAgIC8vICAgICApLAogICAgLy8gICAgIGlzX3Nob3J0PXNlbGYuX2lzX3Nob3J0KGFzYSksCiAgICAvLyAgICAgaGFzaD1hYmkuSGFzaC5mcm9tX2J5dGVzKG1ldGFkYXRhX2hhc2gpLCAgIyBObyBsZW5ndGggdmFsaWRhdGlvbgogICAgLy8gKQogICAgdW5jb3ZlciA1CiAgICBpdG9iCiAgICB1bmNvdmVyIDQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgdW5jb3ZlciA0CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgYnl0ZWNfMiAvLyAweDAwCiAgICBpbnRjXzEgLy8gMAogICAgdW5jb3ZlciAzCiAgICBzZXRiaXQKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzQ5LTM2MQogICAgLy8gYXJjNC5lbWl0KAogICAgLy8gICAgIGFiaS5BcmM4OU1ldGFkYXRhVXBkYXRlZCgKICAgIC8vICAgICAgICAgYXNzZXRfaWQ9YXNhLmlkLAogICAgLy8gICAgICAgICByb3VuZD1HbG9iYWwucm91bmQsCiAgICAvLyAgICAgICAgIHRpbWVzdGFtcD1HbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCwKICAgIC8vICAgICAgICAgcmV2ZXJzaWJsZV9mbGFncz1hcmM0LkJ5dGUob3AuYnRvaShzZWxmLl9nZXRfcmV2ZXJzaWJsZV9mbGFncyhhc2EpKSksCiAgICAvLyAgICAgICAgIGlycmV2ZXJzaWJsZV9mbGFncz1hcmM0LkJ5dGUoCiAgICAvLyAgICAgICAgICAgICBvcC5idG9pKHNlbGYuX2dldF9pcnJldmVyc2libGVfZmxhZ3MoYXNhKSkKICAgIC8vICAgICAgICAgKSwKICAgIC8vICAgICAgICAgaXNfc2hvcnQ9c2VsZi5faXNfc2hvcnQoYXNhKSwKICAgIC8vICAgICAgICAgaGFzaD1hYmkuSGFzaC5mcm9tX2J5dGVzKG1ldGFkYXRhX2hhc2gpLCAgIyBObyBsZW5ndGggdmFsaWRhdGlvbgogICAgLy8gICAgICkKICAgIC8vICkKICAgIHB1c2hieXRlcyAweDhiMDM1MDg0IC8vIG1ldGhvZCAiQXJjODlNZXRhZGF0YVVwZGF0ZWQodWludDY0LHVpbnQ2NCx1aW50NjQsYnl0ZSxieXRlLGJvb2wsYnl0ZVszMl0pIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5hc2FfbWV0YWRhdGFfcmVnaXN0cnkuY29udHJhY3QuQXNhTWV0YWRhdGFSZWdpc3RyeS5fdXBkYXRlX2hlYWRlcl9leGNsdWRpbmdfZmxhZ3NfYW5kX2VtaXQoYXNhOiB1aW50NjQpIC0+IHZvaWQ6Cl91cGRhdGVfaGVhZGVyX2V4Y2x1ZGluZ19mbGFnc19hbmRfZW1pdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzYzCiAgICAvLyBkZWYgX3VwZGF0ZV9oZWFkZXJfZXhjbHVkaW5nX2ZsYWdzX2FuZF9lbWl0KHNlbGYsIGFzYTogQXNzZXQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MzY0LTM2NQogICAgLy8gIyDimqDvuI8gVGhlIHN1YnJvdXRpbmUgYXNzdW1lcyB0aGF0IE1ldGFkYXRhIEZsYWdzIGhhdmUgYWxyZWFkeSBiZWVuIHNldAogICAgLy8gc2VsZi5faWRlbnRpZnlfbWV0YWRhdGEoYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9pZGVudGlmeV9tZXRhZGF0YQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weTozNjYKICAgIC8vIG1ldGFkYXRhX2hhc2ggPSBzZWxmLl9jb21wdXRlX21ldGFkYXRhX2hhc2goYXNhKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9jb21wdXRlX21ldGFkYXRhX2hhc2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3CiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI3LTEyOQogICAgLy8gc2VsZi5hc3NldF9tZXRhZGF0YS5ib3goYXNhKS5yZXBsYWNlKAogICAgLy8gICAgIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9NRVRBREFUQV9IQVNILCB2YWx1ZT1tZXRhZGF0YV9oYXNoCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTI4CiAgICAvLyBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgdmFsdWU9bWV0YWRhdGFfaGFzaAogICAgcHVzaGludCAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjEyNy0xMjkKICAgIC8vIHNlbGYuYXNzZXRfbWV0YWRhdGEuYm94KGFzYSkucmVwbGFjZSgKICAgIC8vICAgICBzdGFydF9pbmRleD1jb25zdC5JRFhfTUVUQURBVEFfSEFTSCwgdmFsdWU9bWV0YWRhdGFfaGFzaAogICAgLy8gKQogICAgZGlnIDMKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2OAogICAgLy8gc2VsZi5fc2V0X2xhc3RfbW9kaWZpZWRfcm91bmQoYXNhLCBHbG9iYWwucm91bmQpCiAgICBnbG9iYWwgUm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfbWV0YWRhdGFfcmVnaXN0cnkvY29udHJhY3QucHk6MTQyCiAgICAvLyB2YWx1ZT1vcC5pdG9iKGxhc3RfbW9kaWZpZWRfcm91bmQpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDEKICAgIC8vIHN0YXJ0X2luZGV4PWNvbnN0LklEWF9MQVNUX01PRElGSUVEX1JPVU5ELAogICAgcHVzaGludCAzNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV9tZXRhZGF0YV9yZWdpc3RyeS9jb250cmFjdC5weToxNDAtMTQzCiAgICAvLyBzZWxmLmFzc2V0X21ldGFkYXRhLmJveChhc2EpLnJlcGxhY2UoCiAgICAvLyAgICAgc3RhcnRfaW5kZXg9Y29uc3QuSURYX0xBU1RfTU9ESUZJRURfUk9VTkQsCiAgICAvLyAgICAgdmFsdWU9b3AuaXRvYihsYXN0X21vZGlmaWVkX3JvdW5kKSwKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX21ldGFkYXRhX3JlZ2lzdHJ5L2NvbnRyYWN0LnB5OjM2OQogICAgLy8gc2VsZi5fZW1pdF91cGRhdGVkX2V2ZW50KGFzYSwgbWV0YWRhdGFfaGFzaCkKICAgIGZyYW1lX2RpZyAtMQogICAgc3dhcAogICAgY2FsbHN1YiBfZW1pdF91cGRhdGVkX2V2ZW50CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX3ZhbGlkYXRpb24uQXNhVmFsaWRhdGlvbi5faXNfYXNhX21hbmFnZXIoYXNhOiB1aW50NjQpIC0+IHVpbnQ2NDoKX2lzX2FzYV9tYW5hZ2VyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FzYV92YWxpZGF0aW9uLnB5OjE4CiAgICAvLyBkZWYgX2lzX2FzYV9tYW5hZ2VyKHNlbGYsIGFzYTogQXNzZXQpIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weToxOQogICAgLy8gcmV0dXJuIFR4bi5zZW5kZXIgPT0gYXNhLm1hbmFnZXIKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgID09CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuYXNhX3ZhbGlkYXRpb24uQXNhVmFsaWRhdGlvbi5faXNfYXJjNTRfY29tcGxpYW50KGFzYTogdWludDY0KSAtPiB1aW50NjQ6Cl9pc19hcmM1NF9jb21wbGlhbnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6NDAKICAgIC8vIGRlZiBfaXNfYXJjNTRfY29tcGxpYW50KHNlbGYsIGFzYTogQXNzZXQpIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTo0MQogICAgLy8gY2xhd2JhY2ssIGV4aXN0cyA9IG9wLkFzc2V0UGFyYW1zR2V0LmFzc2V0X2NsYXdiYWNrKGFzYSkKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENsYXdiYWNrCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXNhX3ZhbGlkYXRpb24ucHk6NDIKICAgIC8vIHJldHVybiBleGlzdHMgYW5kIGNsYXdiYWNrID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGJ6IF9pc19hcmM1NF9jb21wbGlhbnRfYm9vbF9mYWxzZUAzCiAgICBmcmFtZV9kaWcgMAogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgYnogX2lzX2FyYzU0X2NvbXBsaWFudF9ib29sX2ZhbHNlQDMKICAgIGludGNfMCAvLyAxCgpfaXNfYXJjNTRfY29tcGxpYW50X2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hc2FfdmFsaWRhdGlvbi5weTo0MgogICAgLy8gcmV0dXJuIGV4aXN0cyBhbmQgY2xhd2JhY2sgPT0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgc3dhcAogICAgcmV0c3ViCgpfaXNfYXJjNTRfY29tcGxpYW50X2Jvb2xfZmFsc2VAMzoKICAgIGludGNfMSAvLyAwCiAgICBiIF9pc19hcmM1NF9jb21wbGlhbnRfYm9vbF9tZXJnZUA0Cg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEyCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMQogICAgcmV0dXJuCg=="}, "sourceInfo": {"approval": {"pcOffsetMethod": "cblocks", "sourceInfo": [{"pc": [941], "errorMessage": "ASA Metadata Hash (am) does not match the computed hash"}, {"pc": [656], "errorMessage": "Asset Metadata already exists for the specified ASA"}, {"pc": [1513, 1640, 3399, 3424], "errorMessage": "Asset Metadata does not exist for the specified ASA"}, {"pc": [853], "errorMessage": "Invalid ARC-3 parameters (name or URL)"}, {"pc": [916], "errorMessage": "Invalid ARC-89 partial URI"}, {"pc": [964, 1319], "errorMessage": "Invalid MBR Delta amount"}, {"pc": [663, 1277], "errorMessage": "Invalid MBR Delta receiver, must be the ASA Metadata Registry"}, {"pc": [1895, 3380], "errorMessage": "Invalid Metadata size, exceeds maximum allowed size"}, {"pc": [1269], "errorMessage": "Invalid Metadata size, must be larger than the current size"}, {"pc": [1124], "errorMessage": "Invalid Metadata size, must be smaller than or equal to the current size"}, {"pc": [2759], "errorMessage": "Invalid base64 encoding, must be 0 (URL safe) or 1 (Std)"}, {"pc": [1690, 1771], "errorMessage": "Invalid flag index"}, {"pc": [1449], "errorMessage": "Invalid new ASA Metadata Registry ID, must be different from current"}, {"pc": [2304, 2359, 2510], "errorMessage": "Invalid page index"}, {"pc": [2503], "errorMessage": "Metadata is empty"}, {"pc": [1528, 3406, 3449], "errorMessage": "Metadata is immutable"}, {"pc": [3109], "errorMessage": "Metadata is not short"}, {"pc": [1152, 1305, 3039], "errorMessage": "Metadata size mismatch, must be exactly equal to declared size"}, {"pc": [783], "errorMessage": "Must be flagged as immutable"}, {"pc": [1628], "errorMessage": "No payload head call in Group"}, {"pc": [2402, 2604, 2704, 2781], "errorMessage": "Payload exceeds page size"}, {"pc": [2907, 2998, 3013], "errorMessage": "Payload overflow, exceeds metadata size"}, {"pc": [1389, 2415], "errorMessage": "Slice exceeds metadata range"}, {"pc": [870, 1817], "errorMessage": "The ASA must not have a clawback address"}, {"pc": [276], "errorMessage": "The deployer address is not trusted"}, {"pc": [1634, 3368, 3417], "errorMessage": "The specified ASA does not exist"}, {"pc": [1534, 1644, 3374, 3439], "errorMessage": "Unauthorized, must be the Asset Manager"}, {"pc": [671, 953, 1129, 1157, 1282, 1310, 1539, 1551, 2803, 2808], "errorMessage": "account funded"}, {"pc": [734, 835, 841, 901, 1191, 2054, 3578], "errorMessage": "asset exists"}, {"pc": [2854, 2867], "errorMessage": "check Box exists"}, {"pc": [2157, 2462, 2523, 2554], "errorMessage": "expected bytes to be length 32"}, {"pc": [605, 1096, 1230, 1351, 1617, 2575, 2631, 2675, 2731], "errorMessage": "invalid array length header"}, {"pc": [1672], "errorMessage": "invalid number of bytes for arc4.bool"}, {"pc": [612, 1103, 1237, 1358, 1623, 2582, 2638, 2682, 2738], "errorMessage": "invalid number of bytes for arc4.dynamic_array<arc4.uint8>"}, {"pc": [599, 1090, 1224, 1345, 1887, 2383, 2391], "errorMessage": "invalid number of bytes for arc4.uint16"}, {"pc": [569, 1080, 1215, 1335, 1429, 1438, 1502, 1610, 1654, 1741, 1831, 1877, 2001, 2035, 2084, 2124, 2203, 2264, 2374, 2448, 2476, 2537, 2568, 2624, 2668, 2724], "errorMessage": "invalid number of bytes for arc4.uint64"}, {"pc": [581, 591, 1664, 1751, 2276, 2485, 2749], "errorMessage": "invalid number of bytes for arc4.uint8"}, {"pc": [1169, 1937, 2219, 2238, 3471, 3486], "errorMessage": "overflow"}, {"pc": [633, 1250], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {"TRUSTED_DEPLOYER": {"type": "address"}, "ARC90_NETAUTH": {"type": "AVMBytes"}}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class MbrDelta:
    """Struct for MbrDelta"""
    sign: int
    amount: int

@dataclasses.dataclass(frozen=True)
class MetadataExistence:
    """Struct for MetadataExistence"""
    asa_exists: bool
    metadata_exists: bool

@dataclasses.dataclass(frozen=True)
class MetadataHeader:
    """Struct for MetadataHeader"""
    identifiers: int
    reversible_flags: int
    irreversible_flags: int
    hash: bytes
    last_modified_round: int
    deprecated_by: int

@dataclasses.dataclass(frozen=True)
class MutableFlag:
    """Struct for MutableFlag"""
    flag: bool
    last_modified_round: int

@dataclasses.dataclass(frozen=True)
class PaginatedMetadata:
    """Struct for PaginatedMetadata"""
    has_next_page: bool
    last_modified_round: int
    page_content: bytes

@dataclasses.dataclass(frozen=True)
class Pagination:
    """Struct for Pagination"""
    metadata_size: int
    page_size: int
    total_pages: int

@dataclasses.dataclass(frozen=True)
class RegistryParameters:
    """Struct for RegistryParameters"""
    key_size: int
    header_size: int
    max_metadata_size: int
    short_metadata_size: int
    page_size: int
    first_payload_max_size: int
    extra_payload_max_size: int
    replace_payload_max_size: int
    flat_mbr: int
    byte_mbr: int


@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89CreateMetadataArgs:
    """Dataclass for arc89_create_metadata arguments"""
    asset_id: int
    reversible_flags: int
    irreversible_flags: int
    metadata_size: int
    payload: bytes | str
    mbr_delta_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataArgs:
    """Dataclass for arc89_replace_metadata arguments"""
    asset_id: int
    metadata_size: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataLargerArgs:
    """Dataclass for arc89_replace_metadata_larger arguments"""
    asset_id: int
    metadata_size: int
    payload: bytes | str
    mbr_delta_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ReplaceMetadataSliceArgs:
    """Dataclass for arc89_replace_metadata_slice arguments"""
    asset_id: int
    offset: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_replace_metadata_slice(uint64,uint16,byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89MigrateMetadataArgs:
    """Dataclass for arc89_migrate_metadata arguments"""
    asset_id: int
    new_registry_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_migrate_metadata(uint64,uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89DeleteMetadataArgs:
    """Dataclass for arc89_delete_metadata arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_delete_metadata(uint64)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89ExtraPayloadArgs:
    """Dataclass for arc89_extra_payload arguments"""
    asset_id: int
    payload: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_extra_payload(uint64,byte[])void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetReversibleFlagArgs:
    """Dataclass for arc89_set_reversible_flag arguments"""
    asset_id: int
    flag: int
    value: bool

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_reversible_flag(uint64,uint8,bool)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetIrreversibleFlagArgs:
    """Dataclass for arc89_set_irreversible_flag arguments"""
    asset_id: int
    flag: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_irreversible_flag(uint64,uint8)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89SetImmutableArgs:
    """Dataclass for arc89_set_immutable arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_set_immutable(uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataMbrDeltaArgs:
    """Dataclass for arc89_get_metadata_mbr_delta arguments"""
    asset_id: int
    new_metadata_size: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89CheckMetadataExistsArgs:
    """Dataclass for arc89_check_metadata_exists arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_check_metadata_exists(uint64)(bool,bool)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89IsMetadataImmutableArgs:
    """Dataclass for arc89_is_metadata_immutable arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_is_metadata_immutable(uint64)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89IsMetadataShortArgs:
    """Dataclass for arc89_is_metadata_short arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_is_metadata_short(uint64)(bool,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHeaderArgs:
    """Dataclass for arc89_get_metadata_header arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataPaginationArgs:
    """Dataclass for arc89_get_metadata_pagination arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataArgs:
    """Dataclass for arc89_get_metadata arguments"""
    asset_id: int
    page: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataSliceArgs:
    """Dataclass for arc89_get_metadata_slice arguments"""
    asset_id: int
    offset: int
    size: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHeaderHashArgs:
    """Dataclass for arc89_get_metadata_header_hash arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_header_hash(uint64)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataPageHashArgs:
    """Dataclass for arc89_get_metadata_page_hash arguments"""
    asset_id: int
    page: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_page_hash(uint64,uint8)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataHashArgs:
    """Dataclass for arc89_get_metadata_hash arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_hash(uint64)byte[32]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataStringByKeyArgs:
    """Dataclass for arc89_get_metadata_string_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_string_by_key(uint64,string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataUint64ByKeyArgs:
    """Dataclass for arc89_get_metadata_uint64_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_uint64_by_key(uint64,string)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataObjectByKeyArgs:
    """Dataclass for arc89_get_metadata_object_by_key arguments"""
    asset_id: int
    key: str

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_object_by_key(uint64,string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc89GetMetadataB64BytesByKeyArgs:
    """Dataclass for arc89_get_metadata_b64_bytes_by_key arguments"""
    asset_id: int
    key: str
    b64_encoding: int

    @property
    def abi_method_signature(self) -> str:
        return "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]"


class AsaMetadataRegistryParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }))

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_migrate_metadata(uint64,uint64)void",
            "args": method_args,
        }))

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }))

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }))

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }))

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }))

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint8,uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }))

    def arc89_get_metadata_partial_uri(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_partial_uri()string",
        }))

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }))

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }))

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }))

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }))

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }))

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }))

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class AsaMetadataRegistryCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }))

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_migrate_metadata(uint64,uint64)void",
            "args": method_args,
        }))

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }))

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }))

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }))

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }))

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint8,uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }))

    def arc89_get_metadata_partial_uri(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_partial_uri()string",
        }))

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }))

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }))

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }))

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)",
            "args": method_args,
        }))

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }))

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }))

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }))

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }))

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }))

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }))

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class AsaMetadataRegistrySend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_migrate_metadata(uint64,uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_extra_payload(uint64,byte[])void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_irreversible_flag(uint64,uint8)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_set_immutable(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[RegistryParameters]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_registry_parameters()(uint8,uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(RegistryParameters, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[RegistryParameters], parsed_response)

    def arc89_get_metadata_partial_uri(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_partial_uri()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MbrDelta]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MbrDelta, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MbrDelta], parsed_response)

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MetadataExistence]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MetadataExistence, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MetadataExistence], parsed_response)

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_immutable(uint64)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MutableFlag]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MutableFlag, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MutableFlag], parsed_response)

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[MetadataHeader]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(MetadataHeader, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[MetadataHeader], parsed_response)

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[Pagination]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(Pagination, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[Pagination], parsed_response)

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[PaginatedMetadata]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(PaginatedMetadata, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[PaginatedMetadata], parsed_response)

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_hash(uint64)byte[32]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_string_by_key(uint64,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_object_by_key(uint64,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class AsaMetadataRegistryState:
    """Methods to access state for the current AsaMetadataRegistry app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def asset_metadata(self) -> "_MapState[int, bytes]":
        """Get values from the asset_metadata map in box state"""
        return _MapState(
            self.app_client.state.box,
            "asset_metadata",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class AsaMetadataRegistryClient:
    """Client for interacting with AsaMetadataRegistry smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = AsaMetadataRegistryParams(self.app_client)
        self.create_transaction = AsaMetadataRegistryCreateTransactionParams(self.app_client)
        self.send = AsaMetadataRegistrySend(self.app_client)
        self.state = AsaMetadataRegistryState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AsaMetadataRegistryClient":
        return AsaMetadataRegistryClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "AsaMetadataRegistryComposer":
        return AsaMetadataRegistryComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_replace_metadata_slice(uint64,uint16,byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_migrate_metadata(uint64,uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_delete_metadata(uint64)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_extra_payload(uint64,byte[])void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_reversible_flag(uint64,uint8,bool)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_irreversible_flag(uint64,uint8)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_set_immutable(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_registry_parameters()(uint8,uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> RegistryParameters | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_partial_uri()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MbrDelta | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_check_metadata_exists(uint64)(bool,bool)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MetadataExistence | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_is_metadata_immutable(uint64)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_is_metadata_short(uint64)(bool,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MutableFlag | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> MetadataHeader | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> Pagination | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])"],
        return_value: algokit_utils.ABIReturn | None
    ) -> PaginatedMetadata | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_slice(uint64,uint16,uint16)byte[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_header_hash(uint64)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_page_hash(uint64,uint8)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_hash(uint64)byte[32]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_string_by_key(uint64,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_uint64_by_key(uint64,string)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_object_by_key(uint64,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["extra_resources()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["withdraw_balance_excess()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | MbrDelta | MetadataExistence | MetadataHeader | MutableFlag | None | PaginatedMetadata | Pagination | RegistryParameters | bool | bytes | int | str:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class AsaMetadataRegistryBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating AsaMetadataRegistry contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class AsaMetadataRegistryFactory(algokit_utils.TypedAppFactoryProtocol[AsaMetadataRegistryBareCallCreateParams, None, None]):
    """Factory for deploying and managing AsaMetadataRegistryClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = AsaMetadataRegistryFactoryParams(self.app_factory)
        self.create_transaction = AsaMetadataRegistryFactoryCreateTransaction(self.app_factory)
        self.send = AsaMetadataRegistryFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: AsaMetadataRegistryBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[AsaMetadataRegistryClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return AsaMetadataRegistryClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AsaMetadataRegistryClient:
        """Get an app client by creator address and name"""
        return AsaMetadataRegistryClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AsaMetadataRegistryClient:
        """Get an app client by app ID"""
        return AsaMetadataRegistryClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class AsaMetadataRegistryFactoryParams:
    """Parameters for creating transactions for AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactoryCreateParams(app_factory)
        self.update = AsaMetadataRegistryFactoryUpdateParams(app_factory)
        self.delete = AsaMetadataRegistryFactoryDeleteParams(app_factory)

class AsaMetadataRegistryFactoryCreateParams:
    """Parameters for 'create' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_replace_metadata_slice(uint64,uint16,byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_replace_metadata_slice(uint64,uint16,byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_migrate_metadata(uint64,uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_migrate_metadata(uint64,uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_delete_metadata(uint64)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_delete_metadata(uint64)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_extra_payload(uint64,byte[])void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_extra_payload(uint64,byte[])void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_reversible_flag(uint64,uint8,bool)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_reversible_flag(uint64,uint8,bool)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_irreversible_flag(uint64,uint8)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_irreversible_flag(uint64,uint8)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_set_immutable(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_set_immutable(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_registry_parameters(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_registry_parameters()(uint8,uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_registry_parameters()(uint8,uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_partial_uri(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_partial_uri()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_partial_uri()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_check_metadata_exists(uint64)(bool,bool) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_check_metadata_exists(uint64)(bool,bool)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_is_metadata_immutable(uint64)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_is_metadata_immutable(uint64)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_is_metadata_short(uint64)(bool,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_is_metadata_short(uint64)(bool,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata(uint64,uint8)(bool,uint64,byte[]) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_slice(uint64,uint16,uint16)byte[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_header_hash(uint64)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_header_hash(uint64)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_page_hash(uint64,uint8)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_page_hash(uint64,uint8)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_hash(uint64)byte[32] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_hash(uint64)byte[32]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_string_by_key(uint64,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_string_by_key(uint64,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_uint64_by_key(uint64,string)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_uint64_by_key(uint64,string)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_object_by_key(uint64,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_object_by_key(uint64,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def extra_resources(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the extra_resources()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "extra_resources()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def withdraw_balance_excess(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the withdraw_balance_excess()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "withdraw_balance_excess()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class AsaMetadataRegistryFactoryUpdateParams:
    """Parameters for 'update' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class AsaMetadataRegistryFactoryDeleteParams:
    """Parameters for 'delete' operations of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class AsaMetadataRegistryFactoryCreateTransaction:
    """Create transactions for AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactoryCreateTransactionCreate(app_factory)


class AsaMetadataRegistryFactoryCreateTransactionCreate:
    """Create new instances of AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class AsaMetadataRegistryFactorySend:
    """Send calls to AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AsaMetadataRegistryFactorySendCreate(app_factory)


class AsaMetadataRegistryFactorySendCreate:
    """Send create calls to AsaMetadataRegistry contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[AsaMetadataRegistryClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return AsaMetadataRegistryClient(result[0]), result[1]


class AsaMetadataRegistryComposer:
    """Composer for creating transaction groups for AsaMetadataRegistry contract calls"""

    def __init__(self, client: "AsaMetadataRegistryClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def arc89_create_metadata(
        self,
        args: tuple[int, int, int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89CreateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_create_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_create_metadata(uint64,byte,byte,uint16,byte[],pay)(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata(uint64,uint16,byte[])(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata_larger(
        self,
        args: tuple[int, int, bytes | str, algokit_utils.AppMethodCallTransactionArgument] | Arc89ReplaceMetadataLargerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata_larger(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata_larger(uint64,uint16,byte[],pay)(uint8,uint64)", v
            )
        )
        return self

    def arc89_replace_metadata_slice(
        self,
        args: tuple[int, int, bytes | str] | Arc89ReplaceMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_replace_metadata_slice(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_replace_metadata_slice(uint64,uint16,byte[])void", v
            )
        )
        return self

    def arc89_migrate_metadata(
        self,
        args: tuple[int, int] | Arc89MigrateMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_migrate_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_migrate_metadata(uint64,uint64)void", v
            )
        )
        return self

    def arc89_delete_metadata(
        self,
        args: tuple[int] | Arc89DeleteMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_delete_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_delete_metadata(uint64)(uint8,uint64)", v
            )
        )
        return self

    def arc89_extra_payload(
        self,
        args: tuple[int, bytes | str] | Arc89ExtraPayloadArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_extra_payload(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_extra_payload(uint64,byte[])void", v
            )
        )
        return self

    def arc89_set_reversible_flag(
        self,
        args: tuple[int, int, bool] | Arc89SetReversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_reversible_flag(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_reversible_flag(uint64,uint8,bool)void", v
            )
        )
        return self

    def arc89_set_irreversible_flag(
        self,
        args: tuple[int, int] | Arc89SetIrreversibleFlagArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_irreversible_flag(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_irreversible_flag(uint64,uint8)void", v
            )
        )
        return self

    def arc89_set_immutable(
        self,
        args: tuple[int] | Arc89SetImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_set_immutable(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_set_immutable(uint64)void", v
            )
        )
        return self

    def arc89_get_metadata_registry_parameters(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_registry_parameters(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_registry_parameters()(uint8,uint16,uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_partial_uri(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_partial_uri(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_partial_uri()string", v
            )
        )
        return self

    def arc89_get_metadata_mbr_delta(
        self,
        args: tuple[int, int] | Arc89GetMetadataMbrDeltaArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_mbr_delta(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_mbr_delta(uint64,uint16)(uint8,uint64)", v
            )
        )
        return self

    def arc89_check_metadata_exists(
        self,
        args: tuple[int] | Arc89CheckMetadataExistsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_check_metadata_exists(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_check_metadata_exists(uint64)(bool,bool)", v
            )
        )
        return self

    def arc89_is_metadata_immutable(
        self,
        args: tuple[int] | Arc89IsMetadataImmutableArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_is_metadata_immutable(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_is_metadata_immutable(uint64)bool", v
            )
        )
        return self

    def arc89_is_metadata_short(
        self,
        args: tuple[int] | Arc89IsMetadataShortArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_is_metadata_short(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_is_metadata_short(uint64)(bool,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_header(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_header(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_header(uint64)(byte,byte,byte,byte[32],uint64,uint64)", v
            )
        )
        return self

    def arc89_get_metadata_pagination(
        self,
        args: tuple[int] | Arc89GetMetadataPaginationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_pagination(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_pagination(uint64)(uint16,uint16,uint8)", v
            )
        )
        return self

    def arc89_get_metadata(
        self,
        args: tuple[int, int] | Arc89GetMetadataArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata(uint64,uint8)(bool,uint64,byte[])", v
            )
        )
        return self

    def arc89_get_metadata_slice(
        self,
        args: tuple[int, int, int] | Arc89GetMetadataSliceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_slice(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_slice(uint64,uint16,uint16)byte[]", v
            )
        )
        return self

    def arc89_get_metadata_header_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHeaderHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_header_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_header_hash(uint64)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_page_hash(
        self,
        args: tuple[int, int] | Arc89GetMetadataPageHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_page_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_page_hash(uint64,uint8)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_hash(
        self,
        args: tuple[int] | Arc89GetMetadataHashArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_hash(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_hash(uint64)byte[32]", v
            )
        )
        return self

    def arc89_get_metadata_string_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataStringByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_string_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_string_by_key(uint64,string)string", v
            )
        )
        return self

    def arc89_get_metadata_uint64_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataUint64ByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_uint64_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_uint64_by_key(uint64,string)uint64", v
            )
        )
        return self

    def arc89_get_metadata_object_by_key(
        self,
        args: tuple[int, str] | Arc89GetMetadataObjectByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_object_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_object_by_key(uint64,string)string", v
            )
        )
        return self

    def arc89_get_metadata_b64_bytes_by_key(
        self,
        args: tuple[int, str, int] | Arc89GetMetadataB64BytesByKeyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc89_get_metadata_b64_bytes_by_key(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc89_get_metadata_b64_bytes_by_key(uint64,string,uint8)byte[]", v
            )
        )
        return self

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.extra_resources(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "extra_resources()void", v
            )
        )
        return self

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.withdraw_balance_excess(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "withdraw_balance_excess()void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "AsaMetadataRegistryComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "AsaMetadataRegistryComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
